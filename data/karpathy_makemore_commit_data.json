[{"commit_id": "f61811b994280cb12ddae15ef5800baa2e3a1ca4", "commit_message": "Merge pull request #3 from normanyu/fix-rnn-prev-state\n\nFix bug in RNN where hprev always referred to start.", "relative_path": "makemore.py", "previous_code_file": "\"\"\"\nyou give this script some words (one per line) and it will generate more things like it.\nuses super state of the art Transformer AI tech\nthis code is intended to be super hackable. tune it to your needs.\n\nChanges from minGPT:\n- I removed the from_pretrained function where we init with GPT2 weights\n- I removed dropout layers because the models we train here are small,\n  it's not necessary to understand at this stage and at this scale.\n- I removed weight decay and all of the complexity around what parameters are\n  and are not weight decayed. I don't believe this should make a massive\n  difference at the scale that we operate on here.\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport math\nimport argparse\nfrom dataclasses import dataclass\nfrom typing import List\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\nfrom torch.utils.data import Dataset\nfrom torch.utils.data.dataloader import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\n# -----------------------------------------------------------------------------\n\n@dataclass\nclass ModelConfig:\n    block_size: int = None # length of the input sequences of integers\n    vocab_size: int = None # the input integers are in range [0 .. vocab_size -1]\n    # parameters below control the sizes of each model slightly differently\n    n_layer: int = 4\n    n_embd: int = 64\n    n_embd2: int = 64\n    n_head: int = 4\n\n# -----------------------------------------------------------------------------\n# Transformer Language Model (*exactly* as used in GPT-2)\n\nclass NewGELU(nn.Module):\n    \"\"\"\n    Implementation of the GELU activation function currently in Google BERT repo (identical to OpenAI GPT).\n    Reference: Gaussian Error Linear Units (GELU) paper: https://arxiv.org/abs/1606.08415\n    \"\"\"\n    def forward(self, x):\n        return 0.5 * x * (1.0 + torch.tanh(math.sqrt(2.0 / math.pi) * (x + 0.044715 * torch.pow(x, 3.0))))\n\nclass CausalSelfAttention(nn.Module):\n    \"\"\"\n    A vanilla multi-head masked self-attention layer with a projection at the end.\n    It is possible to use torch.nn.MultiheadAttention here but I am including an\n    explicit implementation here to show that there is nothing too scary here.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.n_embd % config.n_head == 0\n        # key, query, value projections for all heads, but in a batch\n        self.c_attn = nn.Linear(config.n_embd, 3 * config.n_embd)\n        # output projection\n        self.c_proj = nn.Linear(config.n_embd, config.n_embd)\n        # causal mask to ensure that attention is only applied to the left in the input sequence\n        self.register_buffer(\"bias\", torch.tril(torch.ones(config.block_size, config.block_size))\n                                     .view(1, 1, config.block_size, config.block_size))\n        self.n_head = config.n_head\n        self.n_embd = config.n_embd\n\n    def forward(self, x):\n        B, T, C = x.size() # batch size, sequence length, embedding dimensionality (n_embd)\n\n        # calculate query, key, values for all heads in batch and move head forward to be the batch dim\n        q, k ,v  = self.c_attn(x).split(self.n_embd, dim=2)\n        k = k.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        q = q.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        v = v.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n\n        # causal self-attention; Self-attend: (B, nh, T, hs) x (B, nh, hs, T) -> (B, nh, T, T)\n        att = (q @ k.transpose(-2, -1)) * (1.0 / math.sqrt(k.size(-1)))\n        att = att.masked_fill(self.bias[:,:,:T,:T] == 0, float('-inf'))\n        att = F.softmax(att, dim=-1)\n        y = att @ v # (B, nh, T, T) x (B, nh, T, hs) -> (B, nh, T, hs)\n        y = y.transpose(1, 2).contiguous().view(B, T, C) # re-assemble all head outputs side by side\n\n        # output projection\n        y = self.c_proj(y)\n        return y\n\nclass Block(nn.Module):\n    \"\"\" an unassuming Transformer block \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.ln_1 = nn.LayerNorm(config.n_embd)\n        self.attn = CausalSelfAttention(config)\n        self.ln_2 = nn.LayerNorm(config.n_embd)\n        self.mlp = nn.ModuleDict(dict(\n            c_fc    = nn.Linear(config.n_embd, 4 * config.n_embd),\n            c_proj  = nn.Linear(4 * config.n_embd, config.n_embd),\n            act     = NewGELU(),\n        ))\n        m = self.mlp\n        self.mlpf = lambda x: m.c_proj(m.act(m.c_fc(x))) # MLP forward\n\n    def forward(self, x):\n        x = x + self.attn(self.ln_1(x))\n        x = x + self.mlpf(self.ln_2(x))\n        return x\n\nclass Transformer(nn.Module):\n    \"\"\" Transformer Language Model, exactly as seen in GPT-2 \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.block_size = config.block_size\n\n        self.transformer = nn.ModuleDict(dict(\n            wte = nn.Embedding(config.vocab_size, config.n_embd),\n            wpe = nn.Embedding(config.block_size, config.n_embd),\n            h = nn.ModuleList([Block(config) for _ in range(config.n_layer)]),\n            ln_f = nn.LayerNorm(config.n_embd),\n        ))\n        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n\n        # report number of parameters (note we don't count the decoder parameters in lm_head)\n        n_params = sum(p.numel() for p in self.transformer.parameters())\n        print(\"number of parameters: %.2fM\" % (n_params/1e6,))\n\n    def get_block_size(self):\n        return self.block_size\n\n    def forward(self, idx, targets=None):\n        device = idx.device\n        b, t = idx.size()\n        assert t <= self.block_size, f\"Cannot forward sequence of length {t}, block size is only {self.block_size}\"\n        pos = torch.arange(0, t, dtype=torch.long, device=device).unsqueeze(0) # shape (1, t)\n\n        # forward the GPT model itself\n        tok_emb = self.transformer.wte(idx) # token embeddings of shape (b, t, n_embd)\n        pos_emb = self.transformer.wpe(pos) # position embeddings of shape (1, t, n_embd)\n        x = tok_emb + pos_emb\n        for block in self.transformer.h:\n            x = block(x)\n        x = self.transformer.ln_f(x)\n        logits = self.lm_head(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n# Bag of Words (BoW) language model\n\nclass CausalBoW(nn.Module):\n    \"\"\"\n    Causal bag of words. Averages the preceding elements and looks suspiciously like\n    a CausalAttention module you'd find in a transformer, for no apparent reason at all ;)\n    \"\"\"\n    def __init__(self, config):\n        super().__init__()\n\n        # used to mask out vectors and preserve autoregressive property\n        self.block_size = config.block_size\n        self.register_buffer(\"bias\", torch.tril(torch.ones(config.block_size, config.block_size))\n                            .view(1, config.block_size, config.block_size))\n\n    def forward(self, x):\n        B, T, C = x.size() # batch size, sequence length, n_embd\n\n        # do the weighted average of all preceeding token features\n        att = torch.zeros((B, T, T), device=x.device)\n        att = att.masked_fill(self.bias[:,:T,:T] == 0, float('-inf'))\n        att = F.softmax(att, dim=-1)\n        y = att @ x # (B, T, T) x (B, T, C) -> (B, T, C)\n\n        return y\n\nclass BoWBlock(nn.Module):\n    \"\"\" collects BoW features and adds an MLP \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n\n        # Causal BoW module\n        self.cbow = CausalBoW(config)\n        # MLP assembler\n        self.mlp = nn.ModuleDict(dict(\n            c_fc    = nn.Linear(config.n_embd, config.n_embd2),\n            c_proj  = nn.Linear(config.n_embd2, config.n_embd),\n        ))\n        m = self.mlp\n        self.mlpf = lambda x: m.c_proj(F.tanh(m.c_fc(x))) # MLP forward\n\n    def forward(self, x):\n        x = x + self.cbow(x)\n        x = x + self.mlpf(x)\n        return x\n\nclass BoW(nn.Module):\n    \"\"\"\n    takes the previous block_size tokens, encodes them with a lookup table,\n    also encodes their positions with lookup table, then averages all of those\n    embeddings up and uses that to predict the next token.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.block_size = config.block_size\n        self.vocab_size = config.vocab_size\n        # token embedding\n        self.wte = nn.Embedding(config.vocab_size, config.n_embd)\n        # position embedding\n        self.wpe = nn.Embedding(config.block_size, config.n_embd)\n        # context block\n        self.context_block = BoWBlock(config)\n        # language model head decoder layer\n        self.lm_head = nn.Linear(config.n_embd, self.vocab_size)\n\n    def get_block_size(self):\n        return self.block_size\n\n    def forward(self, idx, targets=None):\n\n        device = idx.device\n        b, t = idx.size()\n        assert t <= self.block_size, f\"Cannot forward sequence of length {t}, block size is only {self.block_size}\"\n        pos = torch.arange(0, t, dtype=torch.long, device=device).unsqueeze(0) # shape (1, t)\n\n        # forward the token and position embedding layers\n        tok_emb = self.wte(idx) # token embeddings of shape (b, t, n_embd)\n        pos_emb = self.wpe(pos) # position embeddings of shape (1, t, n_embd)\n        # add and run through the decoder MLP\n        x = tok_emb + pos_emb\n        # run the bag of words context module\n        x = self.context_block(x)\n        # decode to next token probability\n        logits = self.lm_head(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n\"\"\"\nRecurrent Neural Net language model: either a vanilla RNN recurrence or a GRU.\nDid not implement an LSTM because its API is a bit more annoying as it has\nboth a hidden state and a cell state, but it's very similar to GRU and in\npractice works just as well.\n\"\"\"\n\nclass RNNCell(nn.Module):\n    \"\"\"\n    the job of a 'Cell' is to:\n    take input at current time step x_{t} and the hidden state at the\n    previous time step h_{t-1} and return the resulting hidden state\n    h_{t} at the current timestep\n    \"\"\"\n    def __init__(self, config):\n        super().__init__()\n        self.xh_to_h = nn.Linear(config.n_embd + config.n_embd2, config.n_embd2)\n\n    def forward(self, xt, hprev):\n        xh = torch.cat([xt, hprev], dim=1)\n        ht = F.tanh(self.xh_to_h(xh))\n        return ht\n\nclass GRUCell(nn.Module):\n    \"\"\"\n    same job as RNN cell, but a bit more complicated recurrence formula\n    that makes the GRU more expressive and easier to optimize.\n    \"\"\"\n    def __init__(self, config):\n        super().__init__()\n        # input, forget, output, gate\n        self.xh_to_z = nn.Linear(config.n_embd + config.n_embd2, config.n_embd2)\n        self.xh_to_r = nn.Linear(config.n_embd + config.n_embd2, config.n_embd2)\n        self.xh_to_hbar = nn.Linear(config.n_embd + config.n_embd2, config.n_embd2)\n\n    def forward(self, xt, hprev):\n        # first use the reset gate to wipe some channels of the hidden state to zero\n        xh = torch.cat([xt, hprev], dim=1)\n        r = F.sigmoid(self.xh_to_r(xh))\n        hprev_reset = r * hprev\n        # calculate the candidate new hidden state hbar\n        xhr = torch.cat([xt, hprev_reset], dim=1)\n        hbar = F.tanh(self.xh_to_hbar(xhr))\n        # calculate the switch gate that determines if each channel should be updated at all\n        z = F.sigmoid(self.xh_to_z(xh))\n        # blend the previous hidden state and the new candidate hidden state\n        ht = (1 - z) * hprev + z * hbar\n        return ht\n\nclass RNN(nn.Module):\n\n    def __init__(self, config, cell_type):\n        super().__init__()\n        self.block_size = config.block_size\n        self.vocab_size = config.vocab_size\n        self.start = nn.Parameter(torch.zeros(1, config.n_embd2)) # the starting hidden state\n        self.wte = nn.Embedding(config.vocab_size, config.n_embd) # token embeddings table\n        if cell_type == 'rnn':\n            self.cell = RNNCell(config)\n        elif cell_type == 'gru':\n            self.cell = GRUCell(config)\n        self.lm_head = nn.Linear(config.n_embd2, self.vocab_size)\n\n    def get_block_size(self):\n        return self.block_size\n\n    def forward(self, idx, targets=None):\n        device = idx.device\n        b, t = idx.size()\n\n        # embed all the integers up front and all at once for efficiency\n        emb = self.wte(idx) # (b, t, n_embd)\n\n        # sequentially iterate over the inputs and update the RNN state each tick\n        hprev = self.start.expand((b, -1)) # expand out the batch dimension\n        hiddens = []\n        for i in range(t):\n            xt = emb[:, i, :] # (b, n_embd)\n            ht = self.cell(xt, hprev) # (b, n_embd2)\n            hiddens.append(ht)\n\n        # decode the outputs\n        hidden = torch.stack(hiddens, 1) # (b, t, n_embd2)\n        logits = self.lm_head(hidden)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n# MLP language model\n\nclass MLP(nn.Module):\n    \"\"\"\n    takes the previous block_size tokens, encodes them with a lookup table,\n    concatenates the vectors and predicts the next token with an MLP.\n\n    Reference:\n    Bengio et al. 2003 https://www.jmlr.org/papers/volume3/bengio03a/bengio03a.pdf\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.block_size = config.block_size\n        self.vocab_size = config.vocab_size\n        self.wte = nn.Embedding(config.vocab_size + 1, config.n_embd) # token embeddings table\n        # +1 in the line above for a special <BLANK> token that gets inserted if encoding a token\n        # before the beginning of the input sequence\n        self.mlp = nn.Sequential(\n            nn.Linear(self.block_size * config.n_embd, config.n_embd2),\n            nn.Tanh(),\n            nn.Linear(config.n_embd2, self.vocab_size)\n        )\n\n    def get_block_size(self):\n        return self.block_size\n\n    def forward(self, idx, targets=None):\n\n        # gather the word embeddings of the previous 3 words\n        embs = []\n        for k in range(self.block_size):\n            tok_emb = self.wte(idx) # token embeddings of shape (b, t, n_embd)\n            idx = torch.roll(idx, 1, 1)\n            idx[:, 0] = self.vocab_size # special <BLANK> token\n            embs.append(tok_emb)\n\n        # concat all of the embeddings together and pass through an MLP\n        x = torch.cat(embs, -1) # (b, t, n_embd * block_size)\n        logits = self.mlp(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n# Bigram language model\n\nclass Bigram(nn.Module):\n    \"\"\"\n    Bigram Language Model 'neural net', simply a lookup table of logits for the\n    next character given a previous character.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        n = config.vocab_size\n        self.logits = nn.Parameter(torch.zeros((n, n)))\n\n    def get_block_size(self):\n        return 1 # this model only needs one previous character to predict the next\n\n    def forward(self, idx, targets=None):\n\n         # 'forward pass', lol\n        logits = self.logits[idx]\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n# helper functions for evaluating and sampling from the model\n\n@torch.no_grad()\ndef generate(model, idx, max_new_tokens, temperature=1.0, do_sample=False, top_k=None):\n    \"\"\"\n    Take a conditioning sequence of indices idx (LongTensor of shape (b,t)) and complete\n    the sequence max_new_tokens times, feeding the predictions back into the model each time.\n    Most likely you'll want to make sure to be in model.eval() mode of operation for this.\n    \"\"\"\n    block_size = model.get_block_size()\n    for _ in range(max_new_tokens):\n        # if the sequence context is growing too long we must crop it at block_size\n        idx_cond = idx if idx.size(1) <= block_size else idx[:, -block_size:]\n        # forward the model to get the logits for the index in the sequence\n        logits, _ = model(idx_cond)\n        # pluck the logits at the final step and scale by desired temperature\n        logits = logits[:, -1, :] / temperature\n        # optionally crop the logits to only the top k options\n        if top_k is not None:\n            v, _ = torch.topk(logits, top_k)\n            logits[logits < v[:, [-1]]] = -float('Inf')\n        # apply softmax to convert logits to (normalized) probabilities\n        probs = F.softmax(logits, dim=-1)\n        # either sample from the distribution or take the most likely element\n        if do_sample:\n            idx_next = torch.multinomial(probs, num_samples=1)\n        else:\n            _, idx_next = torch.topk(probs, k=1, dim=-1)\n        # append sampled index to the running sequence and continue\n        idx = torch.cat((idx, idx_next), dim=1)\n\n    return idx\n\ndef print_samples(num=10):\n    \"\"\" samples from the model and pretty prints the decoded samples \"\"\"\n    X_init = torch.zeros(num, 1, dtype=torch.long).to(args.device)\n    top_k = args.top_k if args.top_k != -1 else None\n    steps = train_dataset.get_output_length() - 1 # -1 because we already start with <START> token (index 0)\n    X_samp = generate(model, X_init, steps, top_k=top_k, do_sample=True).to('cpu')\n    train_samples, test_samples, new_samples = [], [], []\n    for i in range(X_samp.size(0)):\n        # get the i'th row of sampled integers, as python list\n        row = X_samp[i, 1:].tolist() # note: we need to crop out the first <START> token\n        # token 0 is the <STOP> token, so we crop the output sequence at that point\n        crop_index = row.index(0) if 0 in row else len(row)\n        row = row[:crop_index]\n        word_samp = train_dataset.decode(row)\n        # separately track samples that we have and have not seen before\n        if train_dataset.contains(word_samp):\n            train_samples.append(word_samp)\n        elif test_dataset.contains(word_samp):\n            test_samples.append(word_samp)\n        else:\n            new_samples.append(word_samp)\n    print('-'*80)\n    for lst, desc in [(train_samples, 'in train'), (test_samples, 'in test'), (new_samples, 'new')]:\n        print(f\"{len(lst)} samples that are {desc}:\")\n        for word in lst:\n            print(word)\n    print('-'*80)\n\n@torch.inference_mode()\ndef evaluate(model, dataset, batch_size=50, max_batches=None):\n    model.eval()\n    loader = DataLoader(dataset, shuffle=True, batch_size=batch_size, num_workers=0)\n    losses = []\n    for i, batch in enumerate(loader):\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n        logits, loss = model(X, Y)\n        losses.append(loss.item())\n        if max_batches is not None and i >= max_batches:\n            break\n    mean_loss = torch.tensor(losses).mean().item()\n    model.train() # reset model back to training mode\n    return mean_loss\n\n# -----------------------------------------------------------------------------\n# helper functions for creating the training and test Datasets that emit words\n\nclass CharDataset(Dataset):\n\n    def __init__(self, words, chars, max_word_length):\n        self.words = words\n        self.chars = chars\n        self.max_word_length = max_word_length\n        self.stoi = {ch:i+1 for i,ch in enumerate(chars)}\n        self.itos = {i:s for s,i in self.stoi.items()} # inverse mapping\n\n    def __len__(self):\n        return len(self.words)\n\n    def contains(self, word):\n        return word in self.words\n\n    def get_vocab_size(self):\n        return len(self.chars) + 1 # all the possible characters and special 0 token\n\n    def get_output_length(self):\n        return self.max_word_length + 1 # <START> token followed by words\n\n    def encode(self, word):\n        ix = torch.tensor([self.stoi[w] for w in word], dtype=torch.long)\n        return ix\n\n    def decode(self, ix):\n        word = ''.join(self.itos[i] for i in ix)\n        return word\n\n    def __getitem__(self, idx):\n        word = self.words[idx]\n        ix = self.encode(word)\n        x = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        y = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        x[1:1+len(ix)] = ix\n        y[:len(ix)] = ix\n        y[len(ix)+1:] = -1 # index -1 will mask the loss at the inactive locations\n        return x, y\n\ndef create_datasets(input_file):\n\n    # preprocessing of the input text file\n    with open(input_file, 'r') as f:\n        data = f.read()\n    words = data.splitlines()\n    words = [w.strip() for w in words] # get rid of any leading or trailing white space\n    words = [w for w in words if w] # get rid of any empty strings\n    chars = sorted(list(set(''.join(words)))) # all the possible characters\n    max_word_length = max(len(w) for w in words)\n    print(f\"number of examples in the dataset: {len(words)}\")\n    print(f\"max word length: {max_word_length}\")\n    print(f\"number of unique characters in the vocabulary: {len(chars)}\")\n    print(\"vocabulary:\")\n    print(''.join(chars))\n\n    # partition the input data into a training and the test set\n    test_set_size = min(1000, int(len(words) * 0.1)) # 10% of the training set, or up to 1000 examples\n    rp = torch.randperm(len(words)).tolist()\n    train_words = [words[i] for i in rp[:-test_set_size]]\n    test_words = [words[i] for i in rp[-test_set_size:]]\n    print(f\"split up the dataset into {len(train_words)} training examples and {len(test_words)} test examples\")\n\n    # wrap in dataset objects\n    train_dataset = CharDataset(train_words, chars, max_word_length)\n    test_dataset = CharDataset(test_words, chars, max_word_length)\n\n    return train_dataset, test_dataset\n\nclass InfiniteDataLoader:\n    \"\"\"\n    this is really hacky and I'm not proud of it, but there doesn't seem to be\n    a better way in PyTorch to just create an infinite dataloader?\n    \"\"\"\n\n    def __init__(self, dataset, **kwargs):\n        train_sampler = torch.utils.data.RandomSampler(dataset, replacement=True, num_samples=int(1e10))\n        self.train_loader = DataLoader(dataset, sampler=train_sampler, **kwargs)\n        self.data_iter = iter(self.train_loader)\n\n    def next(self):\n        try:\n            batch = next(self.data_iter)\n        except StopIteration: # this will technically only happen after 1e10 samples... (i.e. basically never)\n            self.data_iter = iter(self.train_loader)\n            batch = next(self.data_iter)\n        return batch\n\n# -----------------------------------------------------------------------------\nif __name__ == '__main__':\n\n    # parse command line args\n    parser = argparse.ArgumentParser(description=\"Make More\")\n    # system/input/output\n    parser.add_argument('--input-file', '-i', type=str, default='names.txt', help=\"input file with things one per line\")\n    parser.add_argument('--work-dir', '-o', type=str, default='out', help=\"output working directory\")\n    parser.add_argument('--resume', action='store_true', help=\"when this flag is used, we will resume optimization from existing model in the workdir\")\n    parser.add_argument('--sample-only', action='store_true', help=\"just sample from the model and quit, don't train\")\n    parser.add_argument('--num-workers', '-n', type=int, default=4, help=\"number of data workers for both train/test\")\n    parser.add_argument('--max-steps', type=int, default=-1, help=\"max number of optimization steps to run for, or -1 for infinite.\")\n    parser.add_argument('--device', type=str, default='cpu', help=\"device to use for compute, examples: cpu|cuda|cuda:2|mps\")\n    parser.add_argument('--seed', type=int, default=3407, help=\"seed\")\n    # sampling\n    parser.add_argument('--top-k', type=int, default=-1, help=\"top-k for sampling, -1 means no top-k\")\n    # model\n    parser.add_argument('--type', type=str, default='transformer', help=\"model class type to use, bigram|mlp|rnn|gru|bow|transformer\")\n    parser.add_argument('--n-layer', type=int, default=4, help=\"number of layers\")\n    parser.add_argument('--n-head', type=int, default=4, help=\"number of heads (in a transformer)\")\n    parser.add_argument('--n-embd', type=int, default=64, help=\"number of feature channels in the model\")\n    parser.add_argument('--n-embd2', type=int, default=64, help=\"number of feature channels elsewhere in the model\")\n    # optimization\n    parser.add_argument('--batch-size', '-b', type=int, default=32, help=\"batch size during optimization\")\n    parser.add_argument('--learning-rate', '-l', type=float, default=5e-4, help=\"learning rate\")\n    parser.add_argument('--weight-decay', '-w', type=float, default=0.01, help=\"weight decay\")\n    args = parser.parse_args()\n    print(vars(args))\n\n    # system inits\n    torch.manual_seed(args.seed)\n    torch.cuda.manual_seed_all(args.seed)\n    os.makedirs(args.work_dir, exist_ok=True)\n    writer = SummaryWriter(log_dir=args.work_dir)\n\n    # init datasets\n    train_dataset, test_dataset = create_datasets(args.input_file)\n    vocab_size = train_dataset.get_vocab_size()\n    block_size = train_dataset.get_output_length()\n    print(f\"dataset determined that: {vocab_size=}, {block_size=}\")\n\n    # init model\n    config = ModelConfig(vocab_size=vocab_size, block_size=block_size,\n                       n_layer=args.n_layer, n_head=args.n_head,\n                       n_embd=args.n_embd, n_embd2=args.n_embd2)\n    if args.type == 'transformer':\n        model = Transformer(config)\n    elif args.type == 'bigram':\n        model = Bigram(config)\n    elif args.type == 'mlp':\n        model = MLP(config)\n    elif args.type == 'rnn':\n        model = RNN(config, cell_type='rnn')\n    elif args.type == 'gru':\n        model = RNN(config, cell_type='gru')\n    elif args.type == 'bow':\n        model = BoW(config)\n    else:\n        raise ValueError(f'model type {args.type} is not recognized')\n    model.to(args.device)\n    print(f\"model #params: {sum(p.numel() for p in model.parameters())}\")\n    if args.resume or args.sample_only: # note: if we sample-only then we also assume we are resuming\n        print(\"resuming from existing model in the workdir\")\n        model.load_state_dict(torch.load(os.path.join(args.work_dir, 'model.pt')))\n    if args.sample_only:\n        print_samples(num=50)\n        sys.exit()\n\n    # init optimizer\n    optimizer = torch.optim.AdamW(model.parameters(), lr=args.learning_rate, weight_decay=args.weight_decay, betas=(0.9, 0.99), eps=1e-8)\n\n    # init dataloader\n    batch_loader = InfiniteDataLoader(train_dataset, batch_size=args.batch_size, pin_memory=True, num_workers=args.num_workers)\n\n    # training loop\n    best_loss = None\n    step = 0\n    while True:\n\n        t0 = time.time()\n\n        # get the next batch, ship to device, and unpack it to input and target\n        batch = batch_loader.next()\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n\n        # feed into the model\n        logits, loss = model(X, Y)\n\n        # calculate the gradient, update the weights\n        model.zero_grad(set_to_none=True)\n        loss.backward()\n        optimizer.step()\n\n        # wait for all CUDA work on the GPU to finish then calculate iteration time taken\n        if args.device.startswith('cuda'):\n            torch.cuda.synchronize()\n        t1 = time.time()\n\n        # logging\n        if step % 10 == 0:\n            print(f\"step {step} | loss {loss.item():.4f} | step time {(t1-t0)*1000:.2f}ms\")\n\n        # evaluate the model\n        if step > 0 and step % 500 == 0:\n            train_loss = evaluate(model, train_dataset, batch_size=100, max_batches=10)\n            test_loss  = evaluate(model, test_dataset,  batch_size=100, max_batches=10)\n            writer.add_scalar(\"Loss/train\", train_loss, step)\n            writer.add_scalar(\"Loss/test\", test_loss, step)\n            writer.flush()\n            print(f\"step {step} train loss: {train_loss} test loss: {test_loss}\")\n            # save the model to disk if it has improved\n            if best_loss is None or test_loss < best_loss:\n                out_path = os.path.join(args.work_dir, \"model.pt\")\n                print(f\"test loss {test_loss} is the best so far, saving model to {out_path}\")\n                torch.save(model.state_dict(), out_path)\n                best_loss = test_loss\n\n        # sample from the model\n        if step > 0 and step % 200 == 0:\n            print_samples(num=10)\n\n        step += 1\n        # termination conditions\n        if args.max_steps >= 0 and step >= args.max_steps:\n            break\n\n", "previous_id": "2f5e8d746e87b3c8424474e35b702092ed7e9579", "new_code_file": "\"\"\"\nyou give this script some words (one per line) and it will generate more things like it.\nuses super state of the art Transformer AI tech\nthis code is intended to be super hackable. tune it to your needs.\n\nChanges from minGPT:\n- I removed the from_pretrained function where we init with GPT2 weights\n- I removed dropout layers because the models we train here are small,\n  it's not necessary to understand at this stage and at this scale.\n- I removed weight decay and all of the complexity around what parameters are\n  and are not weight decayed. I don't believe this should make a massive\n  difference at the scale that we operate on here.\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport math\nimport argparse\nfrom dataclasses import dataclass\nfrom typing import List\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\nfrom torch.utils.data import Dataset\nfrom torch.utils.data.dataloader import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\n# -----------------------------------------------------------------------------\n\n@dataclass\nclass ModelConfig:\n    block_size: int = None # length of the input sequences of integers\n    vocab_size: int = None # the input integers are in range [0 .. vocab_size -1]\n    # parameters below control the sizes of each model slightly differently\n    n_layer: int = 4\n    n_embd: int = 64\n    n_embd2: int = 64\n    n_head: int = 4\n\n# -----------------------------------------------------------------------------\n# Transformer Language Model (*exactly* as used in GPT-2)\n\nclass NewGELU(nn.Module):\n    \"\"\"\n    Implementation of the GELU activation function currently in Google BERT repo (identical to OpenAI GPT).\n    Reference: Gaussian Error Linear Units (GELU) paper: https://arxiv.org/abs/1606.08415\n    \"\"\"\n    def forward(self, x):\n        return 0.5 * x * (1.0 + torch.tanh(math.sqrt(2.0 / math.pi) * (x + 0.044715 * torch.pow(x, 3.0))))\n\nclass CausalSelfAttention(nn.Module):\n    \"\"\"\n    A vanilla multi-head masked self-attention layer with a projection at the end.\n    It is possible to use torch.nn.MultiheadAttention here but I am including an\n    explicit implementation here to show that there is nothing too scary here.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.n_embd % config.n_head == 0\n        # key, query, value projections for all heads, but in a batch\n        self.c_attn = nn.Linear(config.n_embd, 3 * config.n_embd)\n        # output projection\n        self.c_proj = nn.Linear(config.n_embd, config.n_embd)\n        # causal mask to ensure that attention is only applied to the left in the input sequence\n        self.register_buffer(\"bias\", torch.tril(torch.ones(config.block_size, config.block_size))\n                                     .view(1, 1, config.block_size, config.block_size))\n        self.n_head = config.n_head\n        self.n_embd = config.n_embd\n\n    def forward(self, x):\n        B, T, C = x.size() # batch size, sequence length, embedding dimensionality (n_embd)\n\n        # calculate query, key, values for all heads in batch and move head forward to be the batch dim\n        q, k ,v  = self.c_attn(x).split(self.n_embd, dim=2)\n        k = k.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        q = q.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        v = v.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n\n        # causal self-attention; Self-attend: (B, nh, T, hs) x (B, nh, hs, T) -> (B, nh, T, T)\n        att = (q @ k.transpose(-2, -1)) * (1.0 / math.sqrt(k.size(-1)))\n        att = att.masked_fill(self.bias[:,:,:T,:T] == 0, float('-inf'))\n        att = F.softmax(att, dim=-1)\n        y = att @ v # (B, nh, T, T) x (B, nh, T, hs) -> (B, nh, T, hs)\n        y = y.transpose(1, 2).contiguous().view(B, T, C) # re-assemble all head outputs side by side\n\n        # output projection\n        y = self.c_proj(y)\n        return y\n\nclass Block(nn.Module):\n    \"\"\" an unassuming Transformer block \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.ln_1 = nn.LayerNorm(config.n_embd)\n        self.attn = CausalSelfAttention(config)\n        self.ln_2 = nn.LayerNorm(config.n_embd)\n        self.mlp = nn.ModuleDict(dict(\n            c_fc    = nn.Linear(config.n_embd, 4 * config.n_embd),\n            c_proj  = nn.Linear(4 * config.n_embd, config.n_embd),\n            act     = NewGELU(),\n        ))\n        m = self.mlp\n        self.mlpf = lambda x: m.c_proj(m.act(m.c_fc(x))) # MLP forward\n\n    def forward(self, x):\n        x = x + self.attn(self.ln_1(x))\n        x = x + self.mlpf(self.ln_2(x))\n        return x\n\nclass Transformer(nn.Module):\n    \"\"\" Transformer Language Model, exactly as seen in GPT-2 \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.block_size = config.block_size\n\n        self.transformer = nn.ModuleDict(dict(\n            wte = nn.Embedding(config.vocab_size, config.n_embd),\n            wpe = nn.Embedding(config.block_size, config.n_embd),\n            h = nn.ModuleList([Block(config) for _ in range(config.n_layer)]),\n            ln_f = nn.LayerNorm(config.n_embd),\n        ))\n        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n\n        # report number of parameters (note we don't count the decoder parameters in lm_head)\n        n_params = sum(p.numel() for p in self.transformer.parameters())\n        print(\"number of parameters: %.2fM\" % (n_params/1e6,))\n\n    def get_block_size(self):\n        return self.block_size\n\n    def forward(self, idx, targets=None):\n        device = idx.device\n        b, t = idx.size()\n        assert t <= self.block_size, f\"Cannot forward sequence of length {t}, block size is only {self.block_size}\"\n        pos = torch.arange(0, t, dtype=torch.long, device=device).unsqueeze(0) # shape (1, t)\n\n        # forward the GPT model itself\n        tok_emb = self.transformer.wte(idx) # token embeddings of shape (b, t, n_embd)\n        pos_emb = self.transformer.wpe(pos) # position embeddings of shape (1, t, n_embd)\n        x = tok_emb + pos_emb\n        for block in self.transformer.h:\n            x = block(x)\n        x = self.transformer.ln_f(x)\n        logits = self.lm_head(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n# Bag of Words (BoW) language model\n\nclass CausalBoW(nn.Module):\n    \"\"\"\n    Causal bag of words. Averages the preceding elements and looks suspiciously like\n    a CausalAttention module you'd find in a transformer, for no apparent reason at all ;)\n    \"\"\"\n    def __init__(self, config):\n        super().__init__()\n\n        # used to mask out vectors and preserve autoregressive property\n        self.block_size = config.block_size\n        self.register_buffer(\"bias\", torch.tril(torch.ones(config.block_size, config.block_size))\n                            .view(1, config.block_size, config.block_size))\n\n    def forward(self, x):\n        B, T, C = x.size() # batch size, sequence length, n_embd\n\n        # do the weighted average of all preceeding token features\n        att = torch.zeros((B, T, T), device=x.device)\n        att = att.masked_fill(self.bias[:,:T,:T] == 0, float('-inf'))\n        att = F.softmax(att, dim=-1)\n        y = att @ x # (B, T, T) x (B, T, C) -> (B, T, C)\n\n        return y\n\nclass BoWBlock(nn.Module):\n    \"\"\" collects BoW features and adds an MLP \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n\n        # Causal BoW module\n        self.cbow = CausalBoW(config)\n        # MLP assembler\n        self.mlp = nn.ModuleDict(dict(\n            c_fc    = nn.Linear(config.n_embd, config.n_embd2),\n            c_proj  = nn.Linear(config.n_embd2, config.n_embd),\n        ))\n        m = self.mlp\n        self.mlpf = lambda x: m.c_proj(F.tanh(m.c_fc(x))) # MLP forward\n\n    def forward(self, x):\n        x = x + self.cbow(x)\n        x = x + self.mlpf(x)\n        return x\n\nclass BoW(nn.Module):\n    \"\"\"\n    takes the previous block_size tokens, encodes them with a lookup table,\n    also encodes their positions with lookup table, then averages all of those\n    embeddings up and uses that to predict the next token.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.block_size = config.block_size\n        self.vocab_size = config.vocab_size\n        # token embedding\n        self.wte = nn.Embedding(config.vocab_size, config.n_embd)\n        # position embedding\n        self.wpe = nn.Embedding(config.block_size, config.n_embd)\n        # context block\n        self.context_block = BoWBlock(config)\n        # language model head decoder layer\n        self.lm_head = nn.Linear(config.n_embd, self.vocab_size)\n\n    def get_block_size(self):\n        return self.block_size\n\n    def forward(self, idx, targets=None):\n\n        device = idx.device\n        b, t = idx.size()\n        assert t <= self.block_size, f\"Cannot forward sequence of length {t}, block size is only {self.block_size}\"\n        pos = torch.arange(0, t, dtype=torch.long, device=device).unsqueeze(0) # shape (1, t)\n\n        # forward the token and position embedding layers\n        tok_emb = self.wte(idx) # token embeddings of shape (b, t, n_embd)\n        pos_emb = self.wpe(pos) # position embeddings of shape (1, t, n_embd)\n        # add and run through the decoder MLP\n        x = tok_emb + pos_emb\n        # run the bag of words context module\n        x = self.context_block(x)\n        # decode to next token probability\n        logits = self.lm_head(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n\"\"\"\nRecurrent Neural Net language model: either a vanilla RNN recurrence or a GRU.\nDid not implement an LSTM because its API is a bit more annoying as it has\nboth a hidden state and a cell state, but it's very similar to GRU and in\npractice works just as well.\n\"\"\"\n\nclass RNNCell(nn.Module):\n    \"\"\"\n    the job of a 'Cell' is to:\n    take input at current time step x_{t} and the hidden state at the\n    previous time step h_{t-1} and return the resulting hidden state\n    h_{t} at the current timestep\n    \"\"\"\n    def __init__(self, config):\n        super().__init__()\n        self.xh_to_h = nn.Linear(config.n_embd + config.n_embd2, config.n_embd2)\n\n    def forward(self, xt, hprev):\n        xh = torch.cat([xt, hprev], dim=1)\n        ht = F.tanh(self.xh_to_h(xh))\n        return ht\n\nclass GRUCell(nn.Module):\n    \"\"\"\n    same job as RNN cell, but a bit more complicated recurrence formula\n    that makes the GRU more expressive and easier to optimize.\n    \"\"\"\n    def __init__(self, config):\n        super().__init__()\n        # input, forget, output, gate\n        self.xh_to_z = nn.Linear(config.n_embd + config.n_embd2, config.n_embd2)\n        self.xh_to_r = nn.Linear(config.n_embd + config.n_embd2, config.n_embd2)\n        self.xh_to_hbar = nn.Linear(config.n_embd + config.n_embd2, config.n_embd2)\n\n    def forward(self, xt, hprev):\n        # first use the reset gate to wipe some channels of the hidden state to zero\n        xh = torch.cat([xt, hprev], dim=1)\n        r = F.sigmoid(self.xh_to_r(xh))\n        hprev_reset = r * hprev\n        # calculate the candidate new hidden state hbar\n        xhr = torch.cat([xt, hprev_reset], dim=1)\n        hbar = F.tanh(self.xh_to_hbar(xhr))\n        # calculate the switch gate that determines if each channel should be updated at all\n        z = F.sigmoid(self.xh_to_z(xh))\n        # blend the previous hidden state and the new candidate hidden state\n        ht = (1 - z) * hprev + z * hbar\n        return ht\n\nclass RNN(nn.Module):\n\n    def __init__(self, config, cell_type):\n        super().__init__()\n        self.block_size = config.block_size\n        self.vocab_size = config.vocab_size\n        self.start = nn.Parameter(torch.zeros(1, config.n_embd2)) # the starting hidden state\n        self.wte = nn.Embedding(config.vocab_size, config.n_embd) # token embeddings table\n        if cell_type == 'rnn':\n            self.cell = RNNCell(config)\n        elif cell_type == 'gru':\n            self.cell = GRUCell(config)\n        self.lm_head = nn.Linear(config.n_embd2, self.vocab_size)\n\n    def get_block_size(self):\n        return self.block_size\n\n    def forward(self, idx, targets=None):\n        device = idx.device\n        b, t = idx.size()\n\n        # embed all the integers up front and all at once for efficiency\n        emb = self.wte(idx) # (b, t, n_embd)\n\n        # sequentially iterate over the inputs and update the RNN state each tick\n        hprev = self.start.expand((b, -1)) # expand out the batch dimension\n        hiddens = []\n        for i in range(t):\n            xt = emb[:, i, :] # (b, n_embd)\n            ht = self.cell(xt, hprev) # (b, n_embd2)\n            hprev = ht\n            hiddens.append(ht)\n\n        # decode the outputs\n        hidden = torch.stack(hiddens, 1) # (b, t, n_embd2)\n        logits = self.lm_head(hidden)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n# MLP language model\n\nclass MLP(nn.Module):\n    \"\"\"\n    takes the previous block_size tokens, encodes them with a lookup table,\n    concatenates the vectors and predicts the next token with an MLP.\n\n    Reference:\n    Bengio et al. 2003 https://www.jmlr.org/papers/volume3/bengio03a/bengio03a.pdf\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.block_size = config.block_size\n        self.vocab_size = config.vocab_size\n        self.wte = nn.Embedding(config.vocab_size + 1, config.n_embd) # token embeddings table\n        # +1 in the line above for a special <BLANK> token that gets inserted if encoding a token\n        # before the beginning of the input sequence\n        self.mlp = nn.Sequential(\n            nn.Linear(self.block_size * config.n_embd, config.n_embd2),\n            nn.Tanh(),\n            nn.Linear(config.n_embd2, self.vocab_size)\n        )\n\n    def get_block_size(self):\n        return self.block_size\n\n    def forward(self, idx, targets=None):\n\n        # gather the word embeddings of the previous 3 words\n        embs = []\n        for k in range(self.block_size):\n            tok_emb = self.wte(idx) # token embeddings of shape (b, t, n_embd)\n            idx = torch.roll(idx, 1, 1)\n            idx[:, 0] = self.vocab_size # special <BLANK> token\n            embs.append(tok_emb)\n\n        # concat all of the embeddings together and pass through an MLP\n        x = torch.cat(embs, -1) # (b, t, n_embd * block_size)\n        logits = self.mlp(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n# Bigram language model\n\nclass Bigram(nn.Module):\n    \"\"\"\n    Bigram Language Model 'neural net', simply a lookup table of logits for the\n    next character given a previous character.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        n = config.vocab_size\n        self.logits = nn.Parameter(torch.zeros((n, n)))\n\n    def get_block_size(self):\n        return 1 # this model only needs one previous character to predict the next\n\n    def forward(self, idx, targets=None):\n\n         # 'forward pass', lol\n        logits = self.logits[idx]\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n# helper functions for evaluating and sampling from the model\n\n@torch.no_grad()\ndef generate(model, idx, max_new_tokens, temperature=1.0, do_sample=False, top_k=None):\n    \"\"\"\n    Take a conditioning sequence of indices idx (LongTensor of shape (b,t)) and complete\n    the sequence max_new_tokens times, feeding the predictions back into the model each time.\n    Most likely you'll want to make sure to be in model.eval() mode of operation for this.\n    \"\"\"\n    block_size = model.get_block_size()\n    for _ in range(max_new_tokens):\n        # if the sequence context is growing too long we must crop it at block_size\n        idx_cond = idx if idx.size(1) <= block_size else idx[:, -block_size:]\n        # forward the model to get the logits for the index in the sequence\n        logits, _ = model(idx_cond)\n        # pluck the logits at the final step and scale by desired temperature\n        logits = logits[:, -1, :] / temperature\n        # optionally crop the logits to only the top k options\n        if top_k is not None:\n            v, _ = torch.topk(logits, top_k)\n            logits[logits < v[:, [-1]]] = -float('Inf')\n        # apply softmax to convert logits to (normalized) probabilities\n        probs = F.softmax(logits, dim=-1)\n        # either sample from the distribution or take the most likely element\n        if do_sample:\n            idx_next = torch.multinomial(probs, num_samples=1)\n        else:\n            _, idx_next = torch.topk(probs, k=1, dim=-1)\n        # append sampled index to the running sequence and continue\n        idx = torch.cat((idx, idx_next), dim=1)\n\n    return idx\n\ndef print_samples(num=10):\n    \"\"\" samples from the model and pretty prints the decoded samples \"\"\"\n    X_init = torch.zeros(num, 1, dtype=torch.long).to(args.device)\n    top_k = args.top_k if args.top_k != -1 else None\n    steps = train_dataset.get_output_length() - 1 # -1 because we already start with <START> token (index 0)\n    X_samp = generate(model, X_init, steps, top_k=top_k, do_sample=True).to('cpu')\n    train_samples, test_samples, new_samples = [], [], []\n    for i in range(X_samp.size(0)):\n        # get the i'th row of sampled integers, as python list\n        row = X_samp[i, 1:].tolist() # note: we need to crop out the first <START> token\n        # token 0 is the <STOP> token, so we crop the output sequence at that point\n        crop_index = row.index(0) if 0 in row else len(row)\n        row = row[:crop_index]\n        word_samp = train_dataset.decode(row)\n        # separately track samples that we have and have not seen before\n        if train_dataset.contains(word_samp):\n            train_samples.append(word_samp)\n        elif test_dataset.contains(word_samp):\n            test_samples.append(word_samp)\n        else:\n            new_samples.append(word_samp)\n    print('-'*80)\n    for lst, desc in [(train_samples, 'in train'), (test_samples, 'in test'), (new_samples, 'new')]:\n        print(f\"{len(lst)} samples that are {desc}:\")\n        for word in lst:\n            print(word)\n    print('-'*80)\n\n@torch.inference_mode()\ndef evaluate(model, dataset, batch_size=50, max_batches=None):\n    model.eval()\n    loader = DataLoader(dataset, shuffle=True, batch_size=batch_size, num_workers=0)\n    losses = []\n    for i, batch in enumerate(loader):\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n        logits, loss = model(X, Y)\n        losses.append(loss.item())\n        if max_batches is not None and i >= max_batches:\n            break\n    mean_loss = torch.tensor(losses).mean().item()\n    model.train() # reset model back to training mode\n    return mean_loss\n\n# -----------------------------------------------------------------------------\n# helper functions for creating the training and test Datasets that emit words\n\nclass CharDataset(Dataset):\n\n    def __init__(self, words, chars, max_word_length):\n        self.words = words\n        self.chars = chars\n        self.max_word_length = max_word_length\n        self.stoi = {ch:i+1 for i,ch in enumerate(chars)}\n        self.itos = {i:s for s,i in self.stoi.items()} # inverse mapping\n\n    def __len__(self):\n        return len(self.words)\n\n    def contains(self, word):\n        return word in self.words\n\n    def get_vocab_size(self):\n        return len(self.chars) + 1 # all the possible characters and special 0 token\n\n    def get_output_length(self):\n        return self.max_word_length + 1 # <START> token followed by words\n\n    def encode(self, word):\n        ix = torch.tensor([self.stoi[w] for w in word], dtype=torch.long)\n        return ix\n\n    def decode(self, ix):\n        word = ''.join(self.itos[i] for i in ix)\n        return word\n\n    def __getitem__(self, idx):\n        word = self.words[idx]\n        ix = self.encode(word)\n        x = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        y = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        x[1:1+len(ix)] = ix\n        y[:len(ix)] = ix\n        y[len(ix)+1:] = -1 # index -1 will mask the loss at the inactive locations\n        return x, y\n\ndef create_datasets(input_file):\n\n    # preprocessing of the input text file\n    with open(input_file, 'r') as f:\n        data = f.read()\n    words = data.splitlines()\n    words = [w.strip() for w in words] # get rid of any leading or trailing white space\n    words = [w for w in words if w] # get rid of any empty strings\n    chars = sorted(list(set(''.join(words)))) # all the possible characters\n    max_word_length = max(len(w) for w in words)\n    print(f\"number of examples in the dataset: {len(words)}\")\n    print(f\"max word length: {max_word_length}\")\n    print(f\"number of unique characters in the vocabulary: {len(chars)}\")\n    print(\"vocabulary:\")\n    print(''.join(chars))\n\n    # partition the input data into a training and the test set\n    test_set_size = min(1000, int(len(words) * 0.1)) # 10% of the training set, or up to 1000 examples\n    rp = torch.randperm(len(words)).tolist()\n    train_words = [words[i] for i in rp[:-test_set_size]]\n    test_words = [words[i] for i in rp[-test_set_size:]]\n    print(f\"split up the dataset into {len(train_words)} training examples and {len(test_words)} test examples\")\n\n    # wrap in dataset objects\n    train_dataset = CharDataset(train_words, chars, max_word_length)\n    test_dataset = CharDataset(test_words, chars, max_word_length)\n\n    return train_dataset, test_dataset\n\nclass InfiniteDataLoader:\n    \"\"\"\n    this is really hacky and I'm not proud of it, but there doesn't seem to be\n    a better way in PyTorch to just create an infinite dataloader?\n    \"\"\"\n\n    def __init__(self, dataset, **kwargs):\n        train_sampler = torch.utils.data.RandomSampler(dataset, replacement=True, num_samples=int(1e10))\n        self.train_loader = DataLoader(dataset, sampler=train_sampler, **kwargs)\n        self.data_iter = iter(self.train_loader)\n\n    def next(self):\n        try:\n            batch = next(self.data_iter)\n        except StopIteration: # this will technically only happen after 1e10 samples... (i.e. basically never)\n            self.data_iter = iter(self.train_loader)\n            batch = next(self.data_iter)\n        return batch\n\n# -----------------------------------------------------------------------------\nif __name__ == '__main__':\n\n    # parse command line args\n    parser = argparse.ArgumentParser(description=\"Make More\")\n    # system/input/output\n    parser.add_argument('--input-file', '-i', type=str, default='names.txt', help=\"input file with things one per line\")\n    parser.add_argument('--work-dir', '-o', type=str, default='out', help=\"output working directory\")\n    parser.add_argument('--resume', action='store_true', help=\"when this flag is used, we will resume optimization from existing model in the workdir\")\n    parser.add_argument('--sample-only', action='store_true', help=\"just sample from the model and quit, don't train\")\n    parser.add_argument('--num-workers', '-n', type=int, default=4, help=\"number of data workers for both train/test\")\n    parser.add_argument('--max-steps', type=int, default=-1, help=\"max number of optimization steps to run for, or -1 for infinite.\")\n    parser.add_argument('--device', type=str, default='cpu', help=\"device to use for compute, examples: cpu|cuda|cuda:2|mps\")\n    parser.add_argument('--seed', type=int, default=3407, help=\"seed\")\n    # sampling\n    parser.add_argument('--top-k', type=int, default=-1, help=\"top-k for sampling, -1 means no top-k\")\n    # model\n    parser.add_argument('--type', type=str, default='transformer', help=\"model class type to use, bigram|mlp|rnn|gru|bow|transformer\")\n    parser.add_argument('--n-layer', type=int, default=4, help=\"number of layers\")\n    parser.add_argument('--n-head', type=int, default=4, help=\"number of heads (in a transformer)\")\n    parser.add_argument('--n-embd', type=int, default=64, help=\"number of feature channels in the model\")\n    parser.add_argument('--n-embd2', type=int, default=64, help=\"number of feature channels elsewhere in the model\")\n    # optimization\n    parser.add_argument('--batch-size', '-b', type=int, default=32, help=\"batch size during optimization\")\n    parser.add_argument('--learning-rate', '-l', type=float, default=5e-4, help=\"learning rate\")\n    parser.add_argument('--weight-decay', '-w', type=float, default=0.01, help=\"weight decay\")\n    args = parser.parse_args()\n    print(vars(args))\n\n    # system inits\n    torch.manual_seed(args.seed)\n    torch.cuda.manual_seed_all(args.seed)\n    os.makedirs(args.work_dir, exist_ok=True)\n    writer = SummaryWriter(log_dir=args.work_dir)\n\n    # init datasets\n    train_dataset, test_dataset = create_datasets(args.input_file)\n    vocab_size = train_dataset.get_vocab_size()\n    block_size = train_dataset.get_output_length()\n    print(f\"dataset determined that: {vocab_size=}, {block_size=}\")\n\n    # init model\n    config = ModelConfig(vocab_size=vocab_size, block_size=block_size,\n                       n_layer=args.n_layer, n_head=args.n_head,\n                       n_embd=args.n_embd, n_embd2=args.n_embd2)\n    if args.type == 'transformer':\n        model = Transformer(config)\n    elif args.type == 'bigram':\n        model = Bigram(config)\n    elif args.type == 'mlp':\n        model = MLP(config)\n    elif args.type == 'rnn':\n        model = RNN(config, cell_type='rnn')\n    elif args.type == 'gru':\n        model = RNN(config, cell_type='gru')\n    elif args.type == 'bow':\n        model = BoW(config)\n    else:\n        raise ValueError(f'model type {args.type} is not recognized')\n    model.to(args.device)\n    print(f\"model #params: {sum(p.numel() for p in model.parameters())}\")\n    if args.resume or args.sample_only: # note: if we sample-only then we also assume we are resuming\n        print(\"resuming from existing model in the workdir\")\n        model.load_state_dict(torch.load(os.path.join(args.work_dir, 'model.pt')))\n    if args.sample_only:\n        print_samples(num=50)\n        sys.exit()\n\n    # init optimizer\n    optimizer = torch.optim.AdamW(model.parameters(), lr=args.learning_rate, weight_decay=args.weight_decay, betas=(0.9, 0.99), eps=1e-8)\n\n    # init dataloader\n    batch_loader = InfiniteDataLoader(train_dataset, batch_size=args.batch_size, pin_memory=True, num_workers=args.num_workers)\n\n    # training loop\n    best_loss = None\n    step = 0\n    while True:\n\n        t0 = time.time()\n\n        # get the next batch, ship to device, and unpack it to input and target\n        batch = batch_loader.next()\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n\n        # feed into the model\n        logits, loss = model(X, Y)\n\n        # calculate the gradient, update the weights\n        model.zero_grad(set_to_none=True)\n        loss.backward()\n        optimizer.step()\n\n        # wait for all CUDA work on the GPU to finish then calculate iteration time taken\n        if args.device.startswith('cuda'):\n            torch.cuda.synchronize()\n        t1 = time.time()\n\n        # logging\n        if step % 10 == 0:\n            print(f\"step {step} | loss {loss.item():.4f} | step time {(t1-t0)*1000:.2f}ms\")\n\n        # evaluate the model\n        if step > 0 and step % 500 == 0:\n            train_loss = evaluate(model, train_dataset, batch_size=100, max_batches=10)\n            test_loss  = evaluate(model, test_dataset,  batch_size=100, max_batches=10)\n            writer.add_scalar(\"Loss/train\", train_loss, step)\n            writer.add_scalar(\"Loss/test\", test_loss, step)\n            writer.flush()\n            print(f\"step {step} train loss: {train_loss} test loss: {test_loss}\")\n            # save the model to disk if it has improved\n            if best_loss is None or test_loss < best_loss:\n                out_path = os.path.join(args.work_dir, \"model.pt\")\n                print(f\"test loss {test_loss} is the best so far, saving model to {out_path}\")\n                torch.save(model.state_dict(), out_path)\n                best_loss = test_loss\n\n        # sample from the model\n        if step > 0 and step % 200 == 0:\n            print_samples(num=10)\n\n        step += 1\n        # termination conditions\n        if args.max_steps >= 0 and step >= args.max_steps:\n            break\n\n", "diff": "@@ -330,6 +330,7 @@ def forward(self, idx, targets=None):\n         for i in range(t):\n             xt = emb[:, i, :] # (b, n_embd)\n             ht = self.cell(xt, hprev) # (b, n_embd2)\n+            hprev = ht\n             hiddens.append(ht)\n \n         # decode the outputs", "status": "modified"}, {"commit_id": "bf386250141f18f61321bc4b9a56c7b67c0b1668", "commit_message": "Fix bug in RNN where hprev always referred to start. Change so that hprev refers to output of previous cell", "relative_path": "makemore.py", "previous_code_file": "\"\"\"\nyou give this script some words (one per line) and it will generate more things like it.\nuses super state of the art Transformer AI tech\nthis code is intended to be super hackable. tune it to your needs.\n\nChanges from minGPT:\n- I removed the from_pretrained function where we init with GPT2 weights\n- I removed dropout layers because the models we train here are small,\n  it's not necessary to understand at this stage and at this scale.\n- I removed weight decay and all of the complexity around what parameters are\n  and are not weight decayed. I don't believe this should make a massive\n  difference at the scale that we operate on here.\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport math\nimport argparse\nfrom dataclasses import dataclass\nfrom typing import List\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\nfrom torch.utils.data import Dataset\nfrom torch.utils.data.dataloader import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\n# -----------------------------------------------------------------------------\n\n@dataclass\nclass ModelConfig:\n    block_size: int = None # length of the input sequences of integers\n    vocab_size: int = None # the input integers are in range [0 .. vocab_size -1]\n    # parameters below control the sizes of each model slightly differently\n    n_layer: int = 4\n    n_embd: int = 64\n    n_embd2: int = 64\n    n_head: int = 4\n\n# -----------------------------------------------------------------------------\n# Transformer Language Model (*exactly* as used in GPT-2)\n\nclass NewGELU(nn.Module):\n    \"\"\"\n    Implementation of the GELU activation function currently in Google BERT repo (identical to OpenAI GPT).\n    Reference: Gaussian Error Linear Units (GELU) paper: https://arxiv.org/abs/1606.08415\n    \"\"\"\n    def forward(self, x):\n        return 0.5 * x * (1.0 + torch.tanh(math.sqrt(2.0 / math.pi) * (x + 0.044715 * torch.pow(x, 3.0))))\n\nclass CausalSelfAttention(nn.Module):\n    \"\"\"\n    A vanilla multi-head masked self-attention layer with a projection at the end.\n    It is possible to use torch.nn.MultiheadAttention here but I am including an\n    explicit implementation here to show that there is nothing too scary here.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.n_embd % config.n_head == 0\n        # key, query, value projections for all heads, but in a batch\n        self.c_attn = nn.Linear(config.n_embd, 3 * config.n_embd)\n        # output projection\n        self.c_proj = nn.Linear(config.n_embd, config.n_embd)\n        # causal mask to ensure that attention is only applied to the left in the input sequence\n        self.register_buffer(\"bias\", torch.tril(torch.ones(config.block_size, config.block_size))\n                                     .view(1, 1, config.block_size, config.block_size))\n        self.n_head = config.n_head\n        self.n_embd = config.n_embd\n\n    def forward(self, x):\n        B, T, C = x.size() # batch size, sequence length, embedding dimensionality (n_embd)\n\n        # calculate query, key, values for all heads in batch and move head forward to be the batch dim\n        q, k ,v  = self.c_attn(x).split(self.n_embd, dim=2)\n        k = k.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        q = q.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        v = v.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n\n        # causal self-attention; Self-attend: (B, nh, T, hs) x (B, nh, hs, T) -> (B, nh, T, T)\n        att = (q @ k.transpose(-2, -1)) * (1.0 / math.sqrt(k.size(-1)))\n        att = att.masked_fill(self.bias[:,:,:T,:T] == 0, float('-inf'))\n        att = F.softmax(att, dim=-1)\n        y = att @ v # (B, nh, T, T) x (B, nh, T, hs) -> (B, nh, T, hs)\n        y = y.transpose(1, 2).contiguous().view(B, T, C) # re-assemble all head outputs side by side\n\n        # output projection\n        y = self.c_proj(y)\n        return y\n\nclass Block(nn.Module):\n    \"\"\" an unassuming Transformer block \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.ln_1 = nn.LayerNorm(config.n_embd)\n        self.attn = CausalSelfAttention(config)\n        self.ln_2 = nn.LayerNorm(config.n_embd)\n        self.mlp = nn.ModuleDict(dict(\n            c_fc    = nn.Linear(config.n_embd, 4 * config.n_embd),\n            c_proj  = nn.Linear(4 * config.n_embd, config.n_embd),\n            act     = NewGELU(),\n        ))\n        m = self.mlp\n        self.mlpf = lambda x: m.c_proj(m.act(m.c_fc(x))) # MLP forward\n\n    def forward(self, x):\n        x = x + self.attn(self.ln_1(x))\n        x = x + self.mlpf(self.ln_2(x))\n        return x\n\nclass Transformer(nn.Module):\n    \"\"\" Transformer Language Model, exactly as seen in GPT-2 \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.block_size = config.block_size\n\n        self.transformer = nn.ModuleDict(dict(\n            wte = nn.Embedding(config.vocab_size, config.n_embd),\n            wpe = nn.Embedding(config.block_size, config.n_embd),\n            h = nn.ModuleList([Block(config) for _ in range(config.n_layer)]),\n            ln_f = nn.LayerNorm(config.n_embd),\n        ))\n        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n\n        # report number of parameters (note we don't count the decoder parameters in lm_head)\n        n_params = sum(p.numel() for p in self.transformer.parameters())\n        print(\"number of parameters: %.2fM\" % (n_params/1e6,))\n\n    def get_block_size(self):\n        return self.block_size\n\n    def forward(self, idx, targets=None):\n        device = idx.device\n        b, t = idx.size()\n        assert t <= self.block_size, f\"Cannot forward sequence of length {t}, block size is only {self.block_size}\"\n        pos = torch.arange(0, t, dtype=torch.long, device=device).unsqueeze(0) # shape (1, t)\n\n        # forward the GPT model itself\n        tok_emb = self.transformer.wte(idx) # token embeddings of shape (b, t, n_embd)\n        pos_emb = self.transformer.wpe(pos) # position embeddings of shape (1, t, n_embd)\n        x = tok_emb + pos_emb\n        for block in self.transformer.h:\n            x = block(x)\n        x = self.transformer.ln_f(x)\n        logits = self.lm_head(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n# Bag of Words (BoW) language model\n\nclass CausalBoW(nn.Module):\n    \"\"\"\n    Causal bag of words. Averages the preceding elements and looks suspiciously like\n    a CausalAttention module you'd find in a transformer, for no apparent reason at all ;)\n    \"\"\"\n    def __init__(self, config):\n        super().__init__()\n\n        # used to mask out vectors and preserve autoregressive property\n        self.block_size = config.block_size\n        self.register_buffer(\"bias\", torch.tril(torch.ones(config.block_size, config.block_size))\n                            .view(1, config.block_size, config.block_size))\n\n    def forward(self, x):\n        B, T, C = x.size() # batch size, sequence length, n_embd\n\n        # do the weighted average of all preceeding token features\n        att = torch.zeros((B, T, T), device=x.device)\n        att = att.masked_fill(self.bias[:,:T,:T] == 0, float('-inf'))\n        att = F.softmax(att, dim=-1)\n        y = att @ x # (B, T, T) x (B, T, C) -> (B, T, C)\n\n        return y\n\nclass BoWBlock(nn.Module):\n    \"\"\" collects BoW features and adds an MLP \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n\n        # Causal BoW module\n        self.cbow = CausalBoW(config)\n        # MLP assembler\n        self.mlp = nn.ModuleDict(dict(\n            c_fc    = nn.Linear(config.n_embd, config.n_embd2),\n            c_proj  = nn.Linear(config.n_embd2, config.n_embd),\n        ))\n        m = self.mlp\n        self.mlpf = lambda x: m.c_proj(F.tanh(m.c_fc(x))) # MLP forward\n\n    def forward(self, x):\n        x = x + self.cbow(x)\n        x = x + self.mlpf(x)\n        return x\n\nclass BoW(nn.Module):\n    \"\"\"\n    takes the previous block_size tokens, encodes them with a lookup table,\n    also encodes their positions with lookup table, then averages all of those\n    embeddings up and uses that to predict the next token.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.block_size = config.block_size\n        self.vocab_size = config.vocab_size\n        # token embedding\n        self.wte = nn.Embedding(config.vocab_size, config.n_embd)\n        # position embedding\n        self.wpe = nn.Embedding(config.block_size, config.n_embd)\n        # context block\n        self.context_block = BoWBlock(config)\n        # language model head decoder layer\n        self.lm_head = nn.Linear(config.n_embd, self.vocab_size)\n\n    def get_block_size(self):\n        return self.block_size\n\n    def forward(self, idx, targets=None):\n\n        device = idx.device\n        b, t = idx.size()\n        assert t <= self.block_size, f\"Cannot forward sequence of length {t}, block size is only {self.block_size}\"\n        pos = torch.arange(0, t, dtype=torch.long, device=device).unsqueeze(0) # shape (1, t)\n\n        # forward the token and position embedding layers\n        tok_emb = self.wte(idx) # token embeddings of shape (b, t, n_embd)\n        pos_emb = self.wpe(pos) # position embeddings of shape (1, t, n_embd)\n        # add and run through the decoder MLP\n        x = tok_emb + pos_emb\n        # run the bag of words context module\n        x = self.context_block(x)\n        # decode to next token probability\n        logits = self.lm_head(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n\"\"\"\nRecurrent Neural Net language model: either a vanilla RNN recurrence or a GRU.\nDid not implement an LSTM because its API is a bit more annoying as it has\nboth a hidden state and a cell state, but it's very similar to GRU and in\npractice works just as well.\n\"\"\"\n\nclass RNNCell(nn.Module):\n    \"\"\"\n    the job of a 'Cell' is to:\n    take input at current time step x_{t} and the hidden state at the\n    previous time step h_{t-1} and return the resulting hidden state\n    h_{t} at the current timestep\n    \"\"\"\n    def __init__(self, config):\n        super().__init__()\n        self.xh_to_h = nn.Linear(config.n_embd + config.n_embd2, config.n_embd2)\n\n    def forward(self, xt, hprev):\n        xh = torch.cat([xt, hprev], dim=1)\n        ht = F.tanh(self.xh_to_h(xh))\n        return ht\n\nclass GRUCell(nn.Module):\n    \"\"\"\n    same job as RNN cell, but a bit more complicated recurrence formula\n    that makes the GRU more expressive and easier to optimize.\n    \"\"\"\n    def __init__(self, config):\n        super().__init__()\n        # input, forget, output, gate\n        self.xh_to_z = nn.Linear(config.n_embd + config.n_embd2, config.n_embd2)\n        self.xh_to_r = nn.Linear(config.n_embd + config.n_embd2, config.n_embd2)\n        self.xh_to_hbar = nn.Linear(config.n_embd + config.n_embd2, config.n_embd2)\n\n    def forward(self, xt, hprev):\n        # first use the reset gate to wipe some channels of the hidden state to zero\n        xh = torch.cat([xt, hprev], dim=1)\n        r = F.sigmoid(self.xh_to_r(xh))\n        hprev_reset = r * hprev\n        # calculate the candidate new hidden state hbar\n        xhr = torch.cat([xt, hprev_reset], dim=1)\n        hbar = F.tanh(self.xh_to_hbar(xhr))\n        # calculate the switch gate that determines if each channel should be updated at all\n        z = F.sigmoid(self.xh_to_z(xh))\n        # blend the previous hidden state and the new candidate hidden state\n        ht = (1 - z) * hprev + z * hbar\n        return ht\n\nclass RNN(nn.Module):\n\n    def __init__(self, config, cell_type):\n        super().__init__()\n        self.block_size = config.block_size\n        self.vocab_size = config.vocab_size\n        self.start = nn.Parameter(torch.zeros(1, config.n_embd2)) # the starting hidden state\n        self.wte = nn.Embedding(config.vocab_size, config.n_embd) # token embeddings table\n        if cell_type == 'rnn':\n            self.cell = RNNCell(config)\n        elif cell_type == 'gru':\n            self.cell = GRUCell(config)\n        self.lm_head = nn.Linear(config.n_embd2, self.vocab_size)\n\n    def get_block_size(self):\n        return self.block_size\n\n    def forward(self, idx, targets=None):\n        device = idx.device\n        b, t = idx.size()\n\n        # embed all the integers up front and all at once for efficiency\n        emb = self.wte(idx) # (b, t, n_embd)\n\n        # sequentially iterate over the inputs and update the RNN state each tick\n        hprev = self.start.expand((b, -1)) # expand out the batch dimension\n        hiddens = []\n        for i in range(t):\n            xt = emb[:, i, :] # (b, n_embd)\n            ht = self.cell(xt, hprev) # (b, n_embd2)\n            hiddens.append(ht)\n\n        # decode the outputs\n        hidden = torch.stack(hiddens, 1) # (b, t, n_embd2)\n        logits = self.lm_head(hidden)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n# MLP language model\n\nclass MLP(nn.Module):\n    \"\"\"\n    takes the previous block_size tokens, encodes them with a lookup table,\n    concatenates the vectors and predicts the next token with an MLP.\n\n    Reference:\n    Bengio et al. 2003 https://www.jmlr.org/papers/volume3/bengio03a/bengio03a.pdf\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.block_size = config.block_size\n        self.vocab_size = config.vocab_size\n        self.wte = nn.Embedding(config.vocab_size + 1, config.n_embd) # token embeddings table\n        # +1 in the line above for a special <BLANK> token that gets inserted if encoding a token\n        # before the beginning of the input sequence\n        self.mlp = nn.Sequential(\n            nn.Linear(self.block_size * config.n_embd, config.n_embd2),\n            nn.Tanh(),\n            nn.Linear(config.n_embd2, self.vocab_size)\n        )\n\n    def get_block_size(self):\n        return self.block_size\n\n    def forward(self, idx, targets=None):\n\n        # gather the word embeddings of the previous 3 words\n        embs = []\n        for k in range(self.block_size):\n            tok_emb = self.wte(idx) # token embeddings of shape (b, t, n_embd)\n            idx = torch.roll(idx, 1, 1)\n            idx[:, 0] = self.vocab_size # special <BLANK> token\n            embs.append(tok_emb)\n\n        # concat all of the embeddings together and pass through an MLP\n        x = torch.cat(embs, -1) # (b, t, n_embd * block_size)\n        logits = self.mlp(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n# Bigram language model\n\nclass Bigram(nn.Module):\n    \"\"\"\n    Bigram Language Model 'neural net', simply a lookup table of logits for the\n    next character given a previous character.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        n = config.vocab_size\n        self.logits = nn.Parameter(torch.zeros((n, n)))\n\n    def get_block_size(self):\n        return 1 # this model only needs one previous character to predict the next\n\n    def forward(self, idx, targets=None):\n\n         # 'forward pass', lol\n        logits = self.logits[idx]\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n# helper functions for evaluating and sampling from the model\n\n@torch.no_grad()\ndef generate(model, idx, max_new_tokens, temperature=1.0, do_sample=False, top_k=None):\n    \"\"\"\n    Take a conditioning sequence of indices idx (LongTensor of shape (b,t)) and complete\n    the sequence max_new_tokens times, feeding the predictions back into the model each time.\n    Most likely you'll want to make sure to be in model.eval() mode of operation for this.\n    \"\"\"\n    block_size = model.get_block_size()\n    for _ in range(max_new_tokens):\n        # if the sequence context is growing too long we must crop it at block_size\n        idx_cond = idx if idx.size(1) <= block_size else idx[:, -block_size:]\n        # forward the model to get the logits for the index in the sequence\n        logits, _ = model(idx_cond)\n        # pluck the logits at the final step and scale by desired temperature\n        logits = logits[:, -1, :] / temperature\n        # optionally crop the logits to only the top k options\n        if top_k is not None:\n            v, _ = torch.topk(logits, top_k)\n            logits[logits < v[:, [-1]]] = -float('Inf')\n        # apply softmax to convert logits to (normalized) probabilities\n        probs = F.softmax(logits, dim=-1)\n        # either sample from the distribution or take the most likely element\n        if do_sample:\n            idx_next = torch.multinomial(probs, num_samples=1)\n        else:\n            _, idx_next = torch.topk(probs, k=1, dim=-1)\n        # append sampled index to the running sequence and continue\n        idx = torch.cat((idx, idx_next), dim=1)\n\n    return idx\n\ndef print_samples(num=10):\n    \"\"\" samples from the model and pretty prints the decoded samples \"\"\"\n    X_init = torch.zeros(num, 1, dtype=torch.long).to(args.device)\n    top_k = args.top_k if args.top_k != -1 else None\n    steps = train_dataset.get_output_length() - 1 # -1 because we already start with <START> token (index 0)\n    X_samp = generate(model, X_init, steps, top_k=top_k, do_sample=True).to('cpu')\n    train_samples, test_samples, new_samples = [], [], []\n    for i in range(X_samp.size(0)):\n        # get the i'th row of sampled integers, as python list\n        row = X_samp[i, 1:].tolist() # note: we need to crop out the first <START> token\n        # token 0 is the <STOP> token, so we crop the output sequence at that point\n        crop_index = row.index(0) if 0 in row else len(row)\n        row = row[:crop_index]\n        word_samp = train_dataset.decode(row)\n        # separately track samples that we have and have not seen before\n        if train_dataset.contains(word_samp):\n            train_samples.append(word_samp)\n        elif test_dataset.contains(word_samp):\n            test_samples.append(word_samp)\n        else:\n            new_samples.append(word_samp)\n    print('-'*80)\n    for lst, desc in [(train_samples, 'in train'), (test_samples, 'in test'), (new_samples, 'new')]:\n        print(f\"{len(lst)} samples that are {desc}:\")\n        for word in lst:\n            print(word)\n    print('-'*80)\n\n@torch.inference_mode()\ndef evaluate(model, dataset, batch_size=50, max_batches=None):\n    model.eval()\n    loader = DataLoader(dataset, shuffle=True, batch_size=batch_size, num_workers=0)\n    losses = []\n    for i, batch in enumerate(loader):\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n        logits, loss = model(X, Y)\n        losses.append(loss.item())\n        if max_batches is not None and i >= max_batches:\n            break\n    mean_loss = torch.tensor(losses).mean().item()\n    model.train() # reset model back to training mode\n    return mean_loss\n\n# -----------------------------------------------------------------------------\n# helper functions for creating the training and test Datasets that emit words\n\nclass CharDataset(Dataset):\n\n    def __init__(self, words, chars, max_word_length):\n        self.words = words\n        self.chars = chars\n        self.max_word_length = max_word_length\n        self.stoi = {ch:i+1 for i,ch in enumerate(chars)}\n        self.itos = {i:s for s,i in self.stoi.items()} # inverse mapping\n\n    def __len__(self):\n        return len(self.words)\n\n    def contains(self, word):\n        return word in self.words\n\n    def get_vocab_size(self):\n        return len(self.chars) + 1 # all the possible characters and special 0 token\n\n    def get_output_length(self):\n        return self.max_word_length + 1 # <START> token followed by words\n\n    def encode(self, word):\n        ix = torch.tensor([self.stoi[w] for w in word], dtype=torch.long)\n        return ix\n\n    def decode(self, ix):\n        word = ''.join(self.itos[i] for i in ix)\n        return word\n\n    def __getitem__(self, idx):\n        word = self.words[idx]\n        ix = self.encode(word)\n        x = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        y = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        x[1:1+len(ix)] = ix\n        y[:len(ix)] = ix\n        y[len(ix)+1:] = -1 # index -1 will mask the loss at the inactive locations\n        return x, y\n\ndef create_datasets(input_file):\n\n    # preprocessing of the input text file\n    with open(input_file, 'r') as f:\n        data = f.read()\n    words = data.splitlines()\n    words = [w.strip() for w in words] # get rid of any leading or trailing white space\n    words = [w for w in words if w] # get rid of any empty strings\n    chars = sorted(list(set(''.join(words)))) # all the possible characters\n    max_word_length = max(len(w) for w in words)\n    print(f\"number of examples in the dataset: {len(words)}\")\n    print(f\"max word length: {max_word_length}\")\n    print(f\"number of unique characters in the vocabulary: {len(chars)}\")\n    print(\"vocabulary:\")\n    print(''.join(chars))\n\n    # partition the input data into a training and the test set\n    test_set_size = min(1000, int(len(words) * 0.1)) # 10% of the training set, or up to 1000 examples\n    rp = torch.randperm(len(words)).tolist()\n    train_words = [words[i] for i in rp[:-test_set_size]]\n    test_words = [words[i] for i in rp[-test_set_size:]]\n    print(f\"split up the dataset into {len(train_words)} training examples and {len(test_words)} test examples\")\n\n    # wrap in dataset objects\n    train_dataset = CharDataset(train_words, chars, max_word_length)\n    test_dataset = CharDataset(test_words, chars, max_word_length)\n\n    return train_dataset, test_dataset\n\nclass InfiniteDataLoader:\n    \"\"\"\n    this is really hacky and I'm not proud of it, but there doesn't seem to be\n    a better way in PyTorch to just create an infinite dataloader?\n    \"\"\"\n\n    def __init__(self, dataset, **kwargs):\n        train_sampler = torch.utils.data.RandomSampler(dataset, replacement=True, num_samples=int(1e10))\n        self.train_loader = DataLoader(dataset, sampler=train_sampler, **kwargs)\n        self.data_iter = iter(self.train_loader)\n\n    def next(self):\n        try:\n            batch = next(self.data_iter)\n        except StopIteration: # this will technically only happen after 1e10 samples... (i.e. basically never)\n            self.data_iter = iter(self.train_loader)\n            batch = next(self.data_iter)\n        return batch\n\n# -----------------------------------------------------------------------------\nif __name__ == '__main__':\n\n    # parse command line args\n    parser = argparse.ArgumentParser(description=\"Make More\")\n    # system/input/output\n    parser.add_argument('--input-file', '-i', type=str, default='names.txt', help=\"input file with things one per line\")\n    parser.add_argument('--work-dir', '-o', type=str, default='out', help=\"output working directory\")\n    parser.add_argument('--resume', action='store_true', help=\"when this flag is used, we will resume optimization from existing model in the workdir\")\n    parser.add_argument('--sample-only', action='store_true', help=\"just sample from the model and quit, don't train\")\n    parser.add_argument('--num-workers', '-n', type=int, default=4, help=\"number of data workers for both train/test\")\n    parser.add_argument('--max-steps', type=int, default=-1, help=\"max number of optimization steps to run for, or -1 for infinite.\")\n    parser.add_argument('--device', type=str, default='cpu', help=\"device to use for compute, examples: cpu|cuda|cuda:2|mps\")\n    parser.add_argument('--seed', type=int, default=3407, help=\"seed\")\n    # sampling\n    parser.add_argument('--top-k', type=int, default=-1, help=\"top-k for sampling, -1 means no top-k\")\n    # model\n    parser.add_argument('--type', type=str, default='transformer', help=\"model class type to use, bigram|mlp|rnn|gru|bow|transformer\")\n    parser.add_argument('--n-layer', type=int, default=4, help=\"number of layers\")\n    parser.add_argument('--n-head', type=int, default=4, help=\"number of heads (in a transformer)\")\n    parser.add_argument('--n-embd', type=int, default=64, help=\"number of feature channels in the model\")\n    parser.add_argument('--n-embd2', type=int, default=64, help=\"number of feature channels elsewhere in the model\")\n    # optimization\n    parser.add_argument('--batch-size', '-b', type=int, default=32, help=\"batch size during optimization\")\n    parser.add_argument('--learning-rate', '-l', type=float, default=5e-4, help=\"learning rate\")\n    parser.add_argument('--weight-decay', '-w', type=float, default=0.01, help=\"weight decay\")\n    args = parser.parse_args()\n    print(vars(args))\n\n    # system inits\n    torch.manual_seed(args.seed)\n    torch.cuda.manual_seed_all(args.seed)\n    os.makedirs(args.work_dir, exist_ok=True)\n    writer = SummaryWriter(log_dir=args.work_dir)\n\n    # init datasets\n    train_dataset, test_dataset = create_datasets(args.input_file)\n    vocab_size = train_dataset.get_vocab_size()\n    block_size = train_dataset.get_output_length()\n    print(f\"dataset determined that: {vocab_size=}, {block_size=}\")\n\n    # init model\n    config = ModelConfig(vocab_size=vocab_size, block_size=block_size,\n                       n_layer=args.n_layer, n_head=args.n_head,\n                       n_embd=args.n_embd, n_embd2=args.n_embd2)\n    if args.type == 'transformer':\n        model = Transformer(config)\n    elif args.type == 'bigram':\n        model = Bigram(config)\n    elif args.type == 'mlp':\n        model = MLP(config)\n    elif args.type == 'rnn':\n        model = RNN(config, cell_type='rnn')\n    elif args.type == 'gru':\n        model = RNN(config, cell_type='gru')\n    elif args.type == 'bow':\n        model = BoW(config)\n    else:\n        raise ValueError(f'model type {args.type} is not recognized')\n    model.to(args.device)\n    print(f\"model #params: {sum(p.numel() for p in model.parameters())}\")\n    if args.resume or args.sample_only: # note: if we sample-only then we also assume we are resuming\n        print(\"resuming from existing model in the workdir\")\n        model.load_state_dict(torch.load(os.path.join(args.work_dir, 'model.pt')))\n    if args.sample_only:\n        print_samples(num=50)\n        sys.exit()\n\n    # init optimizer\n    optimizer = torch.optim.AdamW(model.parameters(), lr=args.learning_rate, weight_decay=args.weight_decay, betas=(0.9, 0.99), eps=1e-8)\n\n    # init dataloader\n    batch_loader = InfiniteDataLoader(train_dataset, batch_size=args.batch_size, pin_memory=True, num_workers=args.num_workers)\n\n    # training loop\n    best_loss = None\n    step = 0\n    while True:\n\n        t0 = time.time()\n\n        # get the next batch, ship to device, and unpack it to input and target\n        batch = batch_loader.next()\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n\n        # feed into the model\n        logits, loss = model(X, Y)\n\n        # calculate the gradient, update the weights\n        model.zero_grad(set_to_none=True)\n        loss.backward()\n        optimizer.step()\n\n        # wait for all CUDA work on the GPU to finish then calculate iteration time taken\n        if args.device.startswith('cuda'):\n            torch.cuda.synchronize()\n        t1 = time.time()\n\n        # logging\n        if step % 10 == 0:\n            print(f\"step {step} | loss {loss.item():.4f} | step time {(t1-t0)*1000:.2f}ms\")\n\n        # evaluate the model\n        if step > 0 and step % 500 == 0:\n            train_loss = evaluate(model, train_dataset, batch_size=100, max_batches=10)\n            test_loss  = evaluate(model, test_dataset,  batch_size=100, max_batches=10)\n            writer.add_scalar(\"Loss/train\", train_loss, step)\n            writer.add_scalar(\"Loss/test\", test_loss, step)\n            writer.flush()\n            print(f\"step {step} train loss: {train_loss} test loss: {test_loss}\")\n            # save the model to disk if it has improved\n            if best_loss is None or test_loss < best_loss:\n                out_path = os.path.join(args.work_dir, \"model.pt\")\n                print(f\"test loss {test_loss} is the best so far, saving model to {out_path}\")\n                torch.save(model.state_dict(), out_path)\n                best_loss = test_loss\n\n        # sample from the model\n        if step > 0 and step % 200 == 0:\n            print_samples(num=10)\n\n        step += 1\n        # termination conditions\n        if args.max_steps >= 0 and step >= args.max_steps:\n            break\n\n", "previous_id": "2f5e8d746e87b3c8424474e35b702092ed7e9579", "new_code_file": "\"\"\"\nyou give this script some words (one per line) and it will generate more things like it.\nuses super state of the art Transformer AI tech\nthis code is intended to be super hackable. tune it to your needs.\n\nChanges from minGPT:\n- I removed the from_pretrained function where we init with GPT2 weights\n- I removed dropout layers because the models we train here are small,\n  it's not necessary to understand at this stage and at this scale.\n- I removed weight decay and all of the complexity around what parameters are\n  and are not weight decayed. I don't believe this should make a massive\n  difference at the scale that we operate on here.\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport math\nimport argparse\nfrom dataclasses import dataclass\nfrom typing import List\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\nfrom torch.utils.data import Dataset\nfrom torch.utils.data.dataloader import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\n# -----------------------------------------------------------------------------\n\n@dataclass\nclass ModelConfig:\n    block_size: int = None # length of the input sequences of integers\n    vocab_size: int = None # the input integers are in range [0 .. vocab_size -1]\n    # parameters below control the sizes of each model slightly differently\n    n_layer: int = 4\n    n_embd: int = 64\n    n_embd2: int = 64\n    n_head: int = 4\n\n# -----------------------------------------------------------------------------\n# Transformer Language Model (*exactly* as used in GPT-2)\n\nclass NewGELU(nn.Module):\n    \"\"\"\n    Implementation of the GELU activation function currently in Google BERT repo (identical to OpenAI GPT).\n    Reference: Gaussian Error Linear Units (GELU) paper: https://arxiv.org/abs/1606.08415\n    \"\"\"\n    def forward(self, x):\n        return 0.5 * x * (1.0 + torch.tanh(math.sqrt(2.0 / math.pi) * (x + 0.044715 * torch.pow(x, 3.0))))\n\nclass CausalSelfAttention(nn.Module):\n    \"\"\"\n    A vanilla multi-head masked self-attention layer with a projection at the end.\n    It is possible to use torch.nn.MultiheadAttention here but I am including an\n    explicit implementation here to show that there is nothing too scary here.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.n_embd % config.n_head == 0\n        # key, query, value projections for all heads, but in a batch\n        self.c_attn = nn.Linear(config.n_embd, 3 * config.n_embd)\n        # output projection\n        self.c_proj = nn.Linear(config.n_embd, config.n_embd)\n        # causal mask to ensure that attention is only applied to the left in the input sequence\n        self.register_buffer(\"bias\", torch.tril(torch.ones(config.block_size, config.block_size))\n                                     .view(1, 1, config.block_size, config.block_size))\n        self.n_head = config.n_head\n        self.n_embd = config.n_embd\n\n    def forward(self, x):\n        B, T, C = x.size() # batch size, sequence length, embedding dimensionality (n_embd)\n\n        # calculate query, key, values for all heads in batch and move head forward to be the batch dim\n        q, k ,v  = self.c_attn(x).split(self.n_embd, dim=2)\n        k = k.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        q = q.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        v = v.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n\n        # causal self-attention; Self-attend: (B, nh, T, hs) x (B, nh, hs, T) -> (B, nh, T, T)\n        att = (q @ k.transpose(-2, -1)) * (1.0 / math.sqrt(k.size(-1)))\n        att = att.masked_fill(self.bias[:,:,:T,:T] == 0, float('-inf'))\n        att = F.softmax(att, dim=-1)\n        y = att @ v # (B, nh, T, T) x (B, nh, T, hs) -> (B, nh, T, hs)\n        y = y.transpose(1, 2).contiguous().view(B, T, C) # re-assemble all head outputs side by side\n\n        # output projection\n        y = self.c_proj(y)\n        return y\n\nclass Block(nn.Module):\n    \"\"\" an unassuming Transformer block \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.ln_1 = nn.LayerNorm(config.n_embd)\n        self.attn = CausalSelfAttention(config)\n        self.ln_2 = nn.LayerNorm(config.n_embd)\n        self.mlp = nn.ModuleDict(dict(\n            c_fc    = nn.Linear(config.n_embd, 4 * config.n_embd),\n            c_proj  = nn.Linear(4 * config.n_embd, config.n_embd),\n            act     = NewGELU(),\n        ))\n        m = self.mlp\n        self.mlpf = lambda x: m.c_proj(m.act(m.c_fc(x))) # MLP forward\n\n    def forward(self, x):\n        x = x + self.attn(self.ln_1(x))\n        x = x + self.mlpf(self.ln_2(x))\n        return x\n\nclass Transformer(nn.Module):\n    \"\"\" Transformer Language Model, exactly as seen in GPT-2 \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.block_size = config.block_size\n\n        self.transformer = nn.ModuleDict(dict(\n            wte = nn.Embedding(config.vocab_size, config.n_embd),\n            wpe = nn.Embedding(config.block_size, config.n_embd),\n            h = nn.ModuleList([Block(config) for _ in range(config.n_layer)]),\n            ln_f = nn.LayerNorm(config.n_embd),\n        ))\n        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n\n        # report number of parameters (note we don't count the decoder parameters in lm_head)\n        n_params = sum(p.numel() for p in self.transformer.parameters())\n        print(\"number of parameters: %.2fM\" % (n_params/1e6,))\n\n    def get_block_size(self):\n        return self.block_size\n\n    def forward(self, idx, targets=None):\n        device = idx.device\n        b, t = idx.size()\n        assert t <= self.block_size, f\"Cannot forward sequence of length {t}, block size is only {self.block_size}\"\n        pos = torch.arange(0, t, dtype=torch.long, device=device).unsqueeze(0) # shape (1, t)\n\n        # forward the GPT model itself\n        tok_emb = self.transformer.wte(idx) # token embeddings of shape (b, t, n_embd)\n        pos_emb = self.transformer.wpe(pos) # position embeddings of shape (1, t, n_embd)\n        x = tok_emb + pos_emb\n        for block in self.transformer.h:\n            x = block(x)\n        x = self.transformer.ln_f(x)\n        logits = self.lm_head(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n# Bag of Words (BoW) language model\n\nclass CausalBoW(nn.Module):\n    \"\"\"\n    Causal bag of words. Averages the preceding elements and looks suspiciously like\n    a CausalAttention module you'd find in a transformer, for no apparent reason at all ;)\n    \"\"\"\n    def __init__(self, config):\n        super().__init__()\n\n        # used to mask out vectors and preserve autoregressive property\n        self.block_size = config.block_size\n        self.register_buffer(\"bias\", torch.tril(torch.ones(config.block_size, config.block_size))\n                            .view(1, config.block_size, config.block_size))\n\n    def forward(self, x):\n        B, T, C = x.size() # batch size, sequence length, n_embd\n\n        # do the weighted average of all preceeding token features\n        att = torch.zeros((B, T, T), device=x.device)\n        att = att.masked_fill(self.bias[:,:T,:T] == 0, float('-inf'))\n        att = F.softmax(att, dim=-1)\n        y = att @ x # (B, T, T) x (B, T, C) -> (B, T, C)\n\n        return y\n\nclass BoWBlock(nn.Module):\n    \"\"\" collects BoW features and adds an MLP \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n\n        # Causal BoW module\n        self.cbow = CausalBoW(config)\n        # MLP assembler\n        self.mlp = nn.ModuleDict(dict(\n            c_fc    = nn.Linear(config.n_embd, config.n_embd2),\n            c_proj  = nn.Linear(config.n_embd2, config.n_embd),\n        ))\n        m = self.mlp\n        self.mlpf = lambda x: m.c_proj(F.tanh(m.c_fc(x))) # MLP forward\n\n    def forward(self, x):\n        x = x + self.cbow(x)\n        x = x + self.mlpf(x)\n        return x\n\nclass BoW(nn.Module):\n    \"\"\"\n    takes the previous block_size tokens, encodes them with a lookup table,\n    also encodes their positions with lookup table, then averages all of those\n    embeddings up and uses that to predict the next token.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.block_size = config.block_size\n        self.vocab_size = config.vocab_size\n        # token embedding\n        self.wte = nn.Embedding(config.vocab_size, config.n_embd)\n        # position embedding\n        self.wpe = nn.Embedding(config.block_size, config.n_embd)\n        # context block\n        self.context_block = BoWBlock(config)\n        # language model head decoder layer\n        self.lm_head = nn.Linear(config.n_embd, self.vocab_size)\n\n    def get_block_size(self):\n        return self.block_size\n\n    def forward(self, idx, targets=None):\n\n        device = idx.device\n        b, t = idx.size()\n        assert t <= self.block_size, f\"Cannot forward sequence of length {t}, block size is only {self.block_size}\"\n        pos = torch.arange(0, t, dtype=torch.long, device=device).unsqueeze(0) # shape (1, t)\n\n        # forward the token and position embedding layers\n        tok_emb = self.wte(idx) # token embeddings of shape (b, t, n_embd)\n        pos_emb = self.wpe(pos) # position embeddings of shape (1, t, n_embd)\n        # add and run through the decoder MLP\n        x = tok_emb + pos_emb\n        # run the bag of words context module\n        x = self.context_block(x)\n        # decode to next token probability\n        logits = self.lm_head(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n\"\"\"\nRecurrent Neural Net language model: either a vanilla RNN recurrence or a GRU.\nDid not implement an LSTM because its API is a bit more annoying as it has\nboth a hidden state and a cell state, but it's very similar to GRU and in\npractice works just as well.\n\"\"\"\n\nclass RNNCell(nn.Module):\n    \"\"\"\n    the job of a 'Cell' is to:\n    take input at current time step x_{t} and the hidden state at the\n    previous time step h_{t-1} and return the resulting hidden state\n    h_{t} at the current timestep\n    \"\"\"\n    def __init__(self, config):\n        super().__init__()\n        self.xh_to_h = nn.Linear(config.n_embd + config.n_embd2, config.n_embd2)\n\n    def forward(self, xt, hprev):\n        xh = torch.cat([xt, hprev], dim=1)\n        ht = F.tanh(self.xh_to_h(xh))\n        return ht\n\nclass GRUCell(nn.Module):\n    \"\"\"\n    same job as RNN cell, but a bit more complicated recurrence formula\n    that makes the GRU more expressive and easier to optimize.\n    \"\"\"\n    def __init__(self, config):\n        super().__init__()\n        # input, forget, output, gate\n        self.xh_to_z = nn.Linear(config.n_embd + config.n_embd2, config.n_embd2)\n        self.xh_to_r = nn.Linear(config.n_embd + config.n_embd2, config.n_embd2)\n        self.xh_to_hbar = nn.Linear(config.n_embd + config.n_embd2, config.n_embd2)\n\n    def forward(self, xt, hprev):\n        # first use the reset gate to wipe some channels of the hidden state to zero\n        xh = torch.cat([xt, hprev], dim=1)\n        r = F.sigmoid(self.xh_to_r(xh))\n        hprev_reset = r * hprev\n        # calculate the candidate new hidden state hbar\n        xhr = torch.cat([xt, hprev_reset], dim=1)\n        hbar = F.tanh(self.xh_to_hbar(xhr))\n        # calculate the switch gate that determines if each channel should be updated at all\n        z = F.sigmoid(self.xh_to_z(xh))\n        # blend the previous hidden state and the new candidate hidden state\n        ht = (1 - z) * hprev + z * hbar\n        return ht\n\nclass RNN(nn.Module):\n\n    def __init__(self, config, cell_type):\n        super().__init__()\n        self.block_size = config.block_size\n        self.vocab_size = config.vocab_size\n        self.start = nn.Parameter(torch.zeros(1, config.n_embd2)) # the starting hidden state\n        self.wte = nn.Embedding(config.vocab_size, config.n_embd) # token embeddings table\n        if cell_type == 'rnn':\n            self.cell = RNNCell(config)\n        elif cell_type == 'gru':\n            self.cell = GRUCell(config)\n        self.lm_head = nn.Linear(config.n_embd2, self.vocab_size)\n\n    def get_block_size(self):\n        return self.block_size\n\n    def forward(self, idx, targets=None):\n        device = idx.device\n        b, t = idx.size()\n\n        # embed all the integers up front and all at once for efficiency\n        emb = self.wte(idx) # (b, t, n_embd)\n\n        # sequentially iterate over the inputs and update the RNN state each tick\n        hprev = self.start.expand((b, -1)) # expand out the batch dimension\n        hiddens = []\n        for i in range(t):\n            xt = emb[:, i, :] # (b, n_embd)\n            ht = self.cell(xt, hprev) # (b, n_embd2)\n            hprev = ht\n            hiddens.append(ht)\n\n        # decode the outputs\n        hidden = torch.stack(hiddens, 1) # (b, t, n_embd2)\n        logits = self.lm_head(hidden)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n# MLP language model\n\nclass MLP(nn.Module):\n    \"\"\"\n    takes the previous block_size tokens, encodes them with a lookup table,\n    concatenates the vectors and predicts the next token with an MLP.\n\n    Reference:\n    Bengio et al. 2003 https://www.jmlr.org/papers/volume3/bengio03a/bengio03a.pdf\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.block_size = config.block_size\n        self.vocab_size = config.vocab_size\n        self.wte = nn.Embedding(config.vocab_size + 1, config.n_embd) # token embeddings table\n        # +1 in the line above for a special <BLANK> token that gets inserted if encoding a token\n        # before the beginning of the input sequence\n        self.mlp = nn.Sequential(\n            nn.Linear(self.block_size * config.n_embd, config.n_embd2),\n            nn.Tanh(),\n            nn.Linear(config.n_embd2, self.vocab_size)\n        )\n\n    def get_block_size(self):\n        return self.block_size\n\n    def forward(self, idx, targets=None):\n\n        # gather the word embeddings of the previous 3 words\n        embs = []\n        for k in range(self.block_size):\n            tok_emb = self.wte(idx) # token embeddings of shape (b, t, n_embd)\n            idx = torch.roll(idx, 1, 1)\n            idx[:, 0] = self.vocab_size # special <BLANK> token\n            embs.append(tok_emb)\n\n        # concat all of the embeddings together and pass through an MLP\n        x = torch.cat(embs, -1) # (b, t, n_embd * block_size)\n        logits = self.mlp(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n# Bigram language model\n\nclass Bigram(nn.Module):\n    \"\"\"\n    Bigram Language Model 'neural net', simply a lookup table of logits for the\n    next character given a previous character.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        n = config.vocab_size\n        self.logits = nn.Parameter(torch.zeros((n, n)))\n\n    def get_block_size(self):\n        return 1 # this model only needs one previous character to predict the next\n\n    def forward(self, idx, targets=None):\n\n         # 'forward pass', lol\n        logits = self.logits[idx]\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n# helper functions for evaluating and sampling from the model\n\n@torch.no_grad()\ndef generate(model, idx, max_new_tokens, temperature=1.0, do_sample=False, top_k=None):\n    \"\"\"\n    Take a conditioning sequence of indices idx (LongTensor of shape (b,t)) and complete\n    the sequence max_new_tokens times, feeding the predictions back into the model each time.\n    Most likely you'll want to make sure to be in model.eval() mode of operation for this.\n    \"\"\"\n    block_size = model.get_block_size()\n    for _ in range(max_new_tokens):\n        # if the sequence context is growing too long we must crop it at block_size\n        idx_cond = idx if idx.size(1) <= block_size else idx[:, -block_size:]\n        # forward the model to get the logits for the index in the sequence\n        logits, _ = model(idx_cond)\n        # pluck the logits at the final step and scale by desired temperature\n        logits = logits[:, -1, :] / temperature\n        # optionally crop the logits to only the top k options\n        if top_k is not None:\n            v, _ = torch.topk(logits, top_k)\n            logits[logits < v[:, [-1]]] = -float('Inf')\n        # apply softmax to convert logits to (normalized) probabilities\n        probs = F.softmax(logits, dim=-1)\n        # either sample from the distribution or take the most likely element\n        if do_sample:\n            idx_next = torch.multinomial(probs, num_samples=1)\n        else:\n            _, idx_next = torch.topk(probs, k=1, dim=-1)\n        # append sampled index to the running sequence and continue\n        idx = torch.cat((idx, idx_next), dim=1)\n\n    return idx\n\ndef print_samples(num=10):\n    \"\"\" samples from the model and pretty prints the decoded samples \"\"\"\n    X_init = torch.zeros(num, 1, dtype=torch.long).to(args.device)\n    top_k = args.top_k if args.top_k != -1 else None\n    steps = train_dataset.get_output_length() - 1 # -1 because we already start with <START> token (index 0)\n    X_samp = generate(model, X_init, steps, top_k=top_k, do_sample=True).to('cpu')\n    train_samples, test_samples, new_samples = [], [], []\n    for i in range(X_samp.size(0)):\n        # get the i'th row of sampled integers, as python list\n        row = X_samp[i, 1:].tolist() # note: we need to crop out the first <START> token\n        # token 0 is the <STOP> token, so we crop the output sequence at that point\n        crop_index = row.index(0) if 0 in row else len(row)\n        row = row[:crop_index]\n        word_samp = train_dataset.decode(row)\n        # separately track samples that we have and have not seen before\n        if train_dataset.contains(word_samp):\n            train_samples.append(word_samp)\n        elif test_dataset.contains(word_samp):\n            test_samples.append(word_samp)\n        else:\n            new_samples.append(word_samp)\n    print('-'*80)\n    for lst, desc in [(train_samples, 'in train'), (test_samples, 'in test'), (new_samples, 'new')]:\n        print(f\"{len(lst)} samples that are {desc}:\")\n        for word in lst:\n            print(word)\n    print('-'*80)\n\n@torch.inference_mode()\ndef evaluate(model, dataset, batch_size=50, max_batches=None):\n    model.eval()\n    loader = DataLoader(dataset, shuffle=True, batch_size=batch_size, num_workers=0)\n    losses = []\n    for i, batch in enumerate(loader):\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n        logits, loss = model(X, Y)\n        losses.append(loss.item())\n        if max_batches is not None and i >= max_batches:\n            break\n    mean_loss = torch.tensor(losses).mean().item()\n    model.train() # reset model back to training mode\n    return mean_loss\n\n# -----------------------------------------------------------------------------\n# helper functions for creating the training and test Datasets that emit words\n\nclass CharDataset(Dataset):\n\n    def __init__(self, words, chars, max_word_length):\n        self.words = words\n        self.chars = chars\n        self.max_word_length = max_word_length\n        self.stoi = {ch:i+1 for i,ch in enumerate(chars)}\n        self.itos = {i:s for s,i in self.stoi.items()} # inverse mapping\n\n    def __len__(self):\n        return len(self.words)\n\n    def contains(self, word):\n        return word in self.words\n\n    def get_vocab_size(self):\n        return len(self.chars) + 1 # all the possible characters and special 0 token\n\n    def get_output_length(self):\n        return self.max_word_length + 1 # <START> token followed by words\n\n    def encode(self, word):\n        ix = torch.tensor([self.stoi[w] for w in word], dtype=torch.long)\n        return ix\n\n    def decode(self, ix):\n        word = ''.join(self.itos[i] for i in ix)\n        return word\n\n    def __getitem__(self, idx):\n        word = self.words[idx]\n        ix = self.encode(word)\n        x = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        y = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        x[1:1+len(ix)] = ix\n        y[:len(ix)] = ix\n        y[len(ix)+1:] = -1 # index -1 will mask the loss at the inactive locations\n        return x, y\n\ndef create_datasets(input_file):\n\n    # preprocessing of the input text file\n    with open(input_file, 'r') as f:\n        data = f.read()\n    words = data.splitlines()\n    words = [w.strip() for w in words] # get rid of any leading or trailing white space\n    words = [w for w in words if w] # get rid of any empty strings\n    chars = sorted(list(set(''.join(words)))) # all the possible characters\n    max_word_length = max(len(w) for w in words)\n    print(f\"number of examples in the dataset: {len(words)}\")\n    print(f\"max word length: {max_word_length}\")\n    print(f\"number of unique characters in the vocabulary: {len(chars)}\")\n    print(\"vocabulary:\")\n    print(''.join(chars))\n\n    # partition the input data into a training and the test set\n    test_set_size = min(1000, int(len(words) * 0.1)) # 10% of the training set, or up to 1000 examples\n    rp = torch.randperm(len(words)).tolist()\n    train_words = [words[i] for i in rp[:-test_set_size]]\n    test_words = [words[i] for i in rp[-test_set_size:]]\n    print(f\"split up the dataset into {len(train_words)} training examples and {len(test_words)} test examples\")\n\n    # wrap in dataset objects\n    train_dataset = CharDataset(train_words, chars, max_word_length)\n    test_dataset = CharDataset(test_words, chars, max_word_length)\n\n    return train_dataset, test_dataset\n\nclass InfiniteDataLoader:\n    \"\"\"\n    this is really hacky and I'm not proud of it, but there doesn't seem to be\n    a better way in PyTorch to just create an infinite dataloader?\n    \"\"\"\n\n    def __init__(self, dataset, **kwargs):\n        train_sampler = torch.utils.data.RandomSampler(dataset, replacement=True, num_samples=int(1e10))\n        self.train_loader = DataLoader(dataset, sampler=train_sampler, **kwargs)\n        self.data_iter = iter(self.train_loader)\n\n    def next(self):\n        try:\n            batch = next(self.data_iter)\n        except StopIteration: # this will technically only happen after 1e10 samples... (i.e. basically never)\n            self.data_iter = iter(self.train_loader)\n            batch = next(self.data_iter)\n        return batch\n\n# -----------------------------------------------------------------------------\nif __name__ == '__main__':\n\n    # parse command line args\n    parser = argparse.ArgumentParser(description=\"Make More\")\n    # system/input/output\n    parser.add_argument('--input-file', '-i', type=str, default='names.txt', help=\"input file with things one per line\")\n    parser.add_argument('--work-dir', '-o', type=str, default='out', help=\"output working directory\")\n    parser.add_argument('--resume', action='store_true', help=\"when this flag is used, we will resume optimization from existing model in the workdir\")\n    parser.add_argument('--sample-only', action='store_true', help=\"just sample from the model and quit, don't train\")\n    parser.add_argument('--num-workers', '-n', type=int, default=4, help=\"number of data workers for both train/test\")\n    parser.add_argument('--max-steps', type=int, default=-1, help=\"max number of optimization steps to run for, or -1 for infinite.\")\n    parser.add_argument('--device', type=str, default='cpu', help=\"device to use for compute, examples: cpu|cuda|cuda:2|mps\")\n    parser.add_argument('--seed', type=int, default=3407, help=\"seed\")\n    # sampling\n    parser.add_argument('--top-k', type=int, default=-1, help=\"top-k for sampling, -1 means no top-k\")\n    # model\n    parser.add_argument('--type', type=str, default='transformer', help=\"model class type to use, bigram|mlp|rnn|gru|bow|transformer\")\n    parser.add_argument('--n-layer', type=int, default=4, help=\"number of layers\")\n    parser.add_argument('--n-head', type=int, default=4, help=\"number of heads (in a transformer)\")\n    parser.add_argument('--n-embd', type=int, default=64, help=\"number of feature channels in the model\")\n    parser.add_argument('--n-embd2', type=int, default=64, help=\"number of feature channels elsewhere in the model\")\n    # optimization\n    parser.add_argument('--batch-size', '-b', type=int, default=32, help=\"batch size during optimization\")\n    parser.add_argument('--learning-rate', '-l', type=float, default=5e-4, help=\"learning rate\")\n    parser.add_argument('--weight-decay', '-w', type=float, default=0.01, help=\"weight decay\")\n    args = parser.parse_args()\n    print(vars(args))\n\n    # system inits\n    torch.manual_seed(args.seed)\n    torch.cuda.manual_seed_all(args.seed)\n    os.makedirs(args.work_dir, exist_ok=True)\n    writer = SummaryWriter(log_dir=args.work_dir)\n\n    # init datasets\n    train_dataset, test_dataset = create_datasets(args.input_file)\n    vocab_size = train_dataset.get_vocab_size()\n    block_size = train_dataset.get_output_length()\n    print(f\"dataset determined that: {vocab_size=}, {block_size=}\")\n\n    # init model\n    config = ModelConfig(vocab_size=vocab_size, block_size=block_size,\n                       n_layer=args.n_layer, n_head=args.n_head,\n                       n_embd=args.n_embd, n_embd2=args.n_embd2)\n    if args.type == 'transformer':\n        model = Transformer(config)\n    elif args.type == 'bigram':\n        model = Bigram(config)\n    elif args.type == 'mlp':\n        model = MLP(config)\n    elif args.type == 'rnn':\n        model = RNN(config, cell_type='rnn')\n    elif args.type == 'gru':\n        model = RNN(config, cell_type='gru')\n    elif args.type == 'bow':\n        model = BoW(config)\n    else:\n        raise ValueError(f'model type {args.type} is not recognized')\n    model.to(args.device)\n    print(f\"model #params: {sum(p.numel() for p in model.parameters())}\")\n    if args.resume or args.sample_only: # note: if we sample-only then we also assume we are resuming\n        print(\"resuming from existing model in the workdir\")\n        model.load_state_dict(torch.load(os.path.join(args.work_dir, 'model.pt')))\n    if args.sample_only:\n        print_samples(num=50)\n        sys.exit()\n\n    # init optimizer\n    optimizer = torch.optim.AdamW(model.parameters(), lr=args.learning_rate, weight_decay=args.weight_decay, betas=(0.9, 0.99), eps=1e-8)\n\n    # init dataloader\n    batch_loader = InfiniteDataLoader(train_dataset, batch_size=args.batch_size, pin_memory=True, num_workers=args.num_workers)\n\n    # training loop\n    best_loss = None\n    step = 0\n    while True:\n\n        t0 = time.time()\n\n        # get the next batch, ship to device, and unpack it to input and target\n        batch = batch_loader.next()\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n\n        # feed into the model\n        logits, loss = model(X, Y)\n\n        # calculate the gradient, update the weights\n        model.zero_grad(set_to_none=True)\n        loss.backward()\n        optimizer.step()\n\n        # wait for all CUDA work on the GPU to finish then calculate iteration time taken\n        if args.device.startswith('cuda'):\n            torch.cuda.synchronize()\n        t1 = time.time()\n\n        # logging\n        if step % 10 == 0:\n            print(f\"step {step} | loss {loss.item():.4f} | step time {(t1-t0)*1000:.2f}ms\")\n\n        # evaluate the model\n        if step > 0 and step % 500 == 0:\n            train_loss = evaluate(model, train_dataset, batch_size=100, max_batches=10)\n            test_loss  = evaluate(model, test_dataset,  batch_size=100, max_batches=10)\n            writer.add_scalar(\"Loss/train\", train_loss, step)\n            writer.add_scalar(\"Loss/test\", test_loss, step)\n            writer.flush()\n            print(f\"step {step} train loss: {train_loss} test loss: {test_loss}\")\n            # save the model to disk if it has improved\n            if best_loss is None or test_loss < best_loss:\n                out_path = os.path.join(args.work_dir, \"model.pt\")\n                print(f\"test loss {test_loss} is the best so far, saving model to {out_path}\")\n                torch.save(model.state_dict(), out_path)\n                best_loss = test_loss\n\n        # sample from the model\n        if step > 0 and step % 200 == 0:\n            print_samples(num=10)\n\n        step += 1\n        # termination conditions\n        if args.max_steps >= 0 and step >= args.max_steps:\n            break\n\n", "diff": "@@ -330,6 +330,7 @@ def forward(self, idx, targets=None):\n         for i in range(t):\n             xt = emb[:, i, :] # (b, n_embd)\n             ht = self.cell(xt, hprev) # (b, n_embd2)\n+            hprev = ht\n             hiddens.append(ht)\n \n         # decode the outputs", "status": "modified"}, {"commit_id": "c079e1ce764adf417c9c905dbefbcb8419b5b278", "commit_message": "add a bag of words model that looks suspiciously similar to a transformer ;)", "relative_path": "makemore.py", "previous_code_file": "\"\"\"\nyou give this script some words (one per line) and it will generate more things like it.\nuses super state of the art Transformer AI tech\nthis code is intended to be super hackable. tune it to your needs.\n\nChanges from minGPT:\n- I removed the from_pretrained function where we init with GPT2 weights\n- I removed dropout layers because the models we train here are small,\n  it's not necessary to understand at this stage and at this scale.\n- I removed weight decay and all of the complexity around what parameters are\n  and are not weight decayed. I don't believe this should make a massive\n  difference at the scale that we operate on here.\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport math\nimport argparse\nfrom dataclasses import dataclass\nfrom typing import List\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\nfrom torch.utils.data import Dataset\nfrom torch.utils.data.dataloader import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\n# -----------------------------------------------------------------------------\n\n@dataclass\nclass ModelConfig:\n    block_size: int = None # length of the input sequences of integers\n    vocab_size: int = None # the input integers are in range [0 .. vocab_size -1]\n    # parameters below control the sizes of each model slightly differently\n    n_layer: int = 4\n    n_embd: int = 64\n    n_embd2: int = 64\n    n_head: int = 4\n\n# -----------------------------------------------------------------------------\n# Transformer Language Model (*exactly* as used in GPT-2)\n\nclass NewGELU(nn.Module):\n    \"\"\"\n    Implementation of the GELU activation function currently in Google BERT repo (identical to OpenAI GPT).\n    Reference: Gaussian Error Linear Units (GELU) paper: https://arxiv.org/abs/1606.08415\n    \"\"\"\n    def forward(self, x):\n        return 0.5 * x * (1.0 + torch.tanh(math.sqrt(2.0 / math.pi) * (x + 0.044715 * torch.pow(x, 3.0))))\n\nclass CausalSelfAttention(nn.Module):\n    \"\"\"\n    A vanilla multi-head masked self-attention layer with a projection at the end.\n    It is possible to use torch.nn.MultiheadAttention here but I am including an\n    explicit implementation here to show that there is nothing too scary here.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.n_embd % config.n_head == 0\n        # key, query, value projections for all heads, but in a batch\n        self.c_attn = nn.Linear(config.n_embd, 3 * config.n_embd)\n        # output projection\n        self.c_proj = nn.Linear(config.n_embd, config.n_embd)\n        # causal mask to ensure that attention is only applied to the left in the input sequence\n        self.register_buffer(\"bias\", torch.tril(torch.ones(config.block_size, config.block_size))\n                                     .view(1, 1, config.block_size, config.block_size))\n        self.n_head = config.n_head\n        self.n_embd = config.n_embd\n\n    def forward(self, x):\n        B, T, C = x.size() # batch size, sequence length, embedding dimensionality (n_embd)\n\n        # calculate query, key, values for all heads in batch and move head forward to be the batch dim\n        q, k ,v  = self.c_attn(x).split(self.n_embd, dim=2)\n        k = k.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        q = q.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        v = v.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n\n        # causal self-attention; Self-attend: (B, nh, T, hs) x (B, nh, hs, T) -> (B, nh, T, T)\n        att = (q @ k.transpose(-2, -1)) * (1.0 / math.sqrt(k.size(-1)))\n        att = att.masked_fill(self.bias[:,:,:T,:T] == 0, float('-inf'))\n        att = F.softmax(att, dim=-1)\n        y = att @ v # (B, nh, T, T) x (B, nh, T, hs) -> (B, nh, T, hs)\n        y = y.transpose(1, 2).contiguous().view(B, T, C) # re-assemble all head outputs side by side\n\n        # output projection\n        y = self.c_proj(y)\n        return y\n\nclass Block(nn.Module):\n    \"\"\" an unassuming Transformer block \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.ln_1 = nn.LayerNorm(config.n_embd)\n        self.attn = CausalSelfAttention(config)\n        self.ln_2 = nn.LayerNorm(config.n_embd)\n        self.mlp = nn.ModuleDict(dict(\n            c_fc    = nn.Linear(config.n_embd, 4 * config.n_embd),\n            c_proj  = nn.Linear(4 * config.n_embd, config.n_embd),\n            act     = NewGELU(),\n        ))\n        m = self.mlp\n        self.mlpf = lambda x: m.c_proj(m.act(m.c_fc(x))) # MLP forward\n\n    def forward(self, x):\n        x = x + self.attn(self.ln_1(x))\n        x = x + self.mlpf(self.ln_2(x))\n        return x\n\nclass Transformer(nn.Module):\n    \"\"\" Transformer Language Model, exactly as seen in GPT-2 \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.block_size = config.block_size\n\n        self.transformer = nn.ModuleDict(dict(\n            wte = nn.Embedding(config.vocab_size, config.n_embd),\n            wpe = nn.Embedding(config.block_size, config.n_embd),\n            h = nn.ModuleList([Block(config) for _ in range(config.n_layer)]),\n            ln_f = nn.LayerNorm(config.n_embd),\n        ))\n        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n\n        # report number of parameters (note we don't count the decoder parameters in lm_head)\n        n_params = sum(p.numel() for p in self.transformer.parameters())\n        print(\"number of parameters: %.2fM\" % (n_params/1e6,))\n\n    def get_block_size(self):\n        return self.block_size\n\n    def forward(self, idx, targets=None):\n        device = idx.device\n        b, t = idx.size()\n        assert t <= self.block_size, f\"Cannot forward sequence of length {t}, block size is only {self.block_size}\"\n        pos = torch.arange(0, t, dtype=torch.long, device=device).unsqueeze(0) # shape (1, t)\n\n        # forward the GPT model itself\n        tok_emb = self.transformer.wte(idx) # token embeddings of shape (b, t, n_embd)\n        pos_emb = self.transformer.wpe(pos) # position embeddings of shape (1, t, n_embd)\n        x = tok_emb + pos_emb\n        for block in self.transformer.h:\n            x = block(x)\n        x = self.transformer.ln_f(x)\n        logits = self.lm_head(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n\"\"\"\nRecurrent Neural Net language model: either a vanilla RNN recurrence or a GRU.\nDid not implement an LSTM because its API is a bit more annoying as it has\nboth a hidden state and a cell state, but it's very similar to GRU and in\npractice works just as well.\n\"\"\"\n\nclass RNNCell(nn.Module):\n    \"\"\"\n    the job of a 'Cell' is to:\n    take input at current time step x_{t} and the hidden state at the\n    previous time step h_{t-1} and return the resulting hidden state\n    h_{t} at the current timestep\n    \"\"\"\n    def __init__(self, config):\n        super().__init__()\n        self.xh_to_h = nn.Linear(config.n_embd + config.n_embd2, config.n_embd2)\n\n    def forward(self, xt, hprev):\n        xh = torch.cat([xt, hprev], dim=1)\n        ht = F.tanh(self.xh_to_h(xh))\n        return ht\n\nclass GRUCell(nn.Module):\n    \"\"\"\n    same job as RNN cell, but a bit more complicated recurrence formula\n    that makes the GRU more expressive and easier to optimize.\n    \"\"\"\n    def __init__(self, config):\n        super().__init__()\n        # input, forget, output, gate\n        self.xh_to_z = nn.Linear(config.n_embd + config.n_embd2, config.n_embd2)\n        self.xh_to_r = nn.Linear(config.n_embd + config.n_embd2, config.n_embd2)\n        self.xh_to_hbar = nn.Linear(config.n_embd + config.n_embd2, config.n_embd2)\n\n    def forward(self, xt, hprev):\n        # first use the reset gate to wipe some channels of the hidden state to zero\n        xh = torch.cat([xt, hprev], dim=1)\n        r = F.sigmoid(self.xh_to_r(xh))\n        hprev_reset = r * hprev\n        # calculate the candidate new hidden state hbar\n        xhr = torch.cat([xt, hprev_reset], dim=1)\n        hbar = F.tanh(self.xh_to_hbar(xhr))\n        # calculate the switch gate that determines if each channel should be updated at all\n        z = F.sigmoid(self.xh_to_z(xh))\n        # blend the previous hidden state and the new candidate hidden state\n        ht = (1 - z) * hprev + z * hbar\n        return ht\n\nclass RNN(nn.Module):\n\n    def __init__(self, config, cell_type):\n        super().__init__()\n        self.block_size = config.block_size\n        self.vocab_size = config.vocab_size\n        self.start = nn.Parameter(torch.zeros(1, config.n_embd2)) # the starting hidden state\n        self.wte = nn.Embedding(config.vocab_size, config.n_embd) # token embeddings table\n        if cell_type == 'rnn':\n            self.cell = RNNCell(config)\n        elif cell_type == 'gru':\n            self.cell = GRUCell(config)\n        self.lm_head = nn.Linear(config.n_embd2, self.vocab_size)\n\n    def get_block_size(self):\n        return self.block_size\n\n    def forward(self, idx, targets=None):\n        device = idx.device\n        b, t = idx.size()\n\n        # embed all the integers up front and all at once for efficiency\n        emb = self.wte(idx) # (b, t, n_embd)\n\n        # sequentially iterate over the inputs and update the RNN state each tick\n        hprev = self.start.expand((b, -1)) # expand out the batch dimension\n        hiddens = []\n        for i in range(t):\n            xt = emb[:, i, :] # (b, n_embd)\n            ht = self.cell(xt, hprev) # (b, n_embd2)\n            hiddens.append(ht)\n\n        # decode the outputs\n        hidden = torch.stack(hiddens, 1) # (b, t, n_embd2)\n        logits = self.lm_head(hidden)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n# MLP language model\n\nclass MLP(nn.Module):\n    \"\"\"\n    takes the previous block_size tokens, encodes them with a lookup table,\n    concatenates the vectors and predicts the next token with an MLP.\n\n    Reference:\n    Bengio et al. 2003 https://www.jmlr.org/papers/volume3/bengio03a/bengio03a.pdf\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.block_size = config.block_size\n        self.vocab_size = config.vocab_size\n        self.wte = nn.Embedding(config.vocab_size + 1, config.n_embd) # token embeddings table\n        # +1 in the line above for a special <BLANK> token that gets inserted if encoding a token\n        # before the beginning of the input sequence\n        self.mlp = nn.Sequential(\n            nn.Linear(self.block_size * config.n_embd, config.n_embd2), # TODO: option to vary this\n            nn.Tanh(),\n            nn.Linear(config.n_embd2, self.vocab_size)\n        )\n\n    def get_block_size(self):\n        return self.block_size\n\n    def forward(self, idx, targets=None):\n\n        # gather the word embeddings of the previous 3 words\n        embs = []\n        for k in range(self.block_size):\n            tok_emb = self.wte(idx) # token embeddings of shape (b, t, n_embd)\n            idx = torch.roll(idx, 1, 1)\n            idx[:, 0] = self.vocab_size # special <BLANK> token\n            embs.append(tok_emb)\n\n        # concat all of the embeddings together and pass through an MLP\n        x = torch.cat(embs, -1) # (b, t, n_embd * block_size)\n        logits = self.mlp(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n# Bigram language model\n\nclass Bigram(nn.Module):\n    \"\"\"\n    Bigram Language Model 'neural net', simply a lookup table of logits for the\n    next character given a previous character.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        n = config.vocab_size\n        self.logits = nn.Parameter(torch.zeros((n, n)))\n\n    def get_block_size(self):\n        return 1 # this model only needs one previous character to predict the next\n\n    def forward(self, idx, targets=None):\n\n         # 'forward pass', lol\n        logits = self.logits[idx]\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n# helper functions for evaluating and sampling from the model\n\n@torch.no_grad()\ndef generate(model, idx, max_new_tokens, temperature=1.0, do_sample=False, top_k=None):\n    \"\"\"\n    Take a conditioning sequence of indices idx (LongTensor of shape (b,t)) and complete\n    the sequence max_new_tokens times, feeding the predictions back into the model each time.\n    Most likely you'll want to make sure to be in model.eval() mode of operation for this.\n    \"\"\"\n    block_size = model.get_block_size()\n    for _ in range(max_new_tokens):\n        # if the sequence context is growing too long we must crop it at block_size\n        idx_cond = idx if idx.size(1) <= block_size else idx[:, -block_size:]\n        # forward the model to get the logits for the index in the sequence\n        logits, _ = model(idx_cond)\n        # pluck the logits at the final step and scale by desired temperature\n        logits = logits[:, -1, :] / temperature\n        # optionally crop the logits to only the top k options\n        if top_k is not None:\n            v, _ = torch.topk(logits, top_k)\n            logits[logits < v[:, [-1]]] = -float('Inf')\n        # apply softmax to convert logits to (normalized) probabilities\n        probs = F.softmax(logits, dim=-1)\n        # either sample from the distribution or take the most likely element\n        if do_sample:\n            idx_next = torch.multinomial(probs, num_samples=1)\n        else:\n            _, idx_next = torch.topk(probs, k=1, dim=-1)\n        # append sampled index to the running sequence and continue\n        idx = torch.cat((idx, idx_next), dim=1)\n\n    return idx\n\ndef print_samples(num=10):\n    \"\"\" samples from the model and pretty prints the decoded samples \"\"\"\n    X_init = torch.zeros(num, 1, dtype=torch.long).to(args.device)\n    top_k = args.top_k if args.top_k != -1 else None\n    steps = train_dataset.get_output_length() - 1 # -1 because we already start with <START> token (index 0)\n    X_samp = generate(model, X_init, steps, top_k=top_k, do_sample=True).to('cpu')\n    train_samples, test_samples, new_samples = [], [], []\n    for i in range(X_samp.size(0)):\n        # get the i'th row of sampled integers, as python list\n        row = X_samp[i, 1:].tolist() # note: we need to crop out the first <START> token\n        # token 0 is the <STOP> token, so we crop the output sequence at that point\n        crop_index = row.index(0) if 0 in row else len(row)\n        row = row[:crop_index]\n        word_samp = train_dataset.decode(row)\n        # separately track samples that we have and have not seen before\n        if train_dataset.contains(word_samp):\n            train_samples.append(word_samp)\n        elif test_dataset.contains(word_samp):\n            test_samples.append(word_samp)\n        else:\n            new_samples.append(word_samp)\n    print('-'*80)\n    for lst, desc in [(train_samples, 'in train'), (test_samples, 'in test'), (new_samples, 'new')]:\n        print(f\"{len(lst)} samples that are {desc}:\")\n        for word in lst:\n            print(word)\n    print('-'*80)\n\n@torch.inference_mode()\ndef evaluate(model, dataset, batch_size=50, max_batches=None):\n    model.eval()\n    loader = DataLoader(dataset, shuffle=True, batch_size=batch_size, num_workers=0)\n    losses = []\n    for i, batch in enumerate(loader):\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n        logits, loss = model(X, Y)\n        losses.append(loss.item())\n        if max_batches is not None and i >= max_batches:\n            break\n    mean_loss = torch.tensor(losses).mean().item()\n    model.train() # reset model back to training mode\n    return mean_loss\n\n# -----------------------------------------------------------------------------\n# helper functions for creating the training and test Datasets that emit words\n\nclass CharDataset(Dataset):\n\n    def __init__(self, words, chars, max_word_length):\n        self.words = words\n        self.chars = chars\n        self.max_word_length = max_word_length\n        self.stoi = {ch:i+1 for i,ch in enumerate(chars)}\n        self.itos = {i:s for s,i in self.stoi.items()} # inverse mapping\n\n    def __len__(self):\n        return len(self.words)\n\n    def contains(self, word):\n        return word in self.words\n\n    def get_vocab_size(self):\n        return len(self.chars) + 1 # all the possible characters and special 0 token\n\n    def get_output_length(self):\n        return self.max_word_length + 1 # <START> token followed by words\n\n    def encode(self, word):\n        ix = torch.tensor([self.stoi[w] for w in word], dtype=torch.long)\n        return ix\n\n    def decode(self, ix):\n        word = ''.join(self.itos[i] for i in ix)\n        return word\n\n    def __getitem__(self, idx):\n        word = self.words[idx]\n        ix = self.encode(word)\n        x = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        y = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        x[1:1+len(ix)] = ix\n        y[:len(ix)] = ix\n        y[len(ix)+1:] = -1 # index -1 will mask the loss at the inactive locations\n        return x, y\n\ndef create_datasets(input_file):\n\n    # preprocessing of the input text file\n    with open(input_file, 'r') as f:\n        data = f.read()\n    words = data.splitlines()\n    words = [w.strip() for w in words] # get rid of any leading or trailing white space\n    words = [w for w in words if w] # get rid of any empty strings\n    chars = sorted(list(set(''.join(words)))) # all the possible characters\n    max_word_length = max(len(w) for w in words)\n    print(f\"number of examples in the dataset: {len(words)}\")\n    print(f\"max word length: {max_word_length}\")\n    print(f\"number of unique characters in the vocabulary: {len(chars)}\")\n    print(\"vocabulary:\")\n    print(''.join(chars))\n\n    # partition the input data into a training and the test set\n    test_set_size = min(1000, int(len(words) * 0.1)) # 10% of the training set, or up to 1000 examples\n    rp = torch.randperm(len(words)).tolist()\n    train_words = [words[i] for i in rp[:-test_set_size]]\n    test_words = [words[i] for i in rp[-test_set_size:]]\n    print(f\"split up the dataset into {len(train_words)} training examples and {len(test_words)} test examples\")\n\n    # wrap in dataset objects\n    train_dataset = CharDataset(train_words, chars, max_word_length)\n    test_dataset = CharDataset(test_words, chars, max_word_length)\n\n    return train_dataset, test_dataset\n\nclass InfiniteDataLoader:\n    \"\"\"\n    this is really hacky and I'm not proud of it, but there doesn't seem to be\n    a better way in PyTorch to just create an infinite dataloader?\n    \"\"\"\n\n    def __init__(self, dataset, **kwargs):\n        train_sampler = torch.utils.data.RandomSampler(dataset, replacement=True, num_samples=int(1e10))\n        self.train_loader = DataLoader(dataset, sampler=train_sampler, **kwargs)\n        self.data_iter = iter(self.train_loader)\n\n    def next(self):\n        try:\n            batch = next(self.data_iter)\n        except StopIteration: # this will technically only happen after 1e10 samples... (i.e. basically never)\n            self.data_iter = iter(self.train_loader)\n            batch = next(self.data_iter)\n        return batch\n\n# -----------------------------------------------------------------------------\nif __name__ == '__main__':\n\n    # parse command line args\n    parser = argparse.ArgumentParser(description=\"Make More\")\n    # system/input/output\n    parser.add_argument('--input-file', '-i', type=str, default='names.txt', help=\"input file with things one per line\")\n    parser.add_argument('--work-dir', '-o', type=str, default='out', help=\"output working directory\")\n    parser.add_argument('--resume', action='store_true', help=\"when this flag is used, we will resume optimization from existing model in the workdir\")\n    parser.add_argument('--sample-only', action='store_true', help=\"just sample from the model and quit, don't train\")\n    parser.add_argument('--num-workers', '-n', type=int, default=4, help=\"number of data workers for both train/test\")\n    parser.add_argument('--max-steps', type=int, default=-1, help=\"max number of optimization steps to run for, or -1 for infinite.\")\n    parser.add_argument('--device', type=str, default='cpu', help=\"device to use for compute, examples: cpu|cuda|cuda:2|mps\")\n    parser.add_argument('--seed', type=int, default=3407, help=\"seed\")\n    # sampling\n    parser.add_argument('--top-k', type=int, default=-1, help=\"top-k for sampling, -1 means no top-k\")\n    # model\n    parser.add_argument('--type', type=str, default='bigram', help=\"model class type to use, bigram|mlp|rnn|gru|transformer\")\n    parser.add_argument('--n-layer', type=int, default=4, help=\"number of layers\")\n    parser.add_argument('--n-head', type=int, default=4, help=\"number of heads (in a transformer)\")\n    parser.add_argument('--n-embd', type=int, default=64, help=\"number of feature channels in the model\")\n    parser.add_argument('--n-embd2', type=int, default=64, help=\"number of feature channels elsewhere in the model\")\n    # optimization\n    parser.add_argument('--batch-size', '-b', type=int, default=32, help=\"batch size during optimization\")\n    parser.add_argument('--learning-rate', '-l', type=float, default=5e-4, help=\"learning rate\")\n    parser.add_argument('--weight-decay', '-w', type=float, default=0.01, help=\"weight decay\")\n    args = parser.parse_args()\n    print(vars(args))\n\n    # system inits\n    torch.manual_seed(args.seed)\n    torch.cuda.manual_seed_all(args.seed)\n    os.makedirs(args.work_dir, exist_ok=True)\n    writer = SummaryWriter(log_dir=args.work_dir)\n\n    # init datasets\n    train_dataset, test_dataset = create_datasets(args.input_file)\n    vocab_size = train_dataset.get_vocab_size()\n    block_size = train_dataset.get_output_length()\n    print(f\"dataset determined that: {vocab_size=}, {block_size=}\")\n\n    # init model\n    config = ModelConfig(vocab_size=vocab_size, block_size=block_size,\n                       n_layer=args.n_layer, n_head=args.n_head,\n                       n_embd=args.n_embd, n_embd2=args.n_embd2)\n    if args.type == 'transformer':\n        model = Transformer(config)\n    elif args.type == 'bigram':\n        model = Bigram(config)\n    elif args.type == 'mlp':\n        model = MLP(config)\n    elif args.type == 'rnn':\n        model = RNN(config, cell_type='rnn')\n    elif args.type == 'gru':\n        model = RNN(config, cell_type='gru')\n    else:\n        raise ValueError(f'model type {args.type} is not recognized')\n    model.to(args.device)\n    print(f\"model #params: {sum(p.numel() for p in model.parameters())}\")\n    if args.resume or args.sample_only: # note: if we sample-only then we also assume we are resuming\n        print(\"resuming from existing model in the workdir\")\n        model.load_state_dict(torch.load(os.path.join(args.work_dir, 'model.pt')))\n    if args.sample_only:\n        print_samples(num=50)\n        sys.exit()\n\n    # init optimizer\n    optimizer = torch.optim.AdamW(model.parameters(), lr=args.learning_rate, weight_decay=args.weight_decay, betas=(0.9, 0.99), eps=1e-8)\n\n    # init dataloader\n    batch_loader = InfiniteDataLoader(train_dataset, batch_size=args.batch_size, pin_memory=True, num_workers=args.num_workers)\n\n    # training loop\n    best_loss = None\n    step = 0\n    while True:\n\n        t0 = time.time()\n\n        # get the next batch, ship to device, and unpack it to input and target\n        batch = batch_loader.next()\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n\n        # feed into the model\n        logits, loss = model(X, Y)\n\n        # calculate the gradient, update the weights\n        model.zero_grad(set_to_none=True)\n        loss.backward()\n        optimizer.step()\n\n        # wait for all CUDA work on the GPU to finish then calculate iteration time taken\n        if args.device.startswith('cuda'):\n            torch.cuda.synchronize()\n        t1 = time.time()\n\n        # logging\n        if step % 10 == 0:\n            print(f\"step {step} | loss {loss.item():.4f} | step time {(t1-t0)*1000:.2f}ms\")\n\n        # evaluate the model\n        if step > 0 and step % 500 == 0:\n            train_loss = evaluate(model, train_dataset, batch_size=100, max_batches=10)\n            test_loss  = evaluate(model, test_dataset,  batch_size=100, max_batches=10)\n            writer.add_scalar(\"Loss/train\", train_loss, step)\n            writer.add_scalar(\"Loss/test\", test_loss, step)\n            writer.flush()\n            print(f\"step {step} train loss: {train_loss} test loss: {test_loss}\")\n            # save the model to disk if it has improved\n            if best_loss is None or test_loss < best_loss:\n                out_path = os.path.join(args.work_dir, \"model.pt\")\n                print(f\"test loss {test_loss} is the best so far, saving model to {out_path}\")\n                torch.save(model.state_dict(), out_path)\n                best_loss = test_loss\n\n        # sample from the model\n        if step > 0 and step % 200 == 0:\n            print_samples(num=10)\n\n        step += 1\n        # termination conditions\n        if args.max_steps >= 0 and step >= args.max_steps:\n            break\n\n", "previous_id": "b697f434bc2ff3c355cc26e849693492028c4a22", "new_code_file": "\"\"\"\nyou give this script some words (one per line) and it will generate more things like it.\nuses super state of the art Transformer AI tech\nthis code is intended to be super hackable. tune it to your needs.\n\nChanges from minGPT:\n- I removed the from_pretrained function where we init with GPT2 weights\n- I removed dropout layers because the models we train here are small,\n  it's not necessary to understand at this stage and at this scale.\n- I removed weight decay and all of the complexity around what parameters are\n  and are not weight decayed. I don't believe this should make a massive\n  difference at the scale that we operate on here.\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport math\nimport argparse\nfrom dataclasses import dataclass\nfrom typing import List\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\nfrom torch.utils.data import Dataset\nfrom torch.utils.data.dataloader import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\n# -----------------------------------------------------------------------------\n\n@dataclass\nclass ModelConfig:\n    block_size: int = None # length of the input sequences of integers\n    vocab_size: int = None # the input integers are in range [0 .. vocab_size -1]\n    # parameters below control the sizes of each model slightly differently\n    n_layer: int = 4\n    n_embd: int = 64\n    n_embd2: int = 64\n    n_head: int = 4\n\n# -----------------------------------------------------------------------------\n# Transformer Language Model (*exactly* as used in GPT-2)\n\nclass NewGELU(nn.Module):\n    \"\"\"\n    Implementation of the GELU activation function currently in Google BERT repo (identical to OpenAI GPT).\n    Reference: Gaussian Error Linear Units (GELU) paper: https://arxiv.org/abs/1606.08415\n    \"\"\"\n    def forward(self, x):\n        return 0.5 * x * (1.0 + torch.tanh(math.sqrt(2.0 / math.pi) * (x + 0.044715 * torch.pow(x, 3.0))))\n\nclass CausalSelfAttention(nn.Module):\n    \"\"\"\n    A vanilla multi-head masked self-attention layer with a projection at the end.\n    It is possible to use torch.nn.MultiheadAttention here but I am including an\n    explicit implementation here to show that there is nothing too scary here.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.n_embd % config.n_head == 0\n        # key, query, value projections for all heads, but in a batch\n        self.c_attn = nn.Linear(config.n_embd, 3 * config.n_embd)\n        # output projection\n        self.c_proj = nn.Linear(config.n_embd, config.n_embd)\n        # causal mask to ensure that attention is only applied to the left in the input sequence\n        self.register_buffer(\"bias\", torch.tril(torch.ones(config.block_size, config.block_size))\n                                     .view(1, 1, config.block_size, config.block_size))\n        self.n_head = config.n_head\n        self.n_embd = config.n_embd\n\n    def forward(self, x):\n        B, T, C = x.size() # batch size, sequence length, embedding dimensionality (n_embd)\n\n        # calculate query, key, values for all heads in batch and move head forward to be the batch dim\n        q, k ,v  = self.c_attn(x).split(self.n_embd, dim=2)\n        k = k.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        q = q.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        v = v.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n\n        # causal self-attention; Self-attend: (B, nh, T, hs) x (B, nh, hs, T) -> (B, nh, T, T)\n        att = (q @ k.transpose(-2, -1)) * (1.0 / math.sqrt(k.size(-1)))\n        att = att.masked_fill(self.bias[:,:,:T,:T] == 0, float('-inf'))\n        att = F.softmax(att, dim=-1)\n        y = att @ v # (B, nh, T, T) x (B, nh, T, hs) -> (B, nh, T, hs)\n        y = y.transpose(1, 2).contiguous().view(B, T, C) # re-assemble all head outputs side by side\n\n        # output projection\n        y = self.c_proj(y)\n        return y\n\nclass Block(nn.Module):\n    \"\"\" an unassuming Transformer block \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.ln_1 = nn.LayerNorm(config.n_embd)\n        self.attn = CausalSelfAttention(config)\n        self.ln_2 = nn.LayerNorm(config.n_embd)\n        self.mlp = nn.ModuleDict(dict(\n            c_fc    = nn.Linear(config.n_embd, 4 * config.n_embd),\n            c_proj  = nn.Linear(4 * config.n_embd, config.n_embd),\n            act     = NewGELU(),\n        ))\n        m = self.mlp\n        self.mlpf = lambda x: m.c_proj(m.act(m.c_fc(x))) # MLP forward\n\n    def forward(self, x):\n        x = x + self.attn(self.ln_1(x))\n        x = x + self.mlpf(self.ln_2(x))\n        return x\n\nclass Transformer(nn.Module):\n    \"\"\" Transformer Language Model, exactly as seen in GPT-2 \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.block_size = config.block_size\n\n        self.transformer = nn.ModuleDict(dict(\n            wte = nn.Embedding(config.vocab_size, config.n_embd),\n            wpe = nn.Embedding(config.block_size, config.n_embd),\n            h = nn.ModuleList([Block(config) for _ in range(config.n_layer)]),\n            ln_f = nn.LayerNorm(config.n_embd),\n        ))\n        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n\n        # report number of parameters (note we don't count the decoder parameters in lm_head)\n        n_params = sum(p.numel() for p in self.transformer.parameters())\n        print(\"number of parameters: %.2fM\" % (n_params/1e6,))\n\n    def get_block_size(self):\n        return self.block_size\n\n    def forward(self, idx, targets=None):\n        device = idx.device\n        b, t = idx.size()\n        assert t <= self.block_size, f\"Cannot forward sequence of length {t}, block size is only {self.block_size}\"\n        pos = torch.arange(0, t, dtype=torch.long, device=device).unsqueeze(0) # shape (1, t)\n\n        # forward the GPT model itself\n        tok_emb = self.transformer.wte(idx) # token embeddings of shape (b, t, n_embd)\n        pos_emb = self.transformer.wpe(pos) # position embeddings of shape (1, t, n_embd)\n        x = tok_emb + pos_emb\n        for block in self.transformer.h:\n            x = block(x)\n        x = self.transformer.ln_f(x)\n        logits = self.lm_head(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n# Bag of Words (BoW) language model\n\nclass CausalBoW(nn.Module):\n    \"\"\"\n    Causal bag of words. Averages the preceding elements and looks suspiciously like\n    a CausalAttention module you'd find in a transformer, for no apparent reason at all ;)\n    \"\"\"\n    def __init__(self, config):\n        super().__init__()\n\n        # used to mask out vectors and preserve autoregressive property\n        self.block_size = config.block_size\n        self.register_buffer(\"bias\", torch.tril(torch.ones(config.block_size, config.block_size))\n                            .view(1, config.block_size, config.block_size))\n\n    def forward(self, x):\n        B, T, C = x.size() # batch size, sequence length, n_embd\n\n        # do the weighted average of all preceeding token features\n        att = torch.zeros((B, T, T), device=x.device)\n        att = att.masked_fill(self.bias[:,:T,:T] == 0, float('-inf'))\n        att = F.softmax(att, dim=-1)\n        y = att @ x # (B, T, T) x (B, T, C) -> (B, T, C)\n\n        return y\n\nclass BoWBlock(nn.Module):\n    \"\"\" collects BoW features and adds an MLP \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n\n        # Causal BoW module\n        self.cbow = CausalBoW(config)\n        # MLP assembler\n        self.mlp = nn.ModuleDict(dict(\n            c_fc    = nn.Linear(config.n_embd, config.n_embd2),\n            c_proj  = nn.Linear(config.n_embd2, config.n_embd),\n        ))\n        m = self.mlp\n        self.mlpf = lambda x: m.c_proj(F.tanh(m.c_fc(x))) # MLP forward\n\n    def forward(self, x):\n        x = x + self.cbow(x)\n        x = x + self.mlpf(x)\n        return x\n\nclass BoW(nn.Module):\n    \"\"\"\n    takes the previous block_size tokens, encodes them with a lookup table,\n    also encodes their positions with lookup table, then averages all of those\n    embeddings up and uses that to predict the next token.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.block_size = config.block_size\n        self.vocab_size = config.vocab_size\n        # token embedding\n        self.wte = nn.Embedding(config.vocab_size, config.n_embd)\n        # position embedding\n        self.wpe = nn.Embedding(config.block_size, config.n_embd)\n        # context block\n        self.context_block = BoWBlock(config)\n        # language model head decoder layer\n        self.lm_head = nn.Linear(config.n_embd, self.vocab_size)\n\n    def get_block_size(self):\n        return self.block_size\n\n    def forward(self, idx, targets=None):\n\n        device = idx.device\n        b, t = idx.size()\n        assert t <= self.block_size, f\"Cannot forward sequence of length {t}, block size is only {self.block_size}\"\n        pos = torch.arange(0, t, dtype=torch.long, device=device).unsqueeze(0) # shape (1, t)\n\n        # forward the token and position embedding layers\n        tok_emb = self.wte(idx) # token embeddings of shape (b, t, n_embd)\n        pos_emb = self.wpe(pos) # position embeddings of shape (1, t, n_embd)\n        # add and run through the decoder MLP\n        x = tok_emb + pos_emb\n        # run the bag of words context module\n        x = self.context_block(x)\n        # decode to next token probability\n        logits = self.lm_head(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n\"\"\"\nRecurrent Neural Net language model: either a vanilla RNN recurrence or a GRU.\nDid not implement an LSTM because its API is a bit more annoying as it has\nboth a hidden state and a cell state, but it's very similar to GRU and in\npractice works just as well.\n\"\"\"\n\nclass RNNCell(nn.Module):\n    \"\"\"\n    the job of a 'Cell' is to:\n    take input at current time step x_{t} and the hidden state at the\n    previous time step h_{t-1} and return the resulting hidden state\n    h_{t} at the current timestep\n    \"\"\"\n    def __init__(self, config):\n        super().__init__()\n        self.xh_to_h = nn.Linear(config.n_embd + config.n_embd2, config.n_embd2)\n\n    def forward(self, xt, hprev):\n        xh = torch.cat([xt, hprev], dim=1)\n        ht = F.tanh(self.xh_to_h(xh))\n        return ht\n\nclass GRUCell(nn.Module):\n    \"\"\"\n    same job as RNN cell, but a bit more complicated recurrence formula\n    that makes the GRU more expressive and easier to optimize.\n    \"\"\"\n    def __init__(self, config):\n        super().__init__()\n        # input, forget, output, gate\n        self.xh_to_z = nn.Linear(config.n_embd + config.n_embd2, config.n_embd2)\n        self.xh_to_r = nn.Linear(config.n_embd + config.n_embd2, config.n_embd2)\n        self.xh_to_hbar = nn.Linear(config.n_embd + config.n_embd2, config.n_embd2)\n\n    def forward(self, xt, hprev):\n        # first use the reset gate to wipe some channels of the hidden state to zero\n        xh = torch.cat([xt, hprev], dim=1)\n        r = F.sigmoid(self.xh_to_r(xh))\n        hprev_reset = r * hprev\n        # calculate the candidate new hidden state hbar\n        xhr = torch.cat([xt, hprev_reset], dim=1)\n        hbar = F.tanh(self.xh_to_hbar(xhr))\n        # calculate the switch gate that determines if each channel should be updated at all\n        z = F.sigmoid(self.xh_to_z(xh))\n        # blend the previous hidden state and the new candidate hidden state\n        ht = (1 - z) * hprev + z * hbar\n        return ht\n\nclass RNN(nn.Module):\n\n    def __init__(self, config, cell_type):\n        super().__init__()\n        self.block_size = config.block_size\n        self.vocab_size = config.vocab_size\n        self.start = nn.Parameter(torch.zeros(1, config.n_embd2)) # the starting hidden state\n        self.wte = nn.Embedding(config.vocab_size, config.n_embd) # token embeddings table\n        if cell_type == 'rnn':\n            self.cell = RNNCell(config)\n        elif cell_type == 'gru':\n            self.cell = GRUCell(config)\n        self.lm_head = nn.Linear(config.n_embd2, self.vocab_size)\n\n    def get_block_size(self):\n        return self.block_size\n\n    def forward(self, idx, targets=None):\n        device = idx.device\n        b, t = idx.size()\n\n        # embed all the integers up front and all at once for efficiency\n        emb = self.wte(idx) # (b, t, n_embd)\n\n        # sequentially iterate over the inputs and update the RNN state each tick\n        hprev = self.start.expand((b, -1)) # expand out the batch dimension\n        hiddens = []\n        for i in range(t):\n            xt = emb[:, i, :] # (b, n_embd)\n            ht = self.cell(xt, hprev) # (b, n_embd2)\n            hiddens.append(ht)\n\n        # decode the outputs\n        hidden = torch.stack(hiddens, 1) # (b, t, n_embd2)\n        logits = self.lm_head(hidden)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n# MLP language model\n\nclass MLP(nn.Module):\n    \"\"\"\n    takes the previous block_size tokens, encodes them with a lookup table,\n    concatenates the vectors and predicts the next token with an MLP.\n\n    Reference:\n    Bengio et al. 2003 https://www.jmlr.org/papers/volume3/bengio03a/bengio03a.pdf\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.block_size = config.block_size\n        self.vocab_size = config.vocab_size\n        self.wte = nn.Embedding(config.vocab_size + 1, config.n_embd) # token embeddings table\n        # +1 in the line above for a special <BLANK> token that gets inserted if encoding a token\n        # before the beginning of the input sequence\n        self.mlp = nn.Sequential(\n            nn.Linear(self.block_size * config.n_embd, config.n_embd2),\n            nn.Tanh(),\n            nn.Linear(config.n_embd2, self.vocab_size)\n        )\n\n    def get_block_size(self):\n        return self.block_size\n\n    def forward(self, idx, targets=None):\n\n        # gather the word embeddings of the previous 3 words\n        embs = []\n        for k in range(self.block_size):\n            tok_emb = self.wte(idx) # token embeddings of shape (b, t, n_embd)\n            idx = torch.roll(idx, 1, 1)\n            idx[:, 0] = self.vocab_size # special <BLANK> token\n            embs.append(tok_emb)\n\n        # concat all of the embeddings together and pass through an MLP\n        x = torch.cat(embs, -1) # (b, t, n_embd * block_size)\n        logits = self.mlp(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n# Bigram language model\n\nclass Bigram(nn.Module):\n    \"\"\"\n    Bigram Language Model 'neural net', simply a lookup table of logits for the\n    next character given a previous character.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        n = config.vocab_size\n        self.logits = nn.Parameter(torch.zeros((n, n)))\n\n    def get_block_size(self):\n        return 1 # this model only needs one previous character to predict the next\n\n    def forward(self, idx, targets=None):\n\n         # 'forward pass', lol\n        logits = self.logits[idx]\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n# helper functions for evaluating and sampling from the model\n\n@torch.no_grad()\ndef generate(model, idx, max_new_tokens, temperature=1.0, do_sample=False, top_k=None):\n    \"\"\"\n    Take a conditioning sequence of indices idx (LongTensor of shape (b,t)) and complete\n    the sequence max_new_tokens times, feeding the predictions back into the model each time.\n    Most likely you'll want to make sure to be in model.eval() mode of operation for this.\n    \"\"\"\n    block_size = model.get_block_size()\n    for _ in range(max_new_tokens):\n        # if the sequence context is growing too long we must crop it at block_size\n        idx_cond = idx if idx.size(1) <= block_size else idx[:, -block_size:]\n        # forward the model to get the logits for the index in the sequence\n        logits, _ = model(idx_cond)\n        # pluck the logits at the final step and scale by desired temperature\n        logits = logits[:, -1, :] / temperature\n        # optionally crop the logits to only the top k options\n        if top_k is not None:\n            v, _ = torch.topk(logits, top_k)\n            logits[logits < v[:, [-1]]] = -float('Inf')\n        # apply softmax to convert logits to (normalized) probabilities\n        probs = F.softmax(logits, dim=-1)\n        # either sample from the distribution or take the most likely element\n        if do_sample:\n            idx_next = torch.multinomial(probs, num_samples=1)\n        else:\n            _, idx_next = torch.topk(probs, k=1, dim=-1)\n        # append sampled index to the running sequence and continue\n        idx = torch.cat((idx, idx_next), dim=1)\n\n    return idx\n\ndef print_samples(num=10):\n    \"\"\" samples from the model and pretty prints the decoded samples \"\"\"\n    X_init = torch.zeros(num, 1, dtype=torch.long).to(args.device)\n    top_k = args.top_k if args.top_k != -1 else None\n    steps = train_dataset.get_output_length() - 1 # -1 because we already start with <START> token (index 0)\n    X_samp = generate(model, X_init, steps, top_k=top_k, do_sample=True).to('cpu')\n    train_samples, test_samples, new_samples = [], [], []\n    for i in range(X_samp.size(0)):\n        # get the i'th row of sampled integers, as python list\n        row = X_samp[i, 1:].tolist() # note: we need to crop out the first <START> token\n        # token 0 is the <STOP> token, so we crop the output sequence at that point\n        crop_index = row.index(0) if 0 in row else len(row)\n        row = row[:crop_index]\n        word_samp = train_dataset.decode(row)\n        # separately track samples that we have and have not seen before\n        if train_dataset.contains(word_samp):\n            train_samples.append(word_samp)\n        elif test_dataset.contains(word_samp):\n            test_samples.append(word_samp)\n        else:\n            new_samples.append(word_samp)\n    print('-'*80)\n    for lst, desc in [(train_samples, 'in train'), (test_samples, 'in test'), (new_samples, 'new')]:\n        print(f\"{len(lst)} samples that are {desc}:\")\n        for word in lst:\n            print(word)\n    print('-'*80)\n\n@torch.inference_mode()\ndef evaluate(model, dataset, batch_size=50, max_batches=None):\n    model.eval()\n    loader = DataLoader(dataset, shuffle=True, batch_size=batch_size, num_workers=0)\n    losses = []\n    for i, batch in enumerate(loader):\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n        logits, loss = model(X, Y)\n        losses.append(loss.item())\n        if max_batches is not None and i >= max_batches:\n            break\n    mean_loss = torch.tensor(losses).mean().item()\n    model.train() # reset model back to training mode\n    return mean_loss\n\n# -----------------------------------------------------------------------------\n# helper functions for creating the training and test Datasets that emit words\n\nclass CharDataset(Dataset):\n\n    def __init__(self, words, chars, max_word_length):\n        self.words = words\n        self.chars = chars\n        self.max_word_length = max_word_length\n        self.stoi = {ch:i+1 for i,ch in enumerate(chars)}\n        self.itos = {i:s for s,i in self.stoi.items()} # inverse mapping\n\n    def __len__(self):\n        return len(self.words)\n\n    def contains(self, word):\n        return word in self.words\n\n    def get_vocab_size(self):\n        return len(self.chars) + 1 # all the possible characters and special 0 token\n\n    def get_output_length(self):\n        return self.max_word_length + 1 # <START> token followed by words\n\n    def encode(self, word):\n        ix = torch.tensor([self.stoi[w] for w in word], dtype=torch.long)\n        return ix\n\n    def decode(self, ix):\n        word = ''.join(self.itos[i] for i in ix)\n        return word\n\n    def __getitem__(self, idx):\n        word = self.words[idx]\n        ix = self.encode(word)\n        x = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        y = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        x[1:1+len(ix)] = ix\n        y[:len(ix)] = ix\n        y[len(ix)+1:] = -1 # index -1 will mask the loss at the inactive locations\n        return x, y\n\ndef create_datasets(input_file):\n\n    # preprocessing of the input text file\n    with open(input_file, 'r') as f:\n        data = f.read()\n    words = data.splitlines()\n    words = [w.strip() for w in words] # get rid of any leading or trailing white space\n    words = [w for w in words if w] # get rid of any empty strings\n    chars = sorted(list(set(''.join(words)))) # all the possible characters\n    max_word_length = max(len(w) for w in words)\n    print(f\"number of examples in the dataset: {len(words)}\")\n    print(f\"max word length: {max_word_length}\")\n    print(f\"number of unique characters in the vocabulary: {len(chars)}\")\n    print(\"vocabulary:\")\n    print(''.join(chars))\n\n    # partition the input data into a training and the test set\n    test_set_size = min(1000, int(len(words) * 0.1)) # 10% of the training set, or up to 1000 examples\n    rp = torch.randperm(len(words)).tolist()\n    train_words = [words[i] for i in rp[:-test_set_size]]\n    test_words = [words[i] for i in rp[-test_set_size:]]\n    print(f\"split up the dataset into {len(train_words)} training examples and {len(test_words)} test examples\")\n\n    # wrap in dataset objects\n    train_dataset = CharDataset(train_words, chars, max_word_length)\n    test_dataset = CharDataset(test_words, chars, max_word_length)\n\n    return train_dataset, test_dataset\n\nclass InfiniteDataLoader:\n    \"\"\"\n    this is really hacky and I'm not proud of it, but there doesn't seem to be\n    a better way in PyTorch to just create an infinite dataloader?\n    \"\"\"\n\n    def __init__(self, dataset, **kwargs):\n        train_sampler = torch.utils.data.RandomSampler(dataset, replacement=True, num_samples=int(1e10))\n        self.train_loader = DataLoader(dataset, sampler=train_sampler, **kwargs)\n        self.data_iter = iter(self.train_loader)\n\n    def next(self):\n        try:\n            batch = next(self.data_iter)\n        except StopIteration: # this will technically only happen after 1e10 samples... (i.e. basically never)\n            self.data_iter = iter(self.train_loader)\n            batch = next(self.data_iter)\n        return batch\n\n# -----------------------------------------------------------------------------\nif __name__ == '__main__':\n\n    # parse command line args\n    parser = argparse.ArgumentParser(description=\"Make More\")\n    # system/input/output\n    parser.add_argument('--input-file', '-i', type=str, default='names.txt', help=\"input file with things one per line\")\n    parser.add_argument('--work-dir', '-o', type=str, default='out', help=\"output working directory\")\n    parser.add_argument('--resume', action='store_true', help=\"when this flag is used, we will resume optimization from existing model in the workdir\")\n    parser.add_argument('--sample-only', action='store_true', help=\"just sample from the model and quit, don't train\")\n    parser.add_argument('--num-workers', '-n', type=int, default=4, help=\"number of data workers for both train/test\")\n    parser.add_argument('--max-steps', type=int, default=-1, help=\"max number of optimization steps to run for, or -1 for infinite.\")\n    parser.add_argument('--device', type=str, default='cpu', help=\"device to use for compute, examples: cpu|cuda|cuda:2|mps\")\n    parser.add_argument('--seed', type=int, default=3407, help=\"seed\")\n    # sampling\n    parser.add_argument('--top-k', type=int, default=-1, help=\"top-k for sampling, -1 means no top-k\")\n    # model\n    parser.add_argument('--type', type=str, default='transformer', help=\"model class type to use, bigram|mlp|rnn|gru|bow|transformer\")\n    parser.add_argument('--n-layer', type=int, default=4, help=\"number of layers\")\n    parser.add_argument('--n-head', type=int, default=4, help=\"number of heads (in a transformer)\")\n    parser.add_argument('--n-embd', type=int, default=64, help=\"number of feature channels in the model\")\n    parser.add_argument('--n-embd2', type=int, default=64, help=\"number of feature channels elsewhere in the model\")\n    # optimization\n    parser.add_argument('--batch-size', '-b', type=int, default=32, help=\"batch size during optimization\")\n    parser.add_argument('--learning-rate', '-l', type=float, default=5e-4, help=\"learning rate\")\n    parser.add_argument('--weight-decay', '-w', type=float, default=0.01, help=\"weight decay\")\n    args = parser.parse_args()\n    print(vars(args))\n\n    # system inits\n    torch.manual_seed(args.seed)\n    torch.cuda.manual_seed_all(args.seed)\n    os.makedirs(args.work_dir, exist_ok=True)\n    writer = SummaryWriter(log_dir=args.work_dir)\n\n    # init datasets\n    train_dataset, test_dataset = create_datasets(args.input_file)\n    vocab_size = train_dataset.get_vocab_size()\n    block_size = train_dataset.get_output_length()\n    print(f\"dataset determined that: {vocab_size=}, {block_size=}\")\n\n    # init model\n    config = ModelConfig(vocab_size=vocab_size, block_size=block_size,\n                       n_layer=args.n_layer, n_head=args.n_head,\n                       n_embd=args.n_embd, n_embd2=args.n_embd2)\n    if args.type == 'transformer':\n        model = Transformer(config)\n    elif args.type == 'bigram':\n        model = Bigram(config)\n    elif args.type == 'mlp':\n        model = MLP(config)\n    elif args.type == 'rnn':\n        model = RNN(config, cell_type='rnn')\n    elif args.type == 'gru':\n        model = RNN(config, cell_type='gru')\n    elif args.type == 'bow':\n        model = BoW(config)\n    else:\n        raise ValueError(f'model type {args.type} is not recognized')\n    model.to(args.device)\n    print(f\"model #params: {sum(p.numel() for p in model.parameters())}\")\n    if args.resume or args.sample_only: # note: if we sample-only then we also assume we are resuming\n        print(\"resuming from existing model in the workdir\")\n        model.load_state_dict(torch.load(os.path.join(args.work_dir, 'model.pt')))\n    if args.sample_only:\n        print_samples(num=50)\n        sys.exit()\n\n    # init optimizer\n    optimizer = torch.optim.AdamW(model.parameters(), lr=args.learning_rate, weight_decay=args.weight_decay, betas=(0.9, 0.99), eps=1e-8)\n\n    # init dataloader\n    batch_loader = InfiniteDataLoader(train_dataset, batch_size=args.batch_size, pin_memory=True, num_workers=args.num_workers)\n\n    # training loop\n    best_loss = None\n    step = 0\n    while True:\n\n        t0 = time.time()\n\n        # get the next batch, ship to device, and unpack it to input and target\n        batch = batch_loader.next()\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n\n        # feed into the model\n        logits, loss = model(X, Y)\n\n        # calculate the gradient, update the weights\n        model.zero_grad(set_to_none=True)\n        loss.backward()\n        optimizer.step()\n\n        # wait for all CUDA work on the GPU to finish then calculate iteration time taken\n        if args.device.startswith('cuda'):\n            torch.cuda.synchronize()\n        t1 = time.time()\n\n        # logging\n        if step % 10 == 0:\n            print(f\"step {step} | loss {loss.item():.4f} | step time {(t1-t0)*1000:.2f}ms\")\n\n        # evaluate the model\n        if step > 0 and step % 500 == 0:\n            train_loss = evaluate(model, train_dataset, batch_size=100, max_batches=10)\n            test_loss  = evaluate(model, test_dataset,  batch_size=100, max_batches=10)\n            writer.add_scalar(\"Loss/train\", train_loss, step)\n            writer.add_scalar(\"Loss/test\", test_loss, step)\n            writer.flush()\n            print(f\"step {step} train loss: {train_loss} test loss: {test_loss}\")\n            # save the model to disk if it has improved\n            if best_loss is None or test_loss < best_loss:\n                out_path = os.path.join(args.work_dir, \"model.pt\")\n                print(f\"test loss {test_loss} is the best so far, saving model to {out_path}\")\n                torch.save(model.state_dict(), out_path)\n                best_loss = test_loss\n\n        # sample from the model\n        if step > 0 and step % 200 == 0:\n            print_samples(num=10)\n\n        step += 1\n        # termination conditions\n        if args.max_steps >= 0 and step >= args.max_steps:\n            break\n\n", "diff": "@@ -155,6 +155,101 @@ def forward(self, idx, targets=None):\n \n         return logits, loss\n \n+# -----------------------------------------------------------------------------\n+# Bag of Words (BoW) language model\n+\n+class CausalBoW(nn.Module):\n+    \"\"\"\n+    Causal bag of words. Averages the preceding elements and looks suspiciously like\n+    a CausalAttention module you'd find in a transformer, for no apparent reason at all ;)\n+    \"\"\"\n+    def __init__(self, config):\n+        super().__init__()\n+\n+        # used to mask out vectors and preserve autoregressive property\n+        self.block_size = config.block_size\n+        self.register_buffer(\"bias\", torch.tril(torch.ones(config.block_size, config.block_size))\n+                            .view(1, config.block_size, config.block_size))\n+\n+    def forward(self, x):\n+        B, T, C = x.size() # batch size, sequence length, n_embd\n+\n+        # do the weighted average of all preceeding token features\n+        att = torch.zeros((B, T, T), device=x.device)\n+        att = att.masked_fill(self.bias[:,:T,:T] == 0, float('-inf'))\n+        att = F.softmax(att, dim=-1)\n+        y = att @ x # (B, T, T) x (B, T, C) -> (B, T, C)\n+\n+        return y\n+\n+class BoWBlock(nn.Module):\n+    \"\"\" collects BoW features and adds an MLP \"\"\"\n+\n+    def __init__(self, config):\n+        super().__init__()\n+\n+        # Causal BoW module\n+        self.cbow = CausalBoW(config)\n+        # MLP assembler\n+        self.mlp = nn.ModuleDict(dict(\n+            c_fc    = nn.Linear(config.n_embd, config.n_embd2),\n+            c_proj  = nn.Linear(config.n_embd2, config.n_embd),\n+        ))\n+        m = self.mlp\n+        self.mlpf = lambda x: m.c_proj(F.tanh(m.c_fc(x))) # MLP forward\n+\n+    def forward(self, x):\n+        x = x + self.cbow(x)\n+        x = x + self.mlpf(x)\n+        return x\n+\n+class BoW(nn.Module):\n+    \"\"\"\n+    takes the previous block_size tokens, encodes them with a lookup table,\n+    also encodes their positions with lookup table, then averages all of those\n+    embeddings up and uses that to predict the next token.\n+    \"\"\"\n+\n+    def __init__(self, config):\n+        super().__init__()\n+        self.block_size = config.block_size\n+        self.vocab_size = config.vocab_size\n+        # token embedding\n+        self.wte = nn.Embedding(config.vocab_size, config.n_embd)\n+        # position embedding\n+        self.wpe = nn.Embedding(config.block_size, config.n_embd)\n+        # context block\n+        self.context_block = BoWBlock(config)\n+        # language model head decoder layer\n+        self.lm_head = nn.Linear(config.n_embd, self.vocab_size)\n+\n+    def get_block_size(self):\n+        return self.block_size\n+\n+    def forward(self, idx, targets=None):\n+\n+        device = idx.device\n+        b, t = idx.size()\n+        assert t <= self.block_size, f\"Cannot forward sequence of length {t}, block size is only {self.block_size}\"\n+        pos = torch.arange(0, t, dtype=torch.long, device=device).unsqueeze(0) # shape (1, t)\n+\n+        # forward the token and position embedding layers\n+        tok_emb = self.wte(idx) # token embeddings of shape (b, t, n_embd)\n+        pos_emb = self.wpe(pos) # position embeddings of shape (1, t, n_embd)\n+        # add and run through the decoder MLP\n+        x = tok_emb + pos_emb\n+        # run the bag of words context module\n+        x = self.context_block(x)\n+        # decode to next token probability\n+        logits = self.lm_head(x)\n+\n+        # if we are given some desired targets also calculate the loss\n+        loss = None\n+        if targets is not None:\n+            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n+\n+        return logits, loss\n+\n # -----------------------------------------------------------------------------\n \"\"\"\n Recurrent Neural Net language model: either a vanilla RNN recurrence or a GRU.\n@@ -268,7 +363,7 @@ def __init__(self, config):\n         # +1 in the line above for a special <BLANK> token that gets inserted if encoding a token\n         # before the beginning of the input sequence\n         self.mlp = nn.Sequential(\n-            nn.Linear(self.block_size * config.n_embd, config.n_embd2), # TODO: option to vary this\n+            nn.Linear(self.block_size * config.n_embd, config.n_embd2),\n             nn.Tanh(),\n             nn.Linear(config.n_embd2, self.vocab_size)\n         )\n@@ -511,7 +606,7 @@ def next(self):\n     # sampling\n     parser.add_argument('--top-k', type=int, default=-1, help=\"top-k for sampling, -1 means no top-k\")\n     # model\n-    parser.add_argument('--type', type=str, default='bigram', help=\"model class type to use, bigram|mlp|rnn|gru|transformer\")\n+    parser.add_argument('--type', type=str, default='transformer', help=\"model class type to use, bigram|mlp|rnn|gru|bow|transformer\")\n     parser.add_argument('--n-layer', type=int, default=4, help=\"number of layers\")\n     parser.add_argument('--n-head', type=int, default=4, help=\"number of heads (in a transformer)\")\n     parser.add_argument('--n-embd', type=int, default=64, help=\"number of feature channels in the model\")\n@@ -549,6 +644,8 @@ def next(self):\n         model = RNN(config, cell_type='rnn')\n     elif args.type == 'gru':\n         model = RNN(config, cell_type='gru')\n+    elif args.type == 'bow':\n+        model = BoW(config)\n     else:\n         raise ValueError(f'model type {args.type} is not recognized')\n     model.to(args.device)", "status": "modified"}, {"commit_id": "b697f434bc2ff3c355cc26e849693492028c4a22", "commit_message": "add an RNN and a GRU language model", "relative_path": "makemore.py", "previous_code_file": "\"\"\"\nyou give this script some words (one per line) and it will generate more things like it.\nuses super state of the art Transformer AI tech\nthis code is intended to be super hackable. tune it to your needs.\n\nChanges from minGPT:\n- I removed the from_pretrained function where we init with GPT2 weights\n- I removed dropout layers because the models we train here are small,\n  it's not necessary to understand at this stage and at this scale.\n- I removed weight decay and all of the complexity around what parameters are\n  and are not weight decayed. I don't believe this should make a massive\n  difference at the scale that we operate on here.\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport math\nimport argparse\nfrom dataclasses import dataclass\nfrom typing import List\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\nfrom torch.utils.data import Dataset\nfrom torch.utils.data.dataloader import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\n# -----------------------------------------------------------------------------\n\n@dataclass\nclass ModelConfig:\n    block_size: int = None # length of the input sequences of integers\n    vocab_size: int = None # the input integers are in range [0 .. vocab_size -1]\n    # parameters below control the sizes of each model slightly differently\n    n_layer: int = 4\n    n_embd: int = 64\n    n_embd2: int = 64\n    n_head: int = 4\n\n# -----------------------------------------------------------------------------\n# Transformer Language Model (*exactly* as used in GPT-2)\n\nclass NewGELU(nn.Module):\n    \"\"\"\n    Implementation of the GELU activation function currently in Google BERT repo (identical to OpenAI GPT).\n    Reference: Gaussian Error Linear Units (GELU) paper: https://arxiv.org/abs/1606.08415\n    \"\"\"\n    def forward(self, x):\n        return 0.5 * x * (1.0 + torch.tanh(math.sqrt(2.0 / math.pi) * (x + 0.044715 * torch.pow(x, 3.0))))\n\nclass CausalSelfAttention(nn.Module):\n    \"\"\"\n    A vanilla multi-head masked self-attention layer with a projection at the end.\n    It is possible to use torch.nn.MultiheadAttention here but I am including an\n    explicit implementation here to show that there is nothing too scary here.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.n_embd % config.n_head == 0\n        # key, query, value projections for all heads, but in a batch\n        self.c_attn = nn.Linear(config.n_embd, 3 * config.n_embd)\n        # output projection\n        self.c_proj = nn.Linear(config.n_embd, config.n_embd)\n        # causal mask to ensure that attention is only applied to the left in the input sequence\n        self.register_buffer(\"bias\", torch.tril(torch.ones(config.block_size, config.block_size))\n                                     .view(1, 1, config.block_size, config.block_size))\n        self.n_head = config.n_head\n        self.n_embd = config.n_embd\n\n    def forward(self, x):\n        B, T, C = x.size() # batch size, sequence length, embedding dimensionality (n_embd)\n\n        # calculate query, key, values for all heads in batch and move head forward to be the batch dim\n        q, k ,v  = self.c_attn(x).split(self.n_embd, dim=2)\n        k = k.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        q = q.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        v = v.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n\n        # causal self-attention; Self-attend: (B, nh, T, hs) x (B, nh, hs, T) -> (B, nh, T, T)\n        att = (q @ k.transpose(-2, -1)) * (1.0 / math.sqrt(k.size(-1)))\n        att = att.masked_fill(self.bias[:,:,:T,:T] == 0, float('-inf'))\n        att = F.softmax(att, dim=-1)\n        y = att @ v # (B, nh, T, T) x (B, nh, T, hs) -> (B, nh, T, hs)\n        y = y.transpose(1, 2).contiguous().view(B, T, C) # re-assemble all head outputs side by side\n\n        # output projection\n        y = self.c_proj(y)\n        return y\n\nclass Block(nn.Module):\n    \"\"\" an unassuming Transformer block \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.ln_1 = nn.LayerNorm(config.n_embd)\n        self.attn = CausalSelfAttention(config)\n        self.ln_2 = nn.LayerNorm(config.n_embd)\n        self.mlp = nn.ModuleDict(dict(\n            c_fc    = nn.Linear(config.n_embd, 4 * config.n_embd),\n            c_proj  = nn.Linear(4 * config.n_embd, config.n_embd),\n            act     = NewGELU(),\n        ))\n        m = self.mlp\n        self.mlpf = lambda x: m.c_proj(m.act(m.c_fc(x))) # MLP forward\n\n    def forward(self, x):\n        x = x + self.attn(self.ln_1(x))\n        x = x + self.mlpf(self.ln_2(x))\n        return x\n\nclass GPT(nn.Module):\n    \"\"\" GPT Language Model \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.block_size = config.block_size\n\n        self.transformer = nn.ModuleDict(dict(\n            wte = nn.Embedding(config.vocab_size, config.n_embd),\n            wpe = nn.Embedding(config.block_size, config.n_embd),\n            h = nn.ModuleList([Block(config) for _ in range(config.n_layer)]),\n            ln_f = nn.LayerNorm(config.n_embd),\n        ))\n        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n\n        # report number of parameters (note we don't count the decoder parameters in lm_head)\n        n_params = sum(p.numel() for p in self.transformer.parameters())\n        print(\"number of parameters: %.2fM\" % (n_params/1e6,))\n\n    def get_block_size(self):\n        return self.block_size\n\n    def forward(self, idx, targets=None):\n        device = idx.device\n        b, t = idx.size()\n        assert t <= self.block_size, f\"Cannot forward sequence of length {t}, block size is only {self.block_size}\"\n        pos = torch.arange(0, t, dtype=torch.long, device=device).unsqueeze(0) # shape (1, t)\n\n        # forward the GPT model itself\n        tok_emb = self.transformer.wte(idx) # token embeddings of shape (b, t, n_embd)\n        pos_emb = self.transformer.wpe(pos) # position embeddings of shape (1, t, n_embd)\n        x = tok_emb + pos_emb\n        for block in self.transformer.h:\n            x = block(x)\n        x = self.transformer.ln_f(x)\n        logits = self.lm_head(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n# MLP language model\n\nclass MLP(nn.Module):\n    \"\"\"\n    takes the previous block_size tokens, encodes them with a lookup table,\n    concatenates the vectors and predicts the next token with an MLP.\n\n    Reference:\n    Bengio et al. 2003 https://www.jmlr.org/papers/volume3/bengio03a/bengio03a.pdf\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.block_size = config.block_size\n        self.vocab_size = config.vocab_size\n        self.wte = nn.Embedding(config.vocab_size + 1, config.n_embd) # token embeddings table\n        # +1 in the line above for a special <BLANK> token that gets inserted if encoding a token\n        # before the beginning of the input sequence\n        self.mlp = nn.Sequential(\n            nn.Linear(self.block_size * config.n_embd, config.n_embd2), # TODO: option to vary this\n            nn.Tanh(),\n            nn.Linear(config.n_embd2, self.vocab_size)\n        )\n\n    def get_block_size(self):\n        return self.block_size\n\n    def forward(self, idx, targets=None):\n\n        # gather the word embeddings of the previous 3 words\n        embs = []\n        for k in range(self.block_size):\n            tok_emb = self.wte(idx) # token embeddings of shape (b, t, n_embd)\n            idx = torch.roll(idx, 1, 1)\n            idx[:, 0] = self.vocab_size # special <BLANK> token\n            embs.append(tok_emb)\n\n        # concat all of the embeddings together and pass through an MLP\n        x = torch.cat(embs, -1) # (b, t, n_embd * block_size)\n        logits = self.mlp(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n# Bigram language model\n\nclass Bigram(nn.Module):\n    \"\"\"\n    Bigram Language Model 'neural net', simply a lookup table of logits for the\n    next character given a previous character.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        n = config.vocab_size\n        self.logits = nn.Parameter(torch.zeros((n, n)))\n\n    def get_block_size(self):\n        return 1 # this model only needs one previous character to predict the next\n\n    def forward(self, idx, targets=None):\n\n         # 'forward pass', lol\n        logits = self.logits[idx]\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n# helper functions for evaluating and sampling from the model\n\n@torch.no_grad()\ndef generate(model, idx, max_new_tokens, temperature=1.0, do_sample=False, top_k=None):\n    \"\"\"\n    Take a conditioning sequence of indices idx (LongTensor of shape (b,t)) and complete\n    the sequence max_new_tokens times, feeding the predictions back into the model each time.\n    Most likely you'll want to make sure to be in model.eval() mode of operation for this.\n    \"\"\"\n    block_size = model.get_block_size()\n    for _ in range(max_new_tokens):\n        # if the sequence context is growing too long we must crop it at block_size\n        idx_cond = idx if idx.size(1) <= block_size else idx[:, -block_size:]\n        # forward the model to get the logits for the index in the sequence\n        logits, _ = model(idx_cond)\n        # pluck the logits at the final step and scale by desired temperature\n        logits = logits[:, -1, :] / temperature\n        # optionally crop the logits to only the top k options\n        if top_k is not None:\n            v, _ = torch.topk(logits, top_k)\n            logits[logits < v[:, [-1]]] = -float('Inf')\n        # apply softmax to convert logits to (normalized) probabilities\n        probs = F.softmax(logits, dim=-1)\n        # either sample from the distribution or take the most likely element\n        if do_sample:\n            idx_next = torch.multinomial(probs, num_samples=1)\n        else:\n            _, idx_next = torch.topk(probs, k=1, dim=-1)\n        # append sampled index to the running sequence and continue\n        idx = torch.cat((idx, idx_next), dim=1)\n\n    return idx\n\ndef print_samples(num=10):\n    \"\"\" samples from the model and pretty prints the decoded samples \"\"\"\n    X_init = torch.zeros(num, 1, dtype=torch.long).to(args.device)\n    top_k = args.top_k if args.top_k != -1 else None\n    steps = train_dataset.get_output_length() - 1 # -1 because we already start with <START> token (index 0)\n    X_samp = generate(model, X_init, steps, top_k=top_k, do_sample=True).to('cpu')\n    train_samples, test_samples, new_samples = [], [], []\n    for i in range(X_samp.size(0)):\n        # get the i'th row of sampled integers, as python list\n        row = X_samp[i, 1:].tolist() # note: we need to crop out the first <START> token\n        # token 0 is the <STOP> token, so we crop the output sequence at that point\n        crop_index = row.index(0) if 0 in row else len(row)\n        row = row[:crop_index]\n        word_samp = train_dataset.decode(row)\n        # separately track samples that we have and have not seen before\n        if train_dataset.contains(word_samp):\n            train_samples.append(word_samp)\n        elif test_dataset.contains(word_samp):\n            test_samples.append(word_samp)\n        else:\n            new_samples.append(word_samp)\n    print('-'*80)\n    for lst, desc in [(train_samples, 'in train'), (test_samples, 'in test'), (new_samples, 'new')]:\n        print(f\"{len(lst)} samples that are {desc}:\")\n        for word in lst:\n            print(word)\n    print('-'*80)\n\n@torch.inference_mode()\ndef evaluate(model, dataset, batch_size=50, max_batches=None):\n    model.eval()\n    loader = DataLoader(dataset, shuffle=True, batch_size=batch_size, num_workers=0)\n    losses = []\n    for i, batch in enumerate(loader):\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n        logits, loss = model(X, Y)\n        losses.append(loss.item())\n        if max_batches is not None and i >= max_batches:\n            break\n    mean_loss = torch.tensor(losses).mean().item()\n    model.train() # reset model back to training mode\n    return mean_loss\n\n# -----------------------------------------------------------------------------\n# helper functions for creating the training and test Datasets that emit words\n\nclass CharDataset(Dataset):\n\n    def __init__(self, words, chars, max_word_length):\n        self.words = words\n        self.chars = chars\n        self.max_word_length = max_word_length\n        self.stoi = {ch:i+1 for i,ch in enumerate(chars)}\n        self.itos = {i:s for s,i in self.stoi.items()} # inverse mapping\n\n    def __len__(self):\n        return len(self.words)\n\n    def contains(self, word):\n        return word in self.words\n\n    def get_vocab_size(self):\n        return len(self.chars) + 1 # all the possible characters and special 0 token\n\n    def get_output_length(self):\n        return self.max_word_length + 1 # <START> token followed by words\n\n    def encode(self, word):\n        ix = torch.tensor([self.stoi[w] for w in word], dtype=torch.long)\n        return ix\n\n    def decode(self, ix):\n        word = ''.join(self.itos[i] for i in ix)\n        return word\n\n    def __getitem__(self, idx):\n        word = self.words[idx]\n        ix = self.encode(word)\n        x = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        y = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        x[1:1+len(ix)] = ix\n        y[:len(ix)] = ix\n        y[len(ix)+1:] = -1 # index -1 will mask the loss at the inactive locations\n        return x, y\n\ndef create_datasets(input_file):\n\n    # preprocessing of the input text file\n    with open(input_file, 'r') as f:\n        data = f.read()\n    words = data.splitlines()\n    words = [w.strip() for w in words] # get rid of any leading or trailing white space\n    words = [w for w in words if w] # get rid of any empty strings\n    chars = sorted(list(set(''.join(words)))) # all the possible characters\n    max_word_length = max(len(w) for w in words)\n    print(f\"number of examples in the dataset: {len(words)}\")\n    print(f\"max word length: {max_word_length}\")\n    print(f\"number of unique characters in the vocabulary: {len(chars)}\")\n    print(\"vocabulary:\")\n    print(''.join(chars))\n\n    # partition the input data into a training and the test set\n    test_set_size = min(1000, int(len(words) * 0.1)) # 10% of the training set, or up to 1000 examples\n    rp = torch.randperm(len(words)).tolist()\n    train_words = [words[i] for i in rp[:-test_set_size]]\n    test_words = [words[i] for i in rp[-test_set_size:]]\n    print(f\"split up the dataset into {len(train_words)} training examples and {len(test_words)} test examples\")\n\n    # wrap in dataset objects\n    train_dataset = CharDataset(train_words, chars, max_word_length)\n    test_dataset = CharDataset(test_words, chars, max_word_length)\n\n    return train_dataset, test_dataset\n\nclass InfiniteDataLoader:\n    \"\"\"\n    this is really hacky and I'm not proud of it, but there doesn't seem to be\n    a better way in PyTorch to just create an infinite dataloader?\n    \"\"\"\n\n    def __init__(self, dataset, **kwargs):\n        train_sampler = torch.utils.data.RandomSampler(dataset, replacement=True, num_samples=int(1e10))\n        self.train_loader = DataLoader(dataset, sampler=train_sampler, **kwargs)\n        self.data_iter = iter(self.train_loader)\n\n    def next(self):\n        try:\n            batch = next(self.data_iter)\n        except StopIteration: # this will technically only happen after 1e10 samples... (i.e. basically never)\n            self.data_iter = iter(self.train_loader)\n            batch = next(self.data_iter)\n        return batch\n\n# -----------------------------------------------------------------------------\nif __name__ == '__main__':\n\n    # parse command line args\n    parser = argparse.ArgumentParser(description=\"Make More\")\n    # system/input/output\n    parser.add_argument('--input-file', '-i', type=str, default='names.txt', help=\"input file with things one per line\")\n    parser.add_argument('--work-dir', '-o', type=str, default='out', help=\"output working directory\")\n    parser.add_argument('--resume', action='store_true', help=\"when this flag is used, we will resume optimization from existing model in the workdir\")\n    parser.add_argument('--sample-only', action='store_true', help=\"just sample from the model and quit, don't train\")\n    parser.add_argument('--num-workers', '-n', type=int, default=4, help=\"number of data workers for both train/test\")\n    parser.add_argument('--max-steps', type=int, default=-1, help=\"max number of optimization steps to run for, or -1 for infinite.\")\n    parser.add_argument('--device', type=str, default='cpu', help=\"device to use for compute, examples: cpu|cuda|cuda:2|mps\")\n    parser.add_argument('--seed', type=int, default=3407, help=\"seed\")\n    # sampling\n    parser.add_argument('--top-k', type=int, default=-1, help=\"top-k for sampling, -1 means no top-k\")\n    # model\n    parser.add_argument('--type', type=str, default='bigram', help=\"model class type to use, bigram|mlp|transformer\")\n    parser.add_argument('--n-layer', type=int, default=4, help=\"number of layers\")\n    parser.add_argument('--n-head', type=int, default=4, help=\"number of heads (in a transformer)\")\n    parser.add_argument('--n-embd', type=int, default=64, help=\"number of feature channels in the model\")\n    parser.add_argument('--n-embd2', type=int, default=64, help=\"number of feature channels elsewhere in the model\")\n    # optimization\n    parser.add_argument('--batch-size', '-b', type=int, default=32, help=\"batch size during optimization\")\n    parser.add_argument('--learning-rate', '-l', type=float, default=5e-4, help=\"learning rate\")\n    parser.add_argument('--weight-decay', '-w', type=float, default=0.01, help=\"weight decay\")\n    args = parser.parse_args()\n    print(vars(args))\n\n    # system inits\n    torch.manual_seed(args.seed)\n    torch.cuda.manual_seed_all(args.seed)\n    os.makedirs(args.work_dir, exist_ok=True)\n    writer = SummaryWriter(log_dir=args.work_dir)\n\n    # init datasets\n    train_dataset, test_dataset = create_datasets(args.input_file)\n    vocab_size = train_dataset.get_vocab_size()\n    block_size = train_dataset.get_output_length()\n    print(f\"dataset determined that: {vocab_size=}, {block_size=}\")\n\n    # init model\n    config = ModelConfig(vocab_size=vocab_size, block_size=block_size,\n                       n_layer=args.n_layer, n_head=args.n_head,\n                       n_embd=args.n_embd, n_embd2=args.n_embd2)\n    model = {\n        'transformer': GPT,\n        'bigram': Bigram,\n        'mlp': MLP,\n    }[args.type](config)\n    model.to(args.device)\n    print(f\"model #params: {sum(p.numel() for p in model.parameters())}\")\n    if args.resume or args.sample_only: # note: if we sample-only then we also assume we are resuming\n        print(\"resuming from existing model in the workdir\")\n        model.load_state_dict(torch.load(os.path.join(args.work_dir, 'model.pt')))\n    if args.sample_only:\n        print_samples(num=50)\n        sys.exit()\n\n    # init optimizer\n    optimizer = torch.optim.AdamW(model.parameters(), lr=args.learning_rate, weight_decay=args.weight_decay, betas=(0.9, 0.99), eps=1e-8)\n\n    # init dataloader\n    batch_loader = InfiniteDataLoader(train_dataset, batch_size=args.batch_size, pin_memory=True, num_workers=args.num_workers)\n\n    # training loop\n    best_loss = None\n    step = 0\n    while True:\n\n        t0 = time.time()\n\n        # get the next batch, ship to device, and unpack it to input and target\n        batch = batch_loader.next()\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n\n        # feed into the model\n        logits, loss = model(X, Y)\n\n        # calculate the gradient, update the weights\n        model.zero_grad(set_to_none=True)\n        loss.backward()\n        optimizer.step()\n\n        # wait for all CUDA work on the GPU to finish then calculate iteration time taken\n        if args.device.startswith('cuda'):\n            torch.cuda.synchronize()\n        t1 = time.time()\n\n        # logging\n        if step % 10 == 0:\n            print(f\"step {step} | loss {loss.item():.4f} | step time {(t1-t0)*1000:.2f}ms\")\n\n        # evaluate the model\n        if step > 0 and step % 500 == 0:\n            train_loss = evaluate(model, train_dataset, batch_size=100, max_batches=10)\n            test_loss  = evaluate(model, test_dataset,  batch_size=100, max_batches=10)\n            writer.add_scalar(\"Loss/train\", train_loss, step)\n            writer.add_scalar(\"Loss/test\", test_loss, step)\n            writer.flush()\n            print(f\"step {step} train loss: {train_loss} test loss: {test_loss}\")\n            # save the model to disk if it has improved\n            if best_loss is None or test_loss < best_loss:\n                out_path = os.path.join(args.work_dir, \"model.pt\")\n                print(f\"test loss {test_loss} is the best so far, saving model to {out_path}\")\n                torch.save(model.state_dict(), out_path)\n                best_loss = test_loss\n\n        # sample from the model\n        if step > 0 and step % 200 == 0:\n            print_samples(num=10)\n\n        step += 1\n        # termination conditions\n        if args.max_steps >= 0 and step >= args.max_steps:\n            break\n\n", "previous_id": "6694b67d37ef0420a7d503ee5c126ea512014b70", "new_code_file": "\"\"\"\nyou give this script some words (one per line) and it will generate more things like it.\nuses super state of the art Transformer AI tech\nthis code is intended to be super hackable. tune it to your needs.\n\nChanges from minGPT:\n- I removed the from_pretrained function where we init with GPT2 weights\n- I removed dropout layers because the models we train here are small,\n  it's not necessary to understand at this stage and at this scale.\n- I removed weight decay and all of the complexity around what parameters are\n  and are not weight decayed. I don't believe this should make a massive\n  difference at the scale that we operate on here.\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport math\nimport argparse\nfrom dataclasses import dataclass\nfrom typing import List\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\nfrom torch.utils.data import Dataset\nfrom torch.utils.data.dataloader import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\n# -----------------------------------------------------------------------------\n\n@dataclass\nclass ModelConfig:\n    block_size: int = None # length of the input sequences of integers\n    vocab_size: int = None # the input integers are in range [0 .. vocab_size -1]\n    # parameters below control the sizes of each model slightly differently\n    n_layer: int = 4\n    n_embd: int = 64\n    n_embd2: int = 64\n    n_head: int = 4\n\n# -----------------------------------------------------------------------------\n# Transformer Language Model (*exactly* as used in GPT-2)\n\nclass NewGELU(nn.Module):\n    \"\"\"\n    Implementation of the GELU activation function currently in Google BERT repo (identical to OpenAI GPT).\n    Reference: Gaussian Error Linear Units (GELU) paper: https://arxiv.org/abs/1606.08415\n    \"\"\"\n    def forward(self, x):\n        return 0.5 * x * (1.0 + torch.tanh(math.sqrt(2.0 / math.pi) * (x + 0.044715 * torch.pow(x, 3.0))))\n\nclass CausalSelfAttention(nn.Module):\n    \"\"\"\n    A vanilla multi-head masked self-attention layer with a projection at the end.\n    It is possible to use torch.nn.MultiheadAttention here but I am including an\n    explicit implementation here to show that there is nothing too scary here.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.n_embd % config.n_head == 0\n        # key, query, value projections for all heads, but in a batch\n        self.c_attn = nn.Linear(config.n_embd, 3 * config.n_embd)\n        # output projection\n        self.c_proj = nn.Linear(config.n_embd, config.n_embd)\n        # causal mask to ensure that attention is only applied to the left in the input sequence\n        self.register_buffer(\"bias\", torch.tril(torch.ones(config.block_size, config.block_size))\n                                     .view(1, 1, config.block_size, config.block_size))\n        self.n_head = config.n_head\n        self.n_embd = config.n_embd\n\n    def forward(self, x):\n        B, T, C = x.size() # batch size, sequence length, embedding dimensionality (n_embd)\n\n        # calculate query, key, values for all heads in batch and move head forward to be the batch dim\n        q, k ,v  = self.c_attn(x).split(self.n_embd, dim=2)\n        k = k.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        q = q.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        v = v.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n\n        # causal self-attention; Self-attend: (B, nh, T, hs) x (B, nh, hs, T) -> (B, nh, T, T)\n        att = (q @ k.transpose(-2, -1)) * (1.0 / math.sqrt(k.size(-1)))\n        att = att.masked_fill(self.bias[:,:,:T,:T] == 0, float('-inf'))\n        att = F.softmax(att, dim=-1)\n        y = att @ v # (B, nh, T, T) x (B, nh, T, hs) -> (B, nh, T, hs)\n        y = y.transpose(1, 2).contiguous().view(B, T, C) # re-assemble all head outputs side by side\n\n        # output projection\n        y = self.c_proj(y)\n        return y\n\nclass Block(nn.Module):\n    \"\"\" an unassuming Transformer block \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.ln_1 = nn.LayerNorm(config.n_embd)\n        self.attn = CausalSelfAttention(config)\n        self.ln_2 = nn.LayerNorm(config.n_embd)\n        self.mlp = nn.ModuleDict(dict(\n            c_fc    = nn.Linear(config.n_embd, 4 * config.n_embd),\n            c_proj  = nn.Linear(4 * config.n_embd, config.n_embd),\n            act     = NewGELU(),\n        ))\n        m = self.mlp\n        self.mlpf = lambda x: m.c_proj(m.act(m.c_fc(x))) # MLP forward\n\n    def forward(self, x):\n        x = x + self.attn(self.ln_1(x))\n        x = x + self.mlpf(self.ln_2(x))\n        return x\n\nclass Transformer(nn.Module):\n    \"\"\" Transformer Language Model, exactly as seen in GPT-2 \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.block_size = config.block_size\n\n        self.transformer = nn.ModuleDict(dict(\n            wte = nn.Embedding(config.vocab_size, config.n_embd),\n            wpe = nn.Embedding(config.block_size, config.n_embd),\n            h = nn.ModuleList([Block(config) for _ in range(config.n_layer)]),\n            ln_f = nn.LayerNorm(config.n_embd),\n        ))\n        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n\n        # report number of parameters (note we don't count the decoder parameters in lm_head)\n        n_params = sum(p.numel() for p in self.transformer.parameters())\n        print(\"number of parameters: %.2fM\" % (n_params/1e6,))\n\n    def get_block_size(self):\n        return self.block_size\n\n    def forward(self, idx, targets=None):\n        device = idx.device\n        b, t = idx.size()\n        assert t <= self.block_size, f\"Cannot forward sequence of length {t}, block size is only {self.block_size}\"\n        pos = torch.arange(0, t, dtype=torch.long, device=device).unsqueeze(0) # shape (1, t)\n\n        # forward the GPT model itself\n        tok_emb = self.transformer.wte(idx) # token embeddings of shape (b, t, n_embd)\n        pos_emb = self.transformer.wpe(pos) # position embeddings of shape (1, t, n_embd)\n        x = tok_emb + pos_emb\n        for block in self.transformer.h:\n            x = block(x)\n        x = self.transformer.ln_f(x)\n        logits = self.lm_head(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n\"\"\"\nRecurrent Neural Net language model: either a vanilla RNN recurrence or a GRU.\nDid not implement an LSTM because its API is a bit more annoying as it has\nboth a hidden state and a cell state, but it's very similar to GRU and in\npractice works just as well.\n\"\"\"\n\nclass RNNCell(nn.Module):\n    \"\"\"\n    the job of a 'Cell' is to:\n    take input at current time step x_{t} and the hidden state at the\n    previous time step h_{t-1} and return the resulting hidden state\n    h_{t} at the current timestep\n    \"\"\"\n    def __init__(self, config):\n        super().__init__()\n        self.xh_to_h = nn.Linear(config.n_embd + config.n_embd2, config.n_embd2)\n\n    def forward(self, xt, hprev):\n        xh = torch.cat([xt, hprev], dim=1)\n        ht = F.tanh(self.xh_to_h(xh))\n        return ht\n\nclass GRUCell(nn.Module):\n    \"\"\"\n    same job as RNN cell, but a bit more complicated recurrence formula\n    that makes the GRU more expressive and easier to optimize.\n    \"\"\"\n    def __init__(self, config):\n        super().__init__()\n        # input, forget, output, gate\n        self.xh_to_z = nn.Linear(config.n_embd + config.n_embd2, config.n_embd2)\n        self.xh_to_r = nn.Linear(config.n_embd + config.n_embd2, config.n_embd2)\n        self.xh_to_hbar = nn.Linear(config.n_embd + config.n_embd2, config.n_embd2)\n\n    def forward(self, xt, hprev):\n        # first use the reset gate to wipe some channels of the hidden state to zero\n        xh = torch.cat([xt, hprev], dim=1)\n        r = F.sigmoid(self.xh_to_r(xh))\n        hprev_reset = r * hprev\n        # calculate the candidate new hidden state hbar\n        xhr = torch.cat([xt, hprev_reset], dim=1)\n        hbar = F.tanh(self.xh_to_hbar(xhr))\n        # calculate the switch gate that determines if each channel should be updated at all\n        z = F.sigmoid(self.xh_to_z(xh))\n        # blend the previous hidden state and the new candidate hidden state\n        ht = (1 - z) * hprev + z * hbar\n        return ht\n\nclass RNN(nn.Module):\n\n    def __init__(self, config, cell_type):\n        super().__init__()\n        self.block_size = config.block_size\n        self.vocab_size = config.vocab_size\n        self.start = nn.Parameter(torch.zeros(1, config.n_embd2)) # the starting hidden state\n        self.wte = nn.Embedding(config.vocab_size, config.n_embd) # token embeddings table\n        if cell_type == 'rnn':\n            self.cell = RNNCell(config)\n        elif cell_type == 'gru':\n            self.cell = GRUCell(config)\n        self.lm_head = nn.Linear(config.n_embd2, self.vocab_size)\n\n    def get_block_size(self):\n        return self.block_size\n\n    def forward(self, idx, targets=None):\n        device = idx.device\n        b, t = idx.size()\n\n        # embed all the integers up front and all at once for efficiency\n        emb = self.wte(idx) # (b, t, n_embd)\n\n        # sequentially iterate over the inputs and update the RNN state each tick\n        hprev = self.start.expand((b, -1)) # expand out the batch dimension\n        hiddens = []\n        for i in range(t):\n            xt = emb[:, i, :] # (b, n_embd)\n            ht = self.cell(xt, hprev) # (b, n_embd2)\n            hiddens.append(ht)\n\n        # decode the outputs\n        hidden = torch.stack(hiddens, 1) # (b, t, n_embd2)\n        logits = self.lm_head(hidden)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n# MLP language model\n\nclass MLP(nn.Module):\n    \"\"\"\n    takes the previous block_size tokens, encodes them with a lookup table,\n    concatenates the vectors and predicts the next token with an MLP.\n\n    Reference:\n    Bengio et al. 2003 https://www.jmlr.org/papers/volume3/bengio03a/bengio03a.pdf\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.block_size = config.block_size\n        self.vocab_size = config.vocab_size\n        self.wte = nn.Embedding(config.vocab_size + 1, config.n_embd) # token embeddings table\n        # +1 in the line above for a special <BLANK> token that gets inserted if encoding a token\n        # before the beginning of the input sequence\n        self.mlp = nn.Sequential(\n            nn.Linear(self.block_size * config.n_embd, config.n_embd2), # TODO: option to vary this\n            nn.Tanh(),\n            nn.Linear(config.n_embd2, self.vocab_size)\n        )\n\n    def get_block_size(self):\n        return self.block_size\n\n    def forward(self, idx, targets=None):\n\n        # gather the word embeddings of the previous 3 words\n        embs = []\n        for k in range(self.block_size):\n            tok_emb = self.wte(idx) # token embeddings of shape (b, t, n_embd)\n            idx = torch.roll(idx, 1, 1)\n            idx[:, 0] = self.vocab_size # special <BLANK> token\n            embs.append(tok_emb)\n\n        # concat all of the embeddings together and pass through an MLP\n        x = torch.cat(embs, -1) # (b, t, n_embd * block_size)\n        logits = self.mlp(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n# Bigram language model\n\nclass Bigram(nn.Module):\n    \"\"\"\n    Bigram Language Model 'neural net', simply a lookup table of logits for the\n    next character given a previous character.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        n = config.vocab_size\n        self.logits = nn.Parameter(torch.zeros((n, n)))\n\n    def get_block_size(self):\n        return 1 # this model only needs one previous character to predict the next\n\n    def forward(self, idx, targets=None):\n\n         # 'forward pass', lol\n        logits = self.logits[idx]\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n# helper functions for evaluating and sampling from the model\n\n@torch.no_grad()\ndef generate(model, idx, max_new_tokens, temperature=1.0, do_sample=False, top_k=None):\n    \"\"\"\n    Take a conditioning sequence of indices idx (LongTensor of shape (b,t)) and complete\n    the sequence max_new_tokens times, feeding the predictions back into the model each time.\n    Most likely you'll want to make sure to be in model.eval() mode of operation for this.\n    \"\"\"\n    block_size = model.get_block_size()\n    for _ in range(max_new_tokens):\n        # if the sequence context is growing too long we must crop it at block_size\n        idx_cond = idx if idx.size(1) <= block_size else idx[:, -block_size:]\n        # forward the model to get the logits for the index in the sequence\n        logits, _ = model(idx_cond)\n        # pluck the logits at the final step and scale by desired temperature\n        logits = logits[:, -1, :] / temperature\n        # optionally crop the logits to only the top k options\n        if top_k is not None:\n            v, _ = torch.topk(logits, top_k)\n            logits[logits < v[:, [-1]]] = -float('Inf')\n        # apply softmax to convert logits to (normalized) probabilities\n        probs = F.softmax(logits, dim=-1)\n        # either sample from the distribution or take the most likely element\n        if do_sample:\n            idx_next = torch.multinomial(probs, num_samples=1)\n        else:\n            _, idx_next = torch.topk(probs, k=1, dim=-1)\n        # append sampled index to the running sequence and continue\n        idx = torch.cat((idx, idx_next), dim=1)\n\n    return idx\n\ndef print_samples(num=10):\n    \"\"\" samples from the model and pretty prints the decoded samples \"\"\"\n    X_init = torch.zeros(num, 1, dtype=torch.long).to(args.device)\n    top_k = args.top_k if args.top_k != -1 else None\n    steps = train_dataset.get_output_length() - 1 # -1 because we already start with <START> token (index 0)\n    X_samp = generate(model, X_init, steps, top_k=top_k, do_sample=True).to('cpu')\n    train_samples, test_samples, new_samples = [], [], []\n    for i in range(X_samp.size(0)):\n        # get the i'th row of sampled integers, as python list\n        row = X_samp[i, 1:].tolist() # note: we need to crop out the first <START> token\n        # token 0 is the <STOP> token, so we crop the output sequence at that point\n        crop_index = row.index(0) if 0 in row else len(row)\n        row = row[:crop_index]\n        word_samp = train_dataset.decode(row)\n        # separately track samples that we have and have not seen before\n        if train_dataset.contains(word_samp):\n            train_samples.append(word_samp)\n        elif test_dataset.contains(word_samp):\n            test_samples.append(word_samp)\n        else:\n            new_samples.append(word_samp)\n    print('-'*80)\n    for lst, desc in [(train_samples, 'in train'), (test_samples, 'in test'), (new_samples, 'new')]:\n        print(f\"{len(lst)} samples that are {desc}:\")\n        for word in lst:\n            print(word)\n    print('-'*80)\n\n@torch.inference_mode()\ndef evaluate(model, dataset, batch_size=50, max_batches=None):\n    model.eval()\n    loader = DataLoader(dataset, shuffle=True, batch_size=batch_size, num_workers=0)\n    losses = []\n    for i, batch in enumerate(loader):\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n        logits, loss = model(X, Y)\n        losses.append(loss.item())\n        if max_batches is not None and i >= max_batches:\n            break\n    mean_loss = torch.tensor(losses).mean().item()\n    model.train() # reset model back to training mode\n    return mean_loss\n\n# -----------------------------------------------------------------------------\n# helper functions for creating the training and test Datasets that emit words\n\nclass CharDataset(Dataset):\n\n    def __init__(self, words, chars, max_word_length):\n        self.words = words\n        self.chars = chars\n        self.max_word_length = max_word_length\n        self.stoi = {ch:i+1 for i,ch in enumerate(chars)}\n        self.itos = {i:s for s,i in self.stoi.items()} # inverse mapping\n\n    def __len__(self):\n        return len(self.words)\n\n    def contains(self, word):\n        return word in self.words\n\n    def get_vocab_size(self):\n        return len(self.chars) + 1 # all the possible characters and special 0 token\n\n    def get_output_length(self):\n        return self.max_word_length + 1 # <START> token followed by words\n\n    def encode(self, word):\n        ix = torch.tensor([self.stoi[w] for w in word], dtype=torch.long)\n        return ix\n\n    def decode(self, ix):\n        word = ''.join(self.itos[i] for i in ix)\n        return word\n\n    def __getitem__(self, idx):\n        word = self.words[idx]\n        ix = self.encode(word)\n        x = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        y = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        x[1:1+len(ix)] = ix\n        y[:len(ix)] = ix\n        y[len(ix)+1:] = -1 # index -1 will mask the loss at the inactive locations\n        return x, y\n\ndef create_datasets(input_file):\n\n    # preprocessing of the input text file\n    with open(input_file, 'r') as f:\n        data = f.read()\n    words = data.splitlines()\n    words = [w.strip() for w in words] # get rid of any leading or trailing white space\n    words = [w for w in words if w] # get rid of any empty strings\n    chars = sorted(list(set(''.join(words)))) # all the possible characters\n    max_word_length = max(len(w) for w in words)\n    print(f\"number of examples in the dataset: {len(words)}\")\n    print(f\"max word length: {max_word_length}\")\n    print(f\"number of unique characters in the vocabulary: {len(chars)}\")\n    print(\"vocabulary:\")\n    print(''.join(chars))\n\n    # partition the input data into a training and the test set\n    test_set_size = min(1000, int(len(words) * 0.1)) # 10% of the training set, or up to 1000 examples\n    rp = torch.randperm(len(words)).tolist()\n    train_words = [words[i] for i in rp[:-test_set_size]]\n    test_words = [words[i] for i in rp[-test_set_size:]]\n    print(f\"split up the dataset into {len(train_words)} training examples and {len(test_words)} test examples\")\n\n    # wrap in dataset objects\n    train_dataset = CharDataset(train_words, chars, max_word_length)\n    test_dataset = CharDataset(test_words, chars, max_word_length)\n\n    return train_dataset, test_dataset\n\nclass InfiniteDataLoader:\n    \"\"\"\n    this is really hacky and I'm not proud of it, but there doesn't seem to be\n    a better way in PyTorch to just create an infinite dataloader?\n    \"\"\"\n\n    def __init__(self, dataset, **kwargs):\n        train_sampler = torch.utils.data.RandomSampler(dataset, replacement=True, num_samples=int(1e10))\n        self.train_loader = DataLoader(dataset, sampler=train_sampler, **kwargs)\n        self.data_iter = iter(self.train_loader)\n\n    def next(self):\n        try:\n            batch = next(self.data_iter)\n        except StopIteration: # this will technically only happen after 1e10 samples... (i.e. basically never)\n            self.data_iter = iter(self.train_loader)\n            batch = next(self.data_iter)\n        return batch\n\n# -----------------------------------------------------------------------------\nif __name__ == '__main__':\n\n    # parse command line args\n    parser = argparse.ArgumentParser(description=\"Make More\")\n    # system/input/output\n    parser.add_argument('--input-file', '-i', type=str, default='names.txt', help=\"input file with things one per line\")\n    parser.add_argument('--work-dir', '-o', type=str, default='out', help=\"output working directory\")\n    parser.add_argument('--resume', action='store_true', help=\"when this flag is used, we will resume optimization from existing model in the workdir\")\n    parser.add_argument('--sample-only', action='store_true', help=\"just sample from the model and quit, don't train\")\n    parser.add_argument('--num-workers', '-n', type=int, default=4, help=\"number of data workers for both train/test\")\n    parser.add_argument('--max-steps', type=int, default=-1, help=\"max number of optimization steps to run for, or -1 for infinite.\")\n    parser.add_argument('--device', type=str, default='cpu', help=\"device to use for compute, examples: cpu|cuda|cuda:2|mps\")\n    parser.add_argument('--seed', type=int, default=3407, help=\"seed\")\n    # sampling\n    parser.add_argument('--top-k', type=int, default=-1, help=\"top-k for sampling, -1 means no top-k\")\n    # model\n    parser.add_argument('--type', type=str, default='bigram', help=\"model class type to use, bigram|mlp|rnn|gru|transformer\")\n    parser.add_argument('--n-layer', type=int, default=4, help=\"number of layers\")\n    parser.add_argument('--n-head', type=int, default=4, help=\"number of heads (in a transformer)\")\n    parser.add_argument('--n-embd', type=int, default=64, help=\"number of feature channels in the model\")\n    parser.add_argument('--n-embd2', type=int, default=64, help=\"number of feature channels elsewhere in the model\")\n    # optimization\n    parser.add_argument('--batch-size', '-b', type=int, default=32, help=\"batch size during optimization\")\n    parser.add_argument('--learning-rate', '-l', type=float, default=5e-4, help=\"learning rate\")\n    parser.add_argument('--weight-decay', '-w', type=float, default=0.01, help=\"weight decay\")\n    args = parser.parse_args()\n    print(vars(args))\n\n    # system inits\n    torch.manual_seed(args.seed)\n    torch.cuda.manual_seed_all(args.seed)\n    os.makedirs(args.work_dir, exist_ok=True)\n    writer = SummaryWriter(log_dir=args.work_dir)\n\n    # init datasets\n    train_dataset, test_dataset = create_datasets(args.input_file)\n    vocab_size = train_dataset.get_vocab_size()\n    block_size = train_dataset.get_output_length()\n    print(f\"dataset determined that: {vocab_size=}, {block_size=}\")\n\n    # init model\n    config = ModelConfig(vocab_size=vocab_size, block_size=block_size,\n                       n_layer=args.n_layer, n_head=args.n_head,\n                       n_embd=args.n_embd, n_embd2=args.n_embd2)\n    if args.type == 'transformer':\n        model = Transformer(config)\n    elif args.type == 'bigram':\n        model = Bigram(config)\n    elif args.type == 'mlp':\n        model = MLP(config)\n    elif args.type == 'rnn':\n        model = RNN(config, cell_type='rnn')\n    elif args.type == 'gru':\n        model = RNN(config, cell_type='gru')\n    else:\n        raise ValueError(f'model type {args.type} is not recognized')\n    model.to(args.device)\n    print(f\"model #params: {sum(p.numel() for p in model.parameters())}\")\n    if args.resume or args.sample_only: # note: if we sample-only then we also assume we are resuming\n        print(\"resuming from existing model in the workdir\")\n        model.load_state_dict(torch.load(os.path.join(args.work_dir, 'model.pt')))\n    if args.sample_only:\n        print_samples(num=50)\n        sys.exit()\n\n    # init optimizer\n    optimizer = torch.optim.AdamW(model.parameters(), lr=args.learning_rate, weight_decay=args.weight_decay, betas=(0.9, 0.99), eps=1e-8)\n\n    # init dataloader\n    batch_loader = InfiniteDataLoader(train_dataset, batch_size=args.batch_size, pin_memory=True, num_workers=args.num_workers)\n\n    # training loop\n    best_loss = None\n    step = 0\n    while True:\n\n        t0 = time.time()\n\n        # get the next batch, ship to device, and unpack it to input and target\n        batch = batch_loader.next()\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n\n        # feed into the model\n        logits, loss = model(X, Y)\n\n        # calculate the gradient, update the weights\n        model.zero_grad(set_to_none=True)\n        loss.backward()\n        optimizer.step()\n\n        # wait for all CUDA work on the GPU to finish then calculate iteration time taken\n        if args.device.startswith('cuda'):\n            torch.cuda.synchronize()\n        t1 = time.time()\n\n        # logging\n        if step % 10 == 0:\n            print(f\"step {step} | loss {loss.item():.4f} | step time {(t1-t0)*1000:.2f}ms\")\n\n        # evaluate the model\n        if step > 0 and step % 500 == 0:\n            train_loss = evaluate(model, train_dataset, batch_size=100, max_batches=10)\n            test_loss  = evaluate(model, test_dataset,  batch_size=100, max_batches=10)\n            writer.add_scalar(\"Loss/train\", train_loss, step)\n            writer.add_scalar(\"Loss/test\", test_loss, step)\n            writer.flush()\n            print(f\"step {step} train loss: {train_loss} test loss: {test_loss}\")\n            # save the model to disk if it has improved\n            if best_loss is None or test_loss < best_loss:\n                out_path = os.path.join(args.work_dir, \"model.pt\")\n                print(f\"test loss {test_loss} is the best so far, saving model to {out_path}\")\n                torch.save(model.state_dict(), out_path)\n                best_loss = test_loss\n\n        # sample from the model\n        if step > 0 and step % 200 == 0:\n            print_samples(num=10)\n\n        step += 1\n        # termination conditions\n        if args.max_steps >= 0 and step >= args.max_steps:\n            break\n\n", "diff": "@@ -111,8 +111,8 @@ def forward(self, x):\n         x = x + self.mlpf(self.ln_2(x))\n         return x\n \n-class GPT(nn.Module):\n-    \"\"\" GPT Language Model \"\"\"\n+class Transformer(nn.Module):\n+    \"\"\" Transformer Language Model, exactly as seen in GPT-2 \"\"\"\n \n     def __init__(self, config):\n         super().__init__()\n@@ -155,6 +155,99 @@ def forward(self, idx, targets=None):\n \n         return logits, loss\n \n+# -----------------------------------------------------------------------------\n+\"\"\"\n+Recurrent Neural Net language model: either a vanilla RNN recurrence or a GRU.\n+Did not implement an LSTM because its API is a bit more annoying as it has\n+both a hidden state and a cell state, but it's very similar to GRU and in\n+practice works just as well.\n+\"\"\"\n+\n+class RNNCell(nn.Module):\n+    \"\"\"\n+    the job of a 'Cell' is to:\n+    take input at current time step x_{t} and the hidden state at the\n+    previous time step h_{t-1} and return the resulting hidden state\n+    h_{t} at the current timestep\n+    \"\"\"\n+    def __init__(self, config):\n+        super().__init__()\n+        self.xh_to_h = nn.Linear(config.n_embd + config.n_embd2, config.n_embd2)\n+\n+    def forward(self, xt, hprev):\n+        xh = torch.cat([xt, hprev], dim=1)\n+        ht = F.tanh(self.xh_to_h(xh))\n+        return ht\n+\n+class GRUCell(nn.Module):\n+    \"\"\"\n+    same job as RNN cell, but a bit more complicated recurrence formula\n+    that makes the GRU more expressive and easier to optimize.\n+    \"\"\"\n+    def __init__(self, config):\n+        super().__init__()\n+        # input, forget, output, gate\n+        self.xh_to_z = nn.Linear(config.n_embd + config.n_embd2, config.n_embd2)\n+        self.xh_to_r = nn.Linear(config.n_embd + config.n_embd2, config.n_embd2)\n+        self.xh_to_hbar = nn.Linear(config.n_embd + config.n_embd2, config.n_embd2)\n+\n+    def forward(self, xt, hprev):\n+        # first use the reset gate to wipe some channels of the hidden state to zero\n+        xh = torch.cat([xt, hprev], dim=1)\n+        r = F.sigmoid(self.xh_to_r(xh))\n+        hprev_reset = r * hprev\n+        # calculate the candidate new hidden state hbar\n+        xhr = torch.cat([xt, hprev_reset], dim=1)\n+        hbar = F.tanh(self.xh_to_hbar(xhr))\n+        # calculate the switch gate that determines if each channel should be updated at all\n+        z = F.sigmoid(self.xh_to_z(xh))\n+        # blend the previous hidden state and the new candidate hidden state\n+        ht = (1 - z) * hprev + z * hbar\n+        return ht\n+\n+class RNN(nn.Module):\n+\n+    def __init__(self, config, cell_type):\n+        super().__init__()\n+        self.block_size = config.block_size\n+        self.vocab_size = config.vocab_size\n+        self.start = nn.Parameter(torch.zeros(1, config.n_embd2)) # the starting hidden state\n+        self.wte = nn.Embedding(config.vocab_size, config.n_embd) # token embeddings table\n+        if cell_type == 'rnn':\n+            self.cell = RNNCell(config)\n+        elif cell_type == 'gru':\n+            self.cell = GRUCell(config)\n+        self.lm_head = nn.Linear(config.n_embd2, self.vocab_size)\n+\n+    def get_block_size(self):\n+        return self.block_size\n+\n+    def forward(self, idx, targets=None):\n+        device = idx.device\n+        b, t = idx.size()\n+\n+        # embed all the integers up front and all at once for efficiency\n+        emb = self.wte(idx) # (b, t, n_embd)\n+\n+        # sequentially iterate over the inputs and update the RNN state each tick\n+        hprev = self.start.expand((b, -1)) # expand out the batch dimension\n+        hiddens = []\n+        for i in range(t):\n+            xt = emb[:, i, :] # (b, n_embd)\n+            ht = self.cell(xt, hprev) # (b, n_embd2)\n+            hiddens.append(ht)\n+\n+        # decode the outputs\n+        hidden = torch.stack(hiddens, 1) # (b, t, n_embd2)\n+        logits = self.lm_head(hidden)\n+\n+        # if we are given some desired targets also calculate the loss\n+        loss = None\n+        if targets is not None:\n+            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n+\n+        return logits, loss\n+\n # -----------------------------------------------------------------------------\n # MLP language model\n \n@@ -418,7 +511,7 @@ def next(self):\n     # sampling\n     parser.add_argument('--top-k', type=int, default=-1, help=\"top-k for sampling, -1 means no top-k\")\n     # model\n-    parser.add_argument('--type', type=str, default='bigram', help=\"model class type to use, bigram|mlp|transformer\")\n+    parser.add_argument('--type', type=str, default='bigram', help=\"model class type to use, bigram|mlp|rnn|gru|transformer\")\n     parser.add_argument('--n-layer', type=int, default=4, help=\"number of layers\")\n     parser.add_argument('--n-head', type=int, default=4, help=\"number of heads (in a transformer)\")\n     parser.add_argument('--n-embd', type=int, default=64, help=\"number of feature channels in the model\")\n@@ -446,11 +539,18 @@ def next(self):\n     config = ModelConfig(vocab_size=vocab_size, block_size=block_size,\n                        n_layer=args.n_layer, n_head=args.n_head,\n                        n_embd=args.n_embd, n_embd2=args.n_embd2)\n-    model = {\n-        'transformer': GPT,\n-        'bigram': Bigram,\n-        'mlp': MLP,\n-    }[args.type](config)\n+    if args.type == 'transformer':\n+        model = Transformer(config)\n+    elif args.type == 'bigram':\n+        model = Bigram(config)\n+    elif args.type == 'mlp':\n+        model = MLP(config)\n+    elif args.type == 'rnn':\n+        model = RNN(config, cell_type='rnn')\n+    elif args.type == 'gru':\n+        model = RNN(config, cell_type='gru')\n+    else:\n+        raise ValueError(f'model type {args.type} is not recognized')\n     model.to(args.device)\n     print(f\"model #params: {sum(p.numel() for p in model.parameters())}\")\n     if args.resume or args.sample_only: # note: if we sample-only then we also assume we are resuming", "status": "modified"}, {"commit_id": "6694b67d37ef0420a7d503ee5c126ea512014b70", "commit_message": "generalize makemore into other types of language models, and add bigram LM and an MLP LM", "relative_path": "makemore.py", "previous_code_file": "\"\"\"\nyou give this script some words (one per line) and it will generate more things like it.\nuses super state of the art Transformer AI tech\nthis code is intended to be super hackable. tune it to your needs.\n\nChanges from minGPT:\n- I removed the from_pretrained function where we init with GPT2 weights\n- I removed dropout layers because the models we train here are small,\n  it's not necessary to understand at this stage and at this scale.\n- I removed weight decay and all of the complexity around what parameters are\n  and are not weight decayed. I don't believe this should make a massive\n  difference at the scale that we operate on here.\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport math\nimport argparse\nfrom dataclasses import dataclass\nfrom typing import List\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\nfrom torch.utils.data import Dataset\nfrom torch.utils.data.dataloader import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\n# -----------------------------------------------------------------------------\n# GPT model definition\n\n@dataclass\nclass GPTConfig:\n    # size of the model\n    n_layer: int = 4\n    n_head: int = 4\n    n_embd: int = 64\n    vocab_size: int = None\n    block_size: int = None\n\nclass NewGELU(nn.Module):\n    \"\"\"\n    Implementation of the GELU activation function currently in Google BERT repo (identical to OpenAI GPT).\n    Reference: Gaussian Error Linear Units (GELU) paper: https://arxiv.org/abs/1606.08415\n    \"\"\"\n    def forward(self, x):\n        return 0.5 * x * (1.0 + torch.tanh(math.sqrt(2.0 / math.pi) * (x + 0.044715 * torch.pow(x, 3.0))))\n\nclass CausalSelfAttention(nn.Module):\n    \"\"\"\n    A vanilla multi-head masked self-attention layer with a projection at the end.\n    It is possible to use torch.nn.MultiheadAttention here but I am including an\n    explicit implementation here to show that there is nothing too scary here.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.n_embd % config.n_head == 0\n        # key, query, value projections for all heads, but in a batch\n        self.c_attn = nn.Linear(config.n_embd, 3 * config.n_embd)\n        # output projection\n        self.c_proj = nn.Linear(config.n_embd, config.n_embd)\n        # causal mask to ensure that attention is only applied to the left in the input sequence\n        self.register_buffer(\"bias\", torch.tril(torch.ones(config.block_size, config.block_size))\n                                     .view(1, 1, config.block_size, config.block_size))\n        self.n_head = config.n_head\n        self.n_embd = config.n_embd\n\n    def forward(self, x):\n        B, T, C = x.size() # batch size, sequence length, embedding dimensionality (n_embd)\n\n        # calculate query, key, values for all heads in batch and move head forward to be the batch dim\n        q, k ,v  = self.c_attn(x).split(self.n_embd, dim=2)\n        k = k.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        q = q.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        v = v.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n\n        # causal self-attention; Self-attend: (B, nh, T, hs) x (B, nh, hs, T) -> (B, nh, T, T)\n        att = (q @ k.transpose(-2, -1)) * (1.0 / math.sqrt(k.size(-1)))\n        att = att.masked_fill(self.bias[:,:,:T,:T] == 0, float('-inf'))\n        att = F.softmax(att, dim=-1)\n        y = att @ v # (B, nh, T, T) x (B, nh, T, hs) -> (B, nh, T, hs)\n        y = y.transpose(1, 2).contiguous().view(B, T, C) # re-assemble all head outputs side by side\n\n        # output projection\n        y = self.c_proj(y)\n        return y\n\nclass Block(nn.Module):\n    \"\"\" an unassuming Transformer block \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.ln_1 = nn.LayerNorm(config.n_embd)\n        self.attn = CausalSelfAttention(config)\n        self.ln_2 = nn.LayerNorm(config.n_embd)\n        self.mlp = nn.ModuleDict(dict(\n            c_fc    = nn.Linear(config.n_embd, 4 * config.n_embd),\n            c_proj  = nn.Linear(4 * config.n_embd, config.n_embd),\n            act     = NewGELU(),\n        ))\n        m = self.mlp\n        self.mlpf = lambda x: m.c_proj(m.act(m.c_fc(x))) # MLP forward\n\n    def forward(self, x):\n        x = x + self.attn(self.ln_1(x))\n        x = x + self.mlpf(self.ln_2(x))\n        return x\n\nclass GPT(nn.Module):\n    \"\"\" GPT Language Model \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.block_size = config.block_size\n\n        self.transformer = nn.ModuleDict(dict(\n            wte = nn.Embedding(config.vocab_size, config.n_embd),\n            wpe = nn.Embedding(config.block_size, config.n_embd),\n            h = nn.ModuleList([Block(config) for _ in range(config.n_layer)]),\n            ln_f = nn.LayerNorm(config.n_embd),\n        ))\n        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n\n        # report number of parameters (note we don't count the decoder parameters in lm_head)\n        n_params = sum(p.numel() for p in self.transformer.parameters())\n        print(\"number of parameters: %.2fM\" % (n_params/1e6,))\n\n    def forward(self, idx, targets=None):\n        device = idx.device\n        b, t = idx.size()\n        assert t <= self.block_size, f\"Cannot forward sequence of length {t}, block size is only {self.block_size}\"\n        pos = torch.arange(0, t, dtype=torch.long, device=device).unsqueeze(0) # shape (1, t)\n\n        # forward the GPT model itself\n        tok_emb = self.transformer.wte(idx) # token embeddings of shape (b, t, n_embd)\n        pos_emb = self.transformer.wpe(pos) # position embeddings of shape (1, t, n_embd)\n        x = tok_emb + pos_emb\n        for block in self.transformer.h:\n            x = block(x)\n        x = self.transformer.ln_f(x)\n        logits = self.lm_head(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n    @torch.no_grad()\n    def generate(self, idx, max_new_tokens, temperature=1.0, do_sample=False, top_k=None):\n        \"\"\"\n        Take a conditioning sequence of indices idx (LongTensor of shape (b,t)) and complete\n        the sequence max_new_tokens times, feeding the predictions back into the model each time.\n        Most likely you'll want to make sure to be in model.eval() mode of operation for this.\n        \"\"\"\n        for _ in range(max_new_tokens):\n            # if the sequence context is growing too long we must crop it at block_size\n            idx_cond = idx if idx.size(1) <= self.block_size else idx[:, -self.block_size:]\n            # forward the model to get the logits for the index in the sequence\n            logits, _ = self(idx_cond)\n            # pluck the logits at the final step and scale by desired temperature\n            logits = logits[:, -1, :] / temperature\n            # optionally crop the logits to only the top k options\n            if top_k is not None:\n                v, _ = torch.topk(logits, top_k)\n                logits[logits < v[:, [-1]]] = -float('Inf')\n            # apply softmax to convert logits to (normalized) probabilities\n            probs = F.softmax(logits, dim=-1)\n            # either sample from the distribution or take the most likely element\n            if do_sample:\n                idx_next = torch.multinomial(probs, num_samples=1)\n            else:\n                _, idx_next = torch.topk(probs, k=1, dim=-1)\n            # append sampled index to the running sequence and continue\n            idx = torch.cat((idx, idx_next), dim=1)\n\n        return idx\n\n# -----------------------------------------------------------------------------\n# helper functions for evaluating and sampling from the model\n\ndef print_samples(num=10):\n    \"\"\" samples from the model and pretty prints the decoded samples \"\"\"\n    X_init = torch.zeros(num, 1, dtype=torch.long).to(args.device)\n    top_k = args.top_k if args.top_k != -1 else None\n    steps = train_dataset.get_output_length() - 1 # -1 because we already start with <START> token (index 0)\n    X_samp = model.generate(X_init, steps, top_k=top_k, do_sample=True).to('cpu')\n    train_samples, test_samples, new_samples = [], [], []\n    for i in range(X_samp.size(0)):\n        # get the i'th row of sampled integers, as python list\n        row = X_samp[i, 1:].tolist() # note: we need to crop out the first <START> token\n        # token 0 is the <STOP> token, so we crop the output sequence at that point\n        crop_index = row.index(0) if 0 in row else len(row)\n        row = row[:crop_index]\n        word_samp = train_dataset.decode(row)\n        # separately track samples that we have and have not seen before\n        if train_dataset.contains(word_samp):\n            train_samples.append(word_samp)\n        elif test_dataset.contains(word_samp):\n            test_samples.append(word_samp)\n        else:\n            new_samples.append(word_samp)\n    print('-'*80)\n    for lst, desc in [(train_samples, 'in train'), (test_samples, 'in test'), (new_samples, 'new')]:\n        print(f\"{len(lst)} samples that are {desc}:\")\n        for word in lst:\n            print(word)\n    print('-'*80)\n\n@torch.inference_mode()\ndef evaluate(model, dataset, batch_size=50, max_batches=None):\n    model.eval()\n    loader = DataLoader(dataset, shuffle=True, batch_size=batch_size, num_workers=0)\n    losses = []\n    for i, batch in enumerate(loader):\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n        logits, loss = model(X, Y)\n        losses.append(loss.item())\n        if max_batches is not None and i >= max_batches:\n            break\n    mean_loss = torch.tensor(losses).mean().item()\n    model.train() # reset model back to training mode\n    return mean_loss\n\n# -----------------------------------------------------------------------------\n# helper functions for creating the training and test Datasets that emit words\n\nclass CharDataset(Dataset):\n\n    def __init__(self, words, chars, max_word_length):\n        self.words = words\n        self.chars = chars\n        self.max_word_length = max_word_length\n        self.stoi = {ch:i+1 for i,ch in enumerate(chars)}\n        self.itos = {i:s for s,i in self.stoi.items()} # inverse mapping\n\n    def __len__(self):\n        return len(self.words)\n\n    def contains(self, word):\n        return word in self.words\n\n    def get_vocab_size(self):\n        return len(self.chars) + 1 # all the possible characters and special 0 token\n\n    def get_output_length(self):\n        return self.max_word_length + 1 # <START> token followed by words\n\n    def encode(self, word):\n        ix = torch.tensor([self.stoi[w] for w in word], dtype=torch.long)\n        return ix\n\n    def decode(self, ix):\n        word = ''.join(self.itos[i] for i in ix)\n        return word\n\n    def __getitem__(self, idx):\n        word = self.words[idx]\n        ix = self.encode(word)\n        x = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        y = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        x[1:1+len(ix)] = ix\n        y[:len(ix)] = ix\n        y[len(ix)+1:] = -1 # index -1 will mask the loss at the inactive locations\n        return x, y\n\ndef create_datasets(input_file):\n\n    # preprocessing of the input text file\n    with open(input_file, 'r') as f:\n        data = f.read()\n    words = data.splitlines()\n    words = [w.strip() for w in words] # get rid of any leading or trailing white space\n    words = [w for w in words if w] # get rid of any empty strings\n    chars = sorted(list(set(''.join(words)))) # all the possible characters\n    max_word_length = max(len(w) for w in words)\n    print(f\"number of examples in the dataset: {len(words)}\")\n    print(f\"max word length: {max_word_length}\")\n    print(f\"number of unique characters in the vocabulary: {len(chars)}\")\n    print(\"vocabulary:\")\n    print(''.join(chars))\n\n    # partition the input data into a training and the test set\n    test_set_size = min(1000, int(len(words) * 0.1)) # 10% of the training set, or up to 1000 examples\n    rp = torch.randperm(len(words)).tolist()\n    train_words = [words[i] for i in rp[:-test_set_size]]\n    test_words = [words[i] for i in rp[-test_set_size:]]\n    print(f\"split up the dataset into {len(train_words)} training examples and {len(test_words)} test examples\")\n\n    # wrap in dataset objects\n    train_dataset = CharDataset(train_words, chars, max_word_length)\n    test_dataset = CharDataset(test_words, chars, max_word_length)\n\n    return train_dataset, test_dataset\n\nclass InfiniteDataLoader:\n    \"\"\"\n    this is really hacky and I'm not proud of it, but there doesn't seem to be\n    a better way in PyTorch to just create an infinite dataloader?\n    \"\"\"\n\n    def __init__(self, dataset, **kwargs):\n        train_sampler = torch.utils.data.RandomSampler(dataset, replacement=True, num_samples=int(1e10))\n        self.train_loader = DataLoader(dataset, sampler=train_sampler, **kwargs)\n        self.data_iter = iter(self.train_loader)\n\n    def next(self):\n        try:\n            batch = next(self.data_iter)\n        except StopIteration: # this will technically only happen after 1e10 samples... (i.e. basically never)\n            self.data_iter = iter(self.train_loader)\n            batch = next(self.data_iter)\n        return batch\n\n# -----------------------------------------------------------------------------\nif __name__ == '__main__':\n\n    # parse command line args\n    parser = argparse.ArgumentParser(description=\"Make More\")\n    # system/input/output\n    parser.add_argument('--input-file', '-i', type=str, default='names.txt', help=\"input file with things one per line\")\n    parser.add_argument('--work-dir', '-o', type=str, default='out', help=\"output working directory\")\n    parser.add_argument('--resume', action='store_true', help=\"when this flag is used, we will resume optimization from existing model in the workdir\")\n    parser.add_argument('--sample-only', action='store_true', help=\"just sample from the model and quit, don't train\")\n    parser.add_argument('--num-workers', '-n', type=int, default=4, help=\"number of data workers for both train/test\")\n    parser.add_argument('--max-steps', type=int, default=-1, help=\"max number of optimization steps to run for, or -1 for infinite.\")\n    parser.add_argument('--device', type=str, default='cpu', help=\"device to use for compute, examples: cpu|cuda|cuda:2|mps\")\n    parser.add_argument('--seed', type=int, default=3407, help=\"seed\")\n    # sampling\n    parser.add_argument('--top-k', type=int, default=-1, help=\"top-k for sampling, -1 means no top-k\")\n    # model\n    parser.add_argument('--n-layer', type=int, default=4, help=\"number of layers in the transformer\")\n    parser.add_argument('--n-head', type=int, default=4, help=\"number of heads in the transformer\")\n    parser.add_argument('--n-embd', type=int, default=64, help=\"number of feature channels in the transformer\")\n    # optimization\n    parser.add_argument('--batch-size', '-b', type=int, default=32, help=\"batch size during optimization\")\n    parser.add_argument('--learning-rate', '-l', type=float, default=5e-4, help=\"learning rate\")\n    parser.add_argument('--weight-decay', '-w', type=float, default=0.01, help=\"weight decay\")\n    args = parser.parse_args()\n    print(vars(args))\n\n    # system inits\n    torch.manual_seed(args.seed)\n    torch.cuda.manual_seed_all(args.seed)\n    os.makedirs(args.work_dir, exist_ok=True)\n    writer = SummaryWriter(log_dir=args.work_dir)\n\n    # init datasets\n    train_dataset, test_dataset = create_datasets(args.input_file)\n    vocab_size = train_dataset.get_vocab_size()\n    block_size = train_dataset.get_output_length()\n    print(f\"dataset determined that: {vocab_size=}, {block_size=}\")\n\n    # init model\n    config = GPTConfig(vocab_size=vocab_size, block_size=block_size,\n                       n_layer=args.n_layer, n_head=args.n_head, n_embd=args.n_embd)\n    model = GPT(config)\n    model.to(args.device)\n    print(f\"model #params: {sum(p.numel() for p in model.parameters())}\")\n    if args.resume or args.sample_only: # note: if we sample-only then we also assume we are resuming\n        print(\"resuming from existing model in the workdir\")\n        model.load_state_dict(torch.load(os.path.join(args.work_dir, 'model.pt')))\n    if args.sample_only:\n        print_samples(num=50)\n        sys.exit()\n\n    # init optimizer\n    optimizer = torch.optim.AdamW(model.parameters(), lr=args.learning_rate, weight_decay=args.weight_decay, betas=(0.9, 0.99), eps=1e-8)\n\n    # init dataloader\n    batch_loader = InfiniteDataLoader(train_dataset, batch_size=args.batch_size, pin_memory=True, num_workers=args.num_workers)\n\n    # training loop\n    best_loss = None\n    step = 0\n    while True:\n\n        t0 = time.time()\n\n        # get the next batch, ship to device, and unpack it to input and target\n        batch = batch_loader.next()\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n\n        # feed into the model\n        logits, loss = model(X, Y)\n\n        # calculate the gradient, update the weights\n        model.zero_grad(set_to_none=True)\n        loss.backward()\n        optimizer.step()\n\n        # wait for all CUDA work on the GPU to finish then calculate iteration time taken\n        if args.device.startswith('cuda'):\n            torch.cuda.synchronize()\n        t1 = time.time()\n\n        # logging\n        if step % 10 == 0:\n            print(f\"step {step} | loss {loss.item():.4f} | step time {(t1-t0)*1000:.2f}ms\")\n\n        # evaluate the model\n        if step > 0 and step % 500 == 0:\n            train_loss = evaluate(model, train_dataset, batch_size=100, max_batches=10)\n            test_loss  = evaluate(model, test_dataset,  batch_size=100, max_batches=10)\n            writer.add_scalar(\"Loss/train\", train_loss, step)\n            writer.add_scalar(\"Loss/test\", test_loss, step)\n            writer.flush()\n            print(f\"step {step} train loss: {train_loss} test loss: {test_loss}\")\n            # save the model to disk if it has improved\n            if best_loss is None or test_loss < best_loss:\n                out_path = os.path.join(args.work_dir, \"model.pt\")\n                print(f\"test loss {test_loss} is the best so far, saving model to {out_path}\")\n                torch.save(model.state_dict(), out_path)\n                best_loss = test_loss\n\n        # sample from the model\n        if step > 0 and step % 200 == 0:\n            print_samples(num=10)\n\n        step += 1\n        # termination conditions\n        if args.max_steps >= 0 and step >= args.max_steps:\n            break\n\n", "previous_id": "50617fa75dfb6bd57ea342c47ddcafecdc03e9e3", "new_code_file": "\"\"\"\nyou give this script some words (one per line) and it will generate more things like it.\nuses super state of the art Transformer AI tech\nthis code is intended to be super hackable. tune it to your needs.\n\nChanges from minGPT:\n- I removed the from_pretrained function where we init with GPT2 weights\n- I removed dropout layers because the models we train here are small,\n  it's not necessary to understand at this stage and at this scale.\n- I removed weight decay and all of the complexity around what parameters are\n  and are not weight decayed. I don't believe this should make a massive\n  difference at the scale that we operate on here.\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport math\nimport argparse\nfrom dataclasses import dataclass\nfrom typing import List\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\nfrom torch.utils.data import Dataset\nfrom torch.utils.data.dataloader import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\n# -----------------------------------------------------------------------------\n\n@dataclass\nclass ModelConfig:\n    block_size: int = None # length of the input sequences of integers\n    vocab_size: int = None # the input integers are in range [0 .. vocab_size -1]\n    # parameters below control the sizes of each model slightly differently\n    n_layer: int = 4\n    n_embd: int = 64\n    n_embd2: int = 64\n    n_head: int = 4\n\n# -----------------------------------------------------------------------------\n# Transformer Language Model (*exactly* as used in GPT-2)\n\nclass NewGELU(nn.Module):\n    \"\"\"\n    Implementation of the GELU activation function currently in Google BERT repo (identical to OpenAI GPT).\n    Reference: Gaussian Error Linear Units (GELU) paper: https://arxiv.org/abs/1606.08415\n    \"\"\"\n    def forward(self, x):\n        return 0.5 * x * (1.0 + torch.tanh(math.sqrt(2.0 / math.pi) * (x + 0.044715 * torch.pow(x, 3.0))))\n\nclass CausalSelfAttention(nn.Module):\n    \"\"\"\n    A vanilla multi-head masked self-attention layer with a projection at the end.\n    It is possible to use torch.nn.MultiheadAttention here but I am including an\n    explicit implementation here to show that there is nothing too scary here.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.n_embd % config.n_head == 0\n        # key, query, value projections for all heads, but in a batch\n        self.c_attn = nn.Linear(config.n_embd, 3 * config.n_embd)\n        # output projection\n        self.c_proj = nn.Linear(config.n_embd, config.n_embd)\n        # causal mask to ensure that attention is only applied to the left in the input sequence\n        self.register_buffer(\"bias\", torch.tril(torch.ones(config.block_size, config.block_size))\n                                     .view(1, 1, config.block_size, config.block_size))\n        self.n_head = config.n_head\n        self.n_embd = config.n_embd\n\n    def forward(self, x):\n        B, T, C = x.size() # batch size, sequence length, embedding dimensionality (n_embd)\n\n        # calculate query, key, values for all heads in batch and move head forward to be the batch dim\n        q, k ,v  = self.c_attn(x).split(self.n_embd, dim=2)\n        k = k.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        q = q.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        v = v.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n\n        # causal self-attention; Self-attend: (B, nh, T, hs) x (B, nh, hs, T) -> (B, nh, T, T)\n        att = (q @ k.transpose(-2, -1)) * (1.0 / math.sqrt(k.size(-1)))\n        att = att.masked_fill(self.bias[:,:,:T,:T] == 0, float('-inf'))\n        att = F.softmax(att, dim=-1)\n        y = att @ v # (B, nh, T, T) x (B, nh, T, hs) -> (B, nh, T, hs)\n        y = y.transpose(1, 2).contiguous().view(B, T, C) # re-assemble all head outputs side by side\n\n        # output projection\n        y = self.c_proj(y)\n        return y\n\nclass Block(nn.Module):\n    \"\"\" an unassuming Transformer block \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.ln_1 = nn.LayerNorm(config.n_embd)\n        self.attn = CausalSelfAttention(config)\n        self.ln_2 = nn.LayerNorm(config.n_embd)\n        self.mlp = nn.ModuleDict(dict(\n            c_fc    = nn.Linear(config.n_embd, 4 * config.n_embd),\n            c_proj  = nn.Linear(4 * config.n_embd, config.n_embd),\n            act     = NewGELU(),\n        ))\n        m = self.mlp\n        self.mlpf = lambda x: m.c_proj(m.act(m.c_fc(x))) # MLP forward\n\n    def forward(self, x):\n        x = x + self.attn(self.ln_1(x))\n        x = x + self.mlpf(self.ln_2(x))\n        return x\n\nclass GPT(nn.Module):\n    \"\"\" GPT Language Model \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.block_size = config.block_size\n\n        self.transformer = nn.ModuleDict(dict(\n            wte = nn.Embedding(config.vocab_size, config.n_embd),\n            wpe = nn.Embedding(config.block_size, config.n_embd),\n            h = nn.ModuleList([Block(config) for _ in range(config.n_layer)]),\n            ln_f = nn.LayerNorm(config.n_embd),\n        ))\n        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n\n        # report number of parameters (note we don't count the decoder parameters in lm_head)\n        n_params = sum(p.numel() for p in self.transformer.parameters())\n        print(\"number of parameters: %.2fM\" % (n_params/1e6,))\n\n    def get_block_size(self):\n        return self.block_size\n\n    def forward(self, idx, targets=None):\n        device = idx.device\n        b, t = idx.size()\n        assert t <= self.block_size, f\"Cannot forward sequence of length {t}, block size is only {self.block_size}\"\n        pos = torch.arange(0, t, dtype=torch.long, device=device).unsqueeze(0) # shape (1, t)\n\n        # forward the GPT model itself\n        tok_emb = self.transformer.wte(idx) # token embeddings of shape (b, t, n_embd)\n        pos_emb = self.transformer.wpe(pos) # position embeddings of shape (1, t, n_embd)\n        x = tok_emb + pos_emb\n        for block in self.transformer.h:\n            x = block(x)\n        x = self.transformer.ln_f(x)\n        logits = self.lm_head(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n# MLP language model\n\nclass MLP(nn.Module):\n    \"\"\"\n    takes the previous block_size tokens, encodes them with a lookup table,\n    concatenates the vectors and predicts the next token with an MLP.\n\n    Reference:\n    Bengio et al. 2003 https://www.jmlr.org/papers/volume3/bengio03a/bengio03a.pdf\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.block_size = config.block_size\n        self.vocab_size = config.vocab_size\n        self.wte = nn.Embedding(config.vocab_size + 1, config.n_embd) # token embeddings table\n        # +1 in the line above for a special <BLANK> token that gets inserted if encoding a token\n        # before the beginning of the input sequence\n        self.mlp = nn.Sequential(\n            nn.Linear(self.block_size * config.n_embd, config.n_embd2), # TODO: option to vary this\n            nn.Tanh(),\n            nn.Linear(config.n_embd2, self.vocab_size)\n        )\n\n    def get_block_size(self):\n        return self.block_size\n\n    def forward(self, idx, targets=None):\n\n        # gather the word embeddings of the previous 3 words\n        embs = []\n        for k in range(self.block_size):\n            tok_emb = self.wte(idx) # token embeddings of shape (b, t, n_embd)\n            idx = torch.roll(idx, 1, 1)\n            idx[:, 0] = self.vocab_size # special <BLANK> token\n            embs.append(tok_emb)\n\n        # concat all of the embeddings together and pass through an MLP\n        x = torch.cat(embs, -1) # (b, t, n_embd * block_size)\n        logits = self.mlp(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n# Bigram language model\n\nclass Bigram(nn.Module):\n    \"\"\"\n    Bigram Language Model 'neural net', simply a lookup table of logits for the\n    next character given a previous character.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        n = config.vocab_size\n        self.logits = nn.Parameter(torch.zeros((n, n)))\n\n    def get_block_size(self):\n        return 1 # this model only needs one previous character to predict the next\n\n    def forward(self, idx, targets=None):\n\n         # 'forward pass', lol\n        logits = self.logits[idx]\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n# helper functions for evaluating and sampling from the model\n\n@torch.no_grad()\ndef generate(model, idx, max_new_tokens, temperature=1.0, do_sample=False, top_k=None):\n    \"\"\"\n    Take a conditioning sequence of indices idx (LongTensor of shape (b,t)) and complete\n    the sequence max_new_tokens times, feeding the predictions back into the model each time.\n    Most likely you'll want to make sure to be in model.eval() mode of operation for this.\n    \"\"\"\n    block_size = model.get_block_size()\n    for _ in range(max_new_tokens):\n        # if the sequence context is growing too long we must crop it at block_size\n        idx_cond = idx if idx.size(1) <= block_size else idx[:, -block_size:]\n        # forward the model to get the logits for the index in the sequence\n        logits, _ = model(idx_cond)\n        # pluck the logits at the final step and scale by desired temperature\n        logits = logits[:, -1, :] / temperature\n        # optionally crop the logits to only the top k options\n        if top_k is not None:\n            v, _ = torch.topk(logits, top_k)\n            logits[logits < v[:, [-1]]] = -float('Inf')\n        # apply softmax to convert logits to (normalized) probabilities\n        probs = F.softmax(logits, dim=-1)\n        # either sample from the distribution or take the most likely element\n        if do_sample:\n            idx_next = torch.multinomial(probs, num_samples=1)\n        else:\n            _, idx_next = torch.topk(probs, k=1, dim=-1)\n        # append sampled index to the running sequence and continue\n        idx = torch.cat((idx, idx_next), dim=1)\n\n    return idx\n\ndef print_samples(num=10):\n    \"\"\" samples from the model and pretty prints the decoded samples \"\"\"\n    X_init = torch.zeros(num, 1, dtype=torch.long).to(args.device)\n    top_k = args.top_k if args.top_k != -1 else None\n    steps = train_dataset.get_output_length() - 1 # -1 because we already start with <START> token (index 0)\n    X_samp = generate(model, X_init, steps, top_k=top_k, do_sample=True).to('cpu')\n    train_samples, test_samples, new_samples = [], [], []\n    for i in range(X_samp.size(0)):\n        # get the i'th row of sampled integers, as python list\n        row = X_samp[i, 1:].tolist() # note: we need to crop out the first <START> token\n        # token 0 is the <STOP> token, so we crop the output sequence at that point\n        crop_index = row.index(0) if 0 in row else len(row)\n        row = row[:crop_index]\n        word_samp = train_dataset.decode(row)\n        # separately track samples that we have and have not seen before\n        if train_dataset.contains(word_samp):\n            train_samples.append(word_samp)\n        elif test_dataset.contains(word_samp):\n            test_samples.append(word_samp)\n        else:\n            new_samples.append(word_samp)\n    print('-'*80)\n    for lst, desc in [(train_samples, 'in train'), (test_samples, 'in test'), (new_samples, 'new')]:\n        print(f\"{len(lst)} samples that are {desc}:\")\n        for word in lst:\n            print(word)\n    print('-'*80)\n\n@torch.inference_mode()\ndef evaluate(model, dataset, batch_size=50, max_batches=None):\n    model.eval()\n    loader = DataLoader(dataset, shuffle=True, batch_size=batch_size, num_workers=0)\n    losses = []\n    for i, batch in enumerate(loader):\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n        logits, loss = model(X, Y)\n        losses.append(loss.item())\n        if max_batches is not None and i >= max_batches:\n            break\n    mean_loss = torch.tensor(losses).mean().item()\n    model.train() # reset model back to training mode\n    return mean_loss\n\n# -----------------------------------------------------------------------------\n# helper functions for creating the training and test Datasets that emit words\n\nclass CharDataset(Dataset):\n\n    def __init__(self, words, chars, max_word_length):\n        self.words = words\n        self.chars = chars\n        self.max_word_length = max_word_length\n        self.stoi = {ch:i+1 for i,ch in enumerate(chars)}\n        self.itos = {i:s for s,i in self.stoi.items()} # inverse mapping\n\n    def __len__(self):\n        return len(self.words)\n\n    def contains(self, word):\n        return word in self.words\n\n    def get_vocab_size(self):\n        return len(self.chars) + 1 # all the possible characters and special 0 token\n\n    def get_output_length(self):\n        return self.max_word_length + 1 # <START> token followed by words\n\n    def encode(self, word):\n        ix = torch.tensor([self.stoi[w] for w in word], dtype=torch.long)\n        return ix\n\n    def decode(self, ix):\n        word = ''.join(self.itos[i] for i in ix)\n        return word\n\n    def __getitem__(self, idx):\n        word = self.words[idx]\n        ix = self.encode(word)\n        x = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        y = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        x[1:1+len(ix)] = ix\n        y[:len(ix)] = ix\n        y[len(ix)+1:] = -1 # index -1 will mask the loss at the inactive locations\n        return x, y\n\ndef create_datasets(input_file):\n\n    # preprocessing of the input text file\n    with open(input_file, 'r') as f:\n        data = f.read()\n    words = data.splitlines()\n    words = [w.strip() for w in words] # get rid of any leading or trailing white space\n    words = [w for w in words if w] # get rid of any empty strings\n    chars = sorted(list(set(''.join(words)))) # all the possible characters\n    max_word_length = max(len(w) for w in words)\n    print(f\"number of examples in the dataset: {len(words)}\")\n    print(f\"max word length: {max_word_length}\")\n    print(f\"number of unique characters in the vocabulary: {len(chars)}\")\n    print(\"vocabulary:\")\n    print(''.join(chars))\n\n    # partition the input data into a training and the test set\n    test_set_size = min(1000, int(len(words) * 0.1)) # 10% of the training set, or up to 1000 examples\n    rp = torch.randperm(len(words)).tolist()\n    train_words = [words[i] for i in rp[:-test_set_size]]\n    test_words = [words[i] for i in rp[-test_set_size:]]\n    print(f\"split up the dataset into {len(train_words)} training examples and {len(test_words)} test examples\")\n\n    # wrap in dataset objects\n    train_dataset = CharDataset(train_words, chars, max_word_length)\n    test_dataset = CharDataset(test_words, chars, max_word_length)\n\n    return train_dataset, test_dataset\n\nclass InfiniteDataLoader:\n    \"\"\"\n    this is really hacky and I'm not proud of it, but there doesn't seem to be\n    a better way in PyTorch to just create an infinite dataloader?\n    \"\"\"\n\n    def __init__(self, dataset, **kwargs):\n        train_sampler = torch.utils.data.RandomSampler(dataset, replacement=True, num_samples=int(1e10))\n        self.train_loader = DataLoader(dataset, sampler=train_sampler, **kwargs)\n        self.data_iter = iter(self.train_loader)\n\n    def next(self):\n        try:\n            batch = next(self.data_iter)\n        except StopIteration: # this will technically only happen after 1e10 samples... (i.e. basically never)\n            self.data_iter = iter(self.train_loader)\n            batch = next(self.data_iter)\n        return batch\n\n# -----------------------------------------------------------------------------\nif __name__ == '__main__':\n\n    # parse command line args\n    parser = argparse.ArgumentParser(description=\"Make More\")\n    # system/input/output\n    parser.add_argument('--input-file', '-i', type=str, default='names.txt', help=\"input file with things one per line\")\n    parser.add_argument('--work-dir', '-o', type=str, default='out', help=\"output working directory\")\n    parser.add_argument('--resume', action='store_true', help=\"when this flag is used, we will resume optimization from existing model in the workdir\")\n    parser.add_argument('--sample-only', action='store_true', help=\"just sample from the model and quit, don't train\")\n    parser.add_argument('--num-workers', '-n', type=int, default=4, help=\"number of data workers for both train/test\")\n    parser.add_argument('--max-steps', type=int, default=-1, help=\"max number of optimization steps to run for, or -1 for infinite.\")\n    parser.add_argument('--device', type=str, default='cpu', help=\"device to use for compute, examples: cpu|cuda|cuda:2|mps\")\n    parser.add_argument('--seed', type=int, default=3407, help=\"seed\")\n    # sampling\n    parser.add_argument('--top-k', type=int, default=-1, help=\"top-k for sampling, -1 means no top-k\")\n    # model\n    parser.add_argument('--type', type=str, default='bigram', help=\"model class type to use, bigram|mlp|transformer\")\n    parser.add_argument('--n-layer', type=int, default=4, help=\"number of layers\")\n    parser.add_argument('--n-head', type=int, default=4, help=\"number of heads (in a transformer)\")\n    parser.add_argument('--n-embd', type=int, default=64, help=\"number of feature channels in the model\")\n    parser.add_argument('--n-embd2', type=int, default=64, help=\"number of feature channels elsewhere in the model\")\n    # optimization\n    parser.add_argument('--batch-size', '-b', type=int, default=32, help=\"batch size during optimization\")\n    parser.add_argument('--learning-rate', '-l', type=float, default=5e-4, help=\"learning rate\")\n    parser.add_argument('--weight-decay', '-w', type=float, default=0.01, help=\"weight decay\")\n    args = parser.parse_args()\n    print(vars(args))\n\n    # system inits\n    torch.manual_seed(args.seed)\n    torch.cuda.manual_seed_all(args.seed)\n    os.makedirs(args.work_dir, exist_ok=True)\n    writer = SummaryWriter(log_dir=args.work_dir)\n\n    # init datasets\n    train_dataset, test_dataset = create_datasets(args.input_file)\n    vocab_size = train_dataset.get_vocab_size()\n    block_size = train_dataset.get_output_length()\n    print(f\"dataset determined that: {vocab_size=}, {block_size=}\")\n\n    # init model\n    config = ModelConfig(vocab_size=vocab_size, block_size=block_size,\n                       n_layer=args.n_layer, n_head=args.n_head,\n                       n_embd=args.n_embd, n_embd2=args.n_embd2)\n    model = {\n        'transformer': GPT,\n        'bigram': Bigram,\n        'mlp': MLP,\n    }[args.type](config)\n    model.to(args.device)\n    print(f\"model #params: {sum(p.numel() for p in model.parameters())}\")\n    if args.resume or args.sample_only: # note: if we sample-only then we also assume we are resuming\n        print(\"resuming from existing model in the workdir\")\n        model.load_state_dict(torch.load(os.path.join(args.work_dir, 'model.pt')))\n    if args.sample_only:\n        print_samples(num=50)\n        sys.exit()\n\n    # init optimizer\n    optimizer = torch.optim.AdamW(model.parameters(), lr=args.learning_rate, weight_decay=args.weight_decay, betas=(0.9, 0.99), eps=1e-8)\n\n    # init dataloader\n    batch_loader = InfiniteDataLoader(train_dataset, batch_size=args.batch_size, pin_memory=True, num_workers=args.num_workers)\n\n    # training loop\n    best_loss = None\n    step = 0\n    while True:\n\n        t0 = time.time()\n\n        # get the next batch, ship to device, and unpack it to input and target\n        batch = batch_loader.next()\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n\n        # feed into the model\n        logits, loss = model(X, Y)\n\n        # calculate the gradient, update the weights\n        model.zero_grad(set_to_none=True)\n        loss.backward()\n        optimizer.step()\n\n        # wait for all CUDA work on the GPU to finish then calculate iteration time taken\n        if args.device.startswith('cuda'):\n            torch.cuda.synchronize()\n        t1 = time.time()\n\n        # logging\n        if step % 10 == 0:\n            print(f\"step {step} | loss {loss.item():.4f} | step time {(t1-t0)*1000:.2f}ms\")\n\n        # evaluate the model\n        if step > 0 and step % 500 == 0:\n            train_loss = evaluate(model, train_dataset, batch_size=100, max_batches=10)\n            test_loss  = evaluate(model, test_dataset,  batch_size=100, max_batches=10)\n            writer.add_scalar(\"Loss/train\", train_loss, step)\n            writer.add_scalar(\"Loss/test\", test_loss, step)\n            writer.flush()\n            print(f\"step {step} train loss: {train_loss} test loss: {test_loss}\")\n            # save the model to disk if it has improved\n            if best_loss is None or test_loss < best_loss:\n                out_path = os.path.join(args.work_dir, \"model.pt\")\n                print(f\"test loss {test_loss} is the best so far, saving model to {out_path}\")\n                torch.save(model.state_dict(), out_path)\n                best_loss = test_loss\n\n        # sample from the model\n        if step > 0 and step % 200 == 0:\n            print_samples(num=10)\n\n        step += 1\n        # termination conditions\n        if args.max_steps >= 0 and step >= args.max_steps:\n            break\n\n", "diff": "@@ -28,16 +28,19 @@\n from torch.utils.tensorboard import SummaryWriter\n \n # -----------------------------------------------------------------------------\n-# GPT model definition\n \n @dataclass\n-class GPTConfig:\n-    # size of the model\n+class ModelConfig:\n+    block_size: int = None # length of the input sequences of integers\n+    vocab_size: int = None # the input integers are in range [0 .. vocab_size -1]\n+    # parameters below control the sizes of each model slightly differently\n     n_layer: int = 4\n-    n_head: int = 4\n     n_embd: int = 64\n-    vocab_size: int = None\n-    block_size: int = None\n+    n_embd2: int = 64\n+    n_head: int = 4\n+\n+# -----------------------------------------------------------------------------\n+# Transformer Language Model (*exactly* as used in GPT-2)\n \n class NewGELU(nn.Module):\n     \"\"\"\n@@ -127,6 +130,9 @@ def __init__(self, config):\n         n_params = sum(p.numel() for p in self.transformer.parameters())\n         print(\"number of parameters: %.2fM\" % (n_params/1e6,))\n \n+    def get_block_size(self):\n+        return self.block_size\n+\n     def forward(self, idx, targets=None):\n         device = idx.device\n         b, t = idx.size()\n@@ -149,45 +155,124 @@ def forward(self, idx, targets=None):\n \n         return logits, loss\n \n-    @torch.no_grad()\n-    def generate(self, idx, max_new_tokens, temperature=1.0, do_sample=False, top_k=None):\n-        \"\"\"\n-        Take a conditioning sequence of indices idx (LongTensor of shape (b,t)) and complete\n-        the sequence max_new_tokens times, feeding the predictions back into the model each time.\n-        Most likely you'll want to make sure to be in model.eval() mode of operation for this.\n-        \"\"\"\n-        for _ in range(max_new_tokens):\n-            # if the sequence context is growing too long we must crop it at block_size\n-            idx_cond = idx if idx.size(1) <= self.block_size else idx[:, -self.block_size:]\n-            # forward the model to get the logits for the index in the sequence\n-            logits, _ = self(idx_cond)\n-            # pluck the logits at the final step and scale by desired temperature\n-            logits = logits[:, -1, :] / temperature\n-            # optionally crop the logits to only the top k options\n-            if top_k is not None:\n-                v, _ = torch.topk(logits, top_k)\n-                logits[logits < v[:, [-1]]] = -float('Inf')\n-            # apply softmax to convert logits to (normalized) probabilities\n-            probs = F.softmax(logits, dim=-1)\n-            # either sample from the distribution or take the most likely element\n-            if do_sample:\n-                idx_next = torch.multinomial(probs, num_samples=1)\n-            else:\n-                _, idx_next = torch.topk(probs, k=1, dim=-1)\n-            # append sampled index to the running sequence and continue\n-            idx = torch.cat((idx, idx_next), dim=1)\n-\n-        return idx\n+# -----------------------------------------------------------------------------\n+# MLP language model\n+\n+class MLP(nn.Module):\n+    \"\"\"\n+    takes the previous block_size tokens, encodes them with a lookup table,\n+    concatenates the vectors and predicts the next token with an MLP.\n+\n+    Reference:\n+    Bengio et al. 2003 https://www.jmlr.org/papers/volume3/bengio03a/bengio03a.pdf\n+    \"\"\"\n+\n+    def __init__(self, config):\n+        super().__init__()\n+        self.block_size = config.block_size\n+        self.vocab_size = config.vocab_size\n+        self.wte = nn.Embedding(config.vocab_size + 1, config.n_embd) # token embeddings table\n+        # +1 in the line above for a special <BLANK> token that gets inserted if encoding a token\n+        # before the beginning of the input sequence\n+        self.mlp = nn.Sequential(\n+            nn.Linear(self.block_size * config.n_embd, config.n_embd2), # TODO: option to vary this\n+            nn.Tanh(),\n+            nn.Linear(config.n_embd2, self.vocab_size)\n+        )\n+\n+    def get_block_size(self):\n+        return self.block_size\n+\n+    def forward(self, idx, targets=None):\n+\n+        # gather the word embeddings of the previous 3 words\n+        embs = []\n+        for k in range(self.block_size):\n+            tok_emb = self.wte(idx) # token embeddings of shape (b, t, n_embd)\n+            idx = torch.roll(idx, 1, 1)\n+            idx[:, 0] = self.vocab_size # special <BLANK> token\n+            embs.append(tok_emb)\n+\n+        # concat all of the embeddings together and pass through an MLP\n+        x = torch.cat(embs, -1) # (b, t, n_embd * block_size)\n+        logits = self.mlp(x)\n+\n+        # if we are given some desired targets also calculate the loss\n+        loss = None\n+        if targets is not None:\n+            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n+\n+        return logits, loss\n+\n+# -----------------------------------------------------------------------------\n+# Bigram language model\n+\n+class Bigram(nn.Module):\n+    \"\"\"\n+    Bigram Language Model 'neural net', simply a lookup table of logits for the\n+    next character given a previous character.\n+    \"\"\"\n+\n+    def __init__(self, config):\n+        super().__init__()\n+        n = config.vocab_size\n+        self.logits = nn.Parameter(torch.zeros((n, n)))\n+\n+    def get_block_size(self):\n+        return 1 # this model only needs one previous character to predict the next\n+\n+    def forward(self, idx, targets=None):\n+\n+         # 'forward pass', lol\n+        logits = self.logits[idx]\n+\n+        # if we are given some desired targets also calculate the loss\n+        loss = None\n+        if targets is not None:\n+            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n+\n+        return logits, loss\n \n # -----------------------------------------------------------------------------\n # helper functions for evaluating and sampling from the model\n \n+@torch.no_grad()\n+def generate(model, idx, max_new_tokens, temperature=1.0, do_sample=False, top_k=None):\n+    \"\"\"\n+    Take a conditioning sequence of indices idx (LongTensor of shape (b,t)) and complete\n+    the sequence max_new_tokens times, feeding the predictions back into the model each time.\n+    Most likely you'll want to make sure to be in model.eval() mode of operation for this.\n+    \"\"\"\n+    block_size = model.get_block_size()\n+    for _ in range(max_new_tokens):\n+        # if the sequence context is growing too long we must crop it at block_size\n+        idx_cond = idx if idx.size(1) <= block_size else idx[:, -block_size:]\n+        # forward the model to get the logits for the index in the sequence\n+        logits, _ = model(idx_cond)\n+        # pluck the logits at the final step and scale by desired temperature\n+        logits = logits[:, -1, :] / temperature\n+        # optionally crop the logits to only the top k options\n+        if top_k is not None:\n+            v, _ = torch.topk(logits, top_k)\n+            logits[logits < v[:, [-1]]] = -float('Inf')\n+        # apply softmax to convert logits to (normalized) probabilities\n+        probs = F.softmax(logits, dim=-1)\n+        # either sample from the distribution or take the most likely element\n+        if do_sample:\n+            idx_next = torch.multinomial(probs, num_samples=1)\n+        else:\n+            _, idx_next = torch.topk(probs, k=1, dim=-1)\n+        # append sampled index to the running sequence and continue\n+        idx = torch.cat((idx, idx_next), dim=1)\n+\n+    return idx\n+\n def print_samples(num=10):\n     \"\"\" samples from the model and pretty prints the decoded samples \"\"\"\n     X_init = torch.zeros(num, 1, dtype=torch.long).to(args.device)\n     top_k = args.top_k if args.top_k != -1 else None\n     steps = train_dataset.get_output_length() - 1 # -1 because we already start with <START> token (index 0)\n-    X_samp = model.generate(X_init, steps, top_k=top_k, do_sample=True).to('cpu')\n+    X_samp = generate(model, X_init, steps, top_k=top_k, do_sample=True).to('cpu')\n     train_samples, test_samples, new_samples = [], [], []\n     for i in range(X_samp.size(0)):\n         # get the i'th row of sampled integers, as python list\n@@ -333,9 +418,11 @@ def next(self):\n     # sampling\n     parser.add_argument('--top-k', type=int, default=-1, help=\"top-k for sampling, -1 means no top-k\")\n     # model\n-    parser.add_argument('--n-layer', type=int, default=4, help=\"number of layers in the transformer\")\n-    parser.add_argument('--n-head', type=int, default=4, help=\"number of heads in the transformer\")\n-    parser.add_argument('--n-embd', type=int, default=64, help=\"number of feature channels in the transformer\")\n+    parser.add_argument('--type', type=str, default='bigram', help=\"model class type to use, bigram|mlp|transformer\")\n+    parser.add_argument('--n-layer', type=int, default=4, help=\"number of layers\")\n+    parser.add_argument('--n-head', type=int, default=4, help=\"number of heads (in a transformer)\")\n+    parser.add_argument('--n-embd', type=int, default=64, help=\"number of feature channels in the model\")\n+    parser.add_argument('--n-embd2', type=int, default=64, help=\"number of feature channels elsewhere in the model\")\n     # optimization\n     parser.add_argument('--batch-size', '-b', type=int, default=32, help=\"batch size during optimization\")\n     parser.add_argument('--learning-rate', '-l', type=float, default=5e-4, help=\"learning rate\")\n@@ -356,9 +443,14 @@ def next(self):\n     print(f\"dataset determined that: {vocab_size=}, {block_size=}\")\n \n     # init model\n-    config = GPTConfig(vocab_size=vocab_size, block_size=block_size,\n-                       n_layer=args.n_layer, n_head=args.n_head, n_embd=args.n_embd)\n-    model = GPT(config)\n+    config = ModelConfig(vocab_size=vocab_size, block_size=block_size,\n+                       n_layer=args.n_layer, n_head=args.n_head,\n+                       n_embd=args.n_embd, n_embd2=args.n_embd2)\n+    model = {\n+        'transformer': GPT,\n+        'bigram': Bigram,\n+        'mlp': MLP,\n+    }[args.type](config)\n     model.to(args.device)\n     print(f\"model #params: {sum(p.numel() for p in model.parameters())}\")\n     if args.resume or args.sample_only: # note: if we sample-only then we also assume we are resuming", "status": "modified"}, {"commit_id": "50617fa75dfb6bd57ea342c47ddcafecdc03e9e3", "commit_message": "fix comment", "relative_path": "makemore.py", "previous_code_file": "\"\"\"\nyou give this script some words (one per line) and it will generate more things like it.\nuses super state of the art Transformer AI tech\nthis code is intended to be super hackable. tune it to your needs.\n\nChanges from minGPT:\n- I removed the from_pretrained function where we init with GPT2 weights\n- I removed dropout layers because the models we train here are small,\n  it's not necessary to understand at this stage and at this scale.\n- I removed weight decay and all of the complexity around what parameters are\n  and are not weight decayed. I don't believe this should make a massive\n  difference at the scale that we operate on here.\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport math\nimport argparse\nfrom dataclasses import dataclass\nfrom typing import List\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\nfrom torch.utils.data import Dataset\nfrom torch.utils.data.dataloader import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\n# -----------------------------------------------------------------------------\n# GPT model definition\n\n@dataclass\nclass GPTConfig:\n    # size of the model\n    n_layer: int = 4\n    n_head: int = 4\n    n_embd: int = 64\n    vocab_size: int = None\n    block_size: int = None\n\nclass NewGELU(nn.Module):\n    \"\"\"\n    Implementation of the GELU activation function currently in Google BERT repo (identical to OpenAI GPT).\n    Reference: Gaussian Error Linear Units (GELU) paper: https://arxiv.org/abs/1606.08415\n    \"\"\"\n    def forward(self, x):\n        return 0.5 * x * (1.0 + torch.tanh(math.sqrt(2.0 / math.pi) * (x + 0.044715 * torch.pow(x, 3.0))))\n\nclass CausalSelfAttention(nn.Module):\n    \"\"\"\n    A vanilla multi-head masked self-attention layer with a projection at the end.\n    It is possible to use torch.nn.MultiheadAttention here but I am including an\n    explicit implementation here to show that there is nothing too scary here.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.n_embd % config.n_head == 0\n        # key, query, value projections for all heads, but in a batch\n        self.c_attn = nn.Linear(config.n_embd, 3 * config.n_embd)\n        # output projection\n        self.c_proj = nn.Linear(config.n_embd, config.n_embd)\n        # causal mask to ensure that attention is only applied to the left in the input sequence\n        self.register_buffer(\"bias\", torch.tril(torch.ones(config.block_size, config.block_size))\n                                     .view(1, 1, config.block_size, config.block_size))\n        self.n_head = config.n_head\n        self.n_embd = config.n_embd\n\n    def forward(self, x):\n        B, T, C = x.size() # batch size, sequence length, embedding dimensionality (n_embd)\n\n        # calculate query, key, values for all heads in batch and move head forward to be the batch dim\n        q, k ,v  = self.c_attn(x).split(self.n_embd, dim=2)\n        k = k.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        q = q.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        v = v.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n\n        # causal self-attention; Self-attend: (B, nh, T, hs) x (B, nh, hs, T) -> (B, nh, T, T)\n        att = (q @ k.transpose(-2, -1)) * (1.0 / math.sqrt(k.size(-1)))\n        att = att.masked_fill(self.bias[:,:,:T,:T] == 0, float('-inf'))\n        att = F.softmax(att, dim=-1)\n        y = att @ v # (B, nh, T, T) x (B, nh, T, hs) -> (B, nh, T, hs)\n        y = y.transpose(1, 2).contiguous().view(B, T, C) # re-assemble all head outputs side by side\n\n        # output projection\n        y = self.c_proj(y)\n        return y\n\nclass Block(nn.Module):\n    \"\"\" an unassuming Transformer block \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.ln_1 = nn.LayerNorm(config.n_embd)\n        self.attn = CausalSelfAttention(config)\n        self.ln_2 = nn.LayerNorm(config.n_embd)\n        self.mlp = nn.ModuleDict(dict(\n            c_fc    = nn.Linear(config.n_embd, 4 * config.n_embd),\n            c_proj  = nn.Linear(4 * config.n_embd, config.n_embd),\n            act     = NewGELU(),\n        ))\n        m = self.mlp\n        self.mlpf = lambda x: m.c_proj(m.act(m.c_fc(x))) # MLP forward\n\n    def forward(self, x):\n        x = x + self.attn(self.ln_1(x))\n        x = x + self.mlpf(self.ln_2(x))\n        return x\n\nclass GPT(nn.Module):\n    \"\"\" GPT Language Model \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.block_size = config.block_size\n\n        self.transformer = nn.ModuleDict(dict(\n            wte = nn.Embedding(config.vocab_size, config.n_embd),\n            wpe = nn.Embedding(config.block_size, config.n_embd),\n            h = nn.ModuleList([Block(config) for _ in range(config.n_layer)]),\n            ln_f = nn.LayerNorm(config.n_embd),\n        ))\n        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n\n        # report number of parameters (note we don't count the decoder parameters in lm_head)\n        n_params = sum(p.numel() for p in self.transformer.parameters())\n        print(\"number of parameters: %.2fM\" % (n_params/1e6,))\n\n    def forward(self, idx, targets=None):\n        device = idx.device\n        b, t = idx.size()\n        assert t <= self.block_size, f\"Cannot forward sequence of length {t}, block size is only {self.block_size}\"\n        pos = torch.arange(0, t, dtype=torch.long, device=device).unsqueeze(0) # shape (1, t)\n\n        # forward the GPT model itself\n        tok_emb = self.transformer.wte(idx) # token embeddings of shape (b, t, n_embd)\n        pos_emb = self.transformer.wpe(pos) # position embeddings of shape (1, t, n_embd)\n        x = tok_emb + pos_emb\n        for block in self.transformer.h:\n            x = block(x)\n        x = self.transformer.ln_f(x)\n        logits = self.lm_head(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n    @torch.no_grad()\n    def generate(self, idx, max_new_tokens, temperature=1.0, do_sample=False, top_k=None):\n        \"\"\"\n        Take a conditioning sequence of indices idx (LongTensor of shape (b,t)) and complete\n        the sequence max_new_tokens times, feeding the predictions back into the model each time.\n        Most likely you'll want to make sure to be in model.eval() mode of operation for this.\n        \"\"\"\n        for _ in range(max_new_tokens):\n            # if the sequence context is growing too long we must crop it at block_size\n            idx_cond = idx if idx.size(1) <= self.block_size else idx[:, -self.block_size:]\n            # forward the model to get the logits for the index in the sequence\n            logits, _ = self(idx_cond)\n            # pluck the logits at the final step and scale by desired temperature\n            logits = logits[:, -1, :] / temperature\n            # optionally crop the logits to only the top k options\n            if top_k is not None:\n                v, _ = torch.topk(logits, top_k)\n                logits[logits < v[:, [-1]]] = -float('Inf')\n            # apply softmax to convert logits to (normalized) probabilities\n            probs = F.softmax(logits, dim=-1)\n            # either sample from the distribution or take the most likely element\n            if do_sample:\n                idx_next = torch.multinomial(probs, num_samples=1)\n            else:\n                _, idx_next = torch.topk(probs, k=1, dim=-1)\n            # append sampled index to the running sequence and continue\n            idx = torch.cat((idx, idx_next), dim=1)\n\n        return idx\n\n# -----------------------------------------------------------------------------\n# helper functions for evaluating and sampling from the model\n\ndef print_samples(num=10):\n    \"\"\" samples from the model and pretty prints the decoded samples \"\"\"\n    X_init = torch.zeros(num, 1, dtype=torch.long).to(args.device)\n    top_k = args.top_k if args.top_k != -1 else None\n    steps = train_dataset.get_output_length() - 1 # -1 because we already start with <START> token (index 0)\n    X_samp = model.generate(X_init, steps, top_k=top_k, do_sample=True).to('cpu')\n    train_samples, test_samples, new_samples = [], [], []\n    for i in range(X_samp.size(0)):\n        # get the i'th row of sampled integers, as python list\n        row = X_samp[i, 1:].tolist() # note: we need to crop out the first <START> token\n        # token 0 is the <STOP> token, so we crop the output sequence at that point\n        crop_index = row.index(0) if 0 in row else len(row)\n        row = row[:crop_index]\n        word_samp = train_dataset.decode(row)\n        # separately track samples that we have and have not seen before\n        if train_dataset.contains(word_samp):\n            train_samples.append(word_samp)\n        elif test_dataset.contains(word_samp):\n            test_samples.append(word_samp)\n        else:\n            new_samples.append(word_samp)\n    print('-'*80)\n    for lst, desc in [(train_samples, 'in train'), (test_samples, 'in test'), (new_samples, 'new')]:\n        print(f\"{len(lst)} samples that are {desc}:\")\n        for word in lst:\n            print(word)\n    print('-'*80)\n\n@torch.inference_mode()\ndef evaluate(model, dataset, batch_size=50, max_batches=None):\n    model.eval()\n    loader = DataLoader(dataset, shuffle=True, batch_size=batch_size, num_workers=0)\n    losses = []\n    for i, batch in enumerate(loader):\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n        logits, loss = model(X, Y)\n        losses.append(loss.item())\n        if max_batches is not None and i >= max_batches:\n            break\n    mean_loss = torch.tensor(losses).mean().item()\n    model.train() # reset model back to training mode\n    return mean_loss\n\n# -----------------------------------------------------------------------------\n# helper functions for creating the training and test Datasets that emit words\n\nclass CharDataset(Dataset):\n\n    def __init__(self, words, chars, max_word_length):\n        self.words = words\n        self.chars = chars\n        self.max_word_length = max_word_length\n        self.stoi = {ch:i+1 for i,ch in enumerate(chars)}\n        self.itos = {i:s for s,i in self.stoi.items()} # inverse mapping\n\n    def __len__(self):\n        return len(self.words)\n\n    def contains(self, word):\n        return word in self.words\n\n    def get_vocab_size(self):\n        return len(self.chars) + 1 # all the possible characters and special 0 token\n\n    def get_output_length(self):\n        return self.max_word_length + 1 # <START> token followed by words\n\n    def encode(self, word):\n        ix = torch.tensor([self.stoi[w] for w in word], dtype=torch.long)\n        return ix\n\n    def decode(self, ix):\n        word = ''.join(self.itos[i] for i in ix)\n        return word\n\n    def __getitem__(self, idx):\n        word = self.words[idx]\n        ix = self.encode(word)\n        x = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        y = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        x[1:1+len(ix)] = ix\n        y[:len(ix)] = ix\n        y[len(ix)+1:] = -1 # index -1 will mask the loss at the inactive locations\n        return x, y\n\ndef create_datasets(input_file):\n\n    # preprocessing of the input text file\n    with open(input_file, 'r') as f:\n        data = f.read()\n    words = data.splitlines()\n    words = [w.strip() for w in words] # get rid of any leading or trailing white space\n    words = [w for w in words if w] # get rid of any empty strings\n    chars = sorted(list(set(''.join(words)))) # all the possible characters\n    max_word_length = max(len(w) for w in words)\n    print(f\"number of examples in the dataset: {len(words)}\")\n    print(f\"max word length: {max_word_length}\")\n    print(f\"number of unique characters in the vocabulary: {len(chars)}\")\n    print(\"vocabulary:\")\n    print(''.join(chars))\n\n    # partition the input data into a training and the test set\n    test_set_size = min(1000, int(len(words) * 0.1)) # 10% of the training set, or up to 1000 examples\n    rp = torch.randperm(len(words)).tolist()\n    train_words = [words[i] for i in rp[:-test_set_size]]\n    test_words = [words[i] for i in rp[-test_set_size:]]\n    print(f\"split up the dataset into {len(train_words)} training examples and {len(test_words)} test examples\")\n\n    # wrap in dataset objects\n    train_dataset = CharDataset(train_words, chars, max_word_length)\n    test_dataset = CharDataset(test_words, chars, max_word_length)\n\n    return train_dataset, test_dataset\n\nclass InfiniteDataLoader:\n    \"\"\"\n    this is really hacky and I'm not proud of it, but there doesn't seem to be\n    a better way in PyTorch to just create an infinite dataloader?\n    \"\"\"\n\n    def __init__(self, dataset, **kwargs):\n        train_sampler = torch.utils.data.RandomSampler(dataset, replacement=True, num_samples=int(1e10))\n        self.train_loader = DataLoader(dataset, sampler=train_sampler, **kwargs)\n        self.data_iter = iter(self.train_loader)\n\n    def next(self):\n        try:\n            batch = next(self.data_iter)\n        except StopIteration: # this will technically only happen after 1e10 samples... (i.e. basically never)\n            self.data_iter = iter(self.train_loader)\n            batch = next(self.data_iter)\n        return batch\n\n# -----------------------------------------------------------------------------\nif __name__ == '__main__':\n\n    # parse command line args\n    parser = argparse.ArgumentParser(description=\"Make More\")\n    # system/input/output\n    parser.add_argument('--input-file', '-i', type=str, default='names.txt', help=\"input file with things one per line\")\n    parser.add_argument('--work-dir', '-o', type=str, default='out', help=\"output working directory\")\n    parser.add_argument('--resume', action='store_true', help=\"when this flag is used, we will resume optimization from existing model in the workdir\")\n    parser.add_argument('--sample-only', action='store_true', help=\"just sample from the model and quit, don't train\")\n    parser.add_argument('--num-workers', '-n', type=int, default=4, help=\"number of data workers for both train/test\")\n    parser.add_argument('--max-steps', type=int, default=-1, help=\"max number of optimization steps to run for, or -1 for infinite.\")\n    parser.add_argument('--device', type=str, default='cpu', help=\"device to use for compute, examples: cpu|cuda|cuda:2|mps\")\n    parser.add_argument('--seed', type=int, default=3407, help=\"seed\")\n    # sampling\n    parser.add_argument('--top-k', type=int, default=-1, help=\"top-k for sampling, -1 means no top-k\")\n    # model\n    parser.add_argument('--n-layer', type=int, default=4, help=\"number of layers in the transformer\")\n    parser.add_argument('--n-head', type=int, default=4, help=\"number of heads in the transformer\")\n    parser.add_argument('--n-embd', type=int, default=64, help=\"number of feature channels in the transformer\")\n    # optimization\n    parser.add_argument('--batch-size', '-b', type=int, default=32, help=\"batch size during optimization\")\n    parser.add_argument('--learning-rate', '-l', type=float, default=5e-4, help=\"learning rate\")\n    parser.add_argument('--weight-decay', '-w', type=float, default=0.01, help=\"weight decay\")\n    args = parser.parse_args()\n    print(vars(args))\n\n    # system inits\n    torch.manual_seed(args.seed)\n    torch.cuda.manual_seed_all(args.seed)\n    os.makedirs(args.work_dir, exist_ok=True)\n    writer = SummaryWriter(log_dir=args.work_dir)\n\n    # init datasets\n    train_dataset, test_dataset = create_datasets(args.input_file)\n    vocab_size = train_dataset.get_vocab_size()\n    block_size = train_dataset.get_output_length()\n    print(f\"dataset determined that: {vocab_size=}, {block_size=}\")\n\n    # init model\n    config = GPTConfig(vocab_size=vocab_size, block_size=block_size,\n                       n_layer=args.n_layer, n_head=args.n_head, n_embd=args.n_embd)\n    model = GPT(config)\n    model.to(args.device)\n    print(f\"model #params: {sum(p.numel() for p in model.parameters())}\")\n    if args.resume or args.sample_only: # note: if we sample-only then we also assume we are resuming\n        print(\"resuming from existing model in the workdir\")\n        model.load_state_dict(torch.load(os.path.join(args.work_dir, 'model.pt')))\n    if args.sample_only:\n        print_samples(num=50)\n        sys.exit()\n\n    # init optimizer\n    optimizer = torch.optim.AdamW(model.parameters(), lr=args.learning_rate, weight_decay=args.weight_decay, betas=(0.9, 0.99), eps=1e-8)\n\n    # init dataloader\n    batch_loader = InfiniteDataLoader(train_dataset, batch_size=args.batch_size, pin_memory=True, num_workers=args.num_workers)\n\n    # training loop\n    best_loss = None\n    step = 0\n    while True:\n\n        t0 = time.time()\n\n        # get the next batch, ship to device, and unpack it to input and target\n        batch = batch_loader.next()\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n\n        # feed into the model\n        logits, loss = model(X, Y)\n\n        # calculate the gradient, clip it, update the weights\n        model.zero_grad(set_to_none=True)\n        loss.backward()\n        optimizer.step()\n        if args.device.startswith('cuda'):\n            torch.cuda.synchronize()\n        t1 = time.time()\n\n        # logging\n        if step % 10 == 0:\n            print(f\"step {step} | loss {loss.item():.4f} | step time {(t1-t0)*1000:.2f}ms\")\n\n        # evaluate the model\n        if step > 0 and step % 500 == 0:\n            train_loss = evaluate(model, train_dataset, batch_size=100, max_batches=10)\n            test_loss  = evaluate(model, test_dataset,  batch_size=100, max_batches=10)\n            writer.add_scalar(\"Loss/train\", train_loss, step)\n            writer.add_scalar(\"Loss/test\", test_loss, step)\n            writer.flush()\n            print(f\"step {step} train loss: {train_loss} test loss: {test_loss}\")\n            # save the model to disk if it has improved\n            if best_loss is None or test_loss < best_loss:\n                out_path = os.path.join(args.work_dir, \"model.pt\")\n                print(f\"test loss {test_loss} is the best so far, saving model to {out_path}\")\n                torch.save(model.state_dict(), out_path)\n                best_loss = test_loss\n\n        # sample from the model\n        if step > 0 and step % 200 == 0:\n            print_samples(num=10)\n\n        step += 1\n        # termination conditions\n        if args.max_steps >= 0 and step >= args.max_steps:\n            break\n\n", "previous_id": "d4ede452083ded078103231ec6ea9176f343a7d7", "new_code_file": "\"\"\"\nyou give this script some words (one per line) and it will generate more things like it.\nuses super state of the art Transformer AI tech\nthis code is intended to be super hackable. tune it to your needs.\n\nChanges from minGPT:\n- I removed the from_pretrained function where we init with GPT2 weights\n- I removed dropout layers because the models we train here are small,\n  it's not necessary to understand at this stage and at this scale.\n- I removed weight decay and all of the complexity around what parameters are\n  and are not weight decayed. I don't believe this should make a massive\n  difference at the scale that we operate on here.\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport math\nimport argparse\nfrom dataclasses import dataclass\nfrom typing import List\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\nfrom torch.utils.data import Dataset\nfrom torch.utils.data.dataloader import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\n# -----------------------------------------------------------------------------\n# GPT model definition\n\n@dataclass\nclass GPTConfig:\n    # size of the model\n    n_layer: int = 4\n    n_head: int = 4\n    n_embd: int = 64\n    vocab_size: int = None\n    block_size: int = None\n\nclass NewGELU(nn.Module):\n    \"\"\"\n    Implementation of the GELU activation function currently in Google BERT repo (identical to OpenAI GPT).\n    Reference: Gaussian Error Linear Units (GELU) paper: https://arxiv.org/abs/1606.08415\n    \"\"\"\n    def forward(self, x):\n        return 0.5 * x * (1.0 + torch.tanh(math.sqrt(2.0 / math.pi) * (x + 0.044715 * torch.pow(x, 3.0))))\n\nclass CausalSelfAttention(nn.Module):\n    \"\"\"\n    A vanilla multi-head masked self-attention layer with a projection at the end.\n    It is possible to use torch.nn.MultiheadAttention here but I am including an\n    explicit implementation here to show that there is nothing too scary here.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.n_embd % config.n_head == 0\n        # key, query, value projections for all heads, but in a batch\n        self.c_attn = nn.Linear(config.n_embd, 3 * config.n_embd)\n        # output projection\n        self.c_proj = nn.Linear(config.n_embd, config.n_embd)\n        # causal mask to ensure that attention is only applied to the left in the input sequence\n        self.register_buffer(\"bias\", torch.tril(torch.ones(config.block_size, config.block_size))\n                                     .view(1, 1, config.block_size, config.block_size))\n        self.n_head = config.n_head\n        self.n_embd = config.n_embd\n\n    def forward(self, x):\n        B, T, C = x.size() # batch size, sequence length, embedding dimensionality (n_embd)\n\n        # calculate query, key, values for all heads in batch and move head forward to be the batch dim\n        q, k ,v  = self.c_attn(x).split(self.n_embd, dim=2)\n        k = k.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        q = q.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        v = v.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n\n        # causal self-attention; Self-attend: (B, nh, T, hs) x (B, nh, hs, T) -> (B, nh, T, T)\n        att = (q @ k.transpose(-2, -1)) * (1.0 / math.sqrt(k.size(-1)))\n        att = att.masked_fill(self.bias[:,:,:T,:T] == 0, float('-inf'))\n        att = F.softmax(att, dim=-1)\n        y = att @ v # (B, nh, T, T) x (B, nh, T, hs) -> (B, nh, T, hs)\n        y = y.transpose(1, 2).contiguous().view(B, T, C) # re-assemble all head outputs side by side\n\n        # output projection\n        y = self.c_proj(y)\n        return y\n\nclass Block(nn.Module):\n    \"\"\" an unassuming Transformer block \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.ln_1 = nn.LayerNorm(config.n_embd)\n        self.attn = CausalSelfAttention(config)\n        self.ln_2 = nn.LayerNorm(config.n_embd)\n        self.mlp = nn.ModuleDict(dict(\n            c_fc    = nn.Linear(config.n_embd, 4 * config.n_embd),\n            c_proj  = nn.Linear(4 * config.n_embd, config.n_embd),\n            act     = NewGELU(),\n        ))\n        m = self.mlp\n        self.mlpf = lambda x: m.c_proj(m.act(m.c_fc(x))) # MLP forward\n\n    def forward(self, x):\n        x = x + self.attn(self.ln_1(x))\n        x = x + self.mlpf(self.ln_2(x))\n        return x\n\nclass GPT(nn.Module):\n    \"\"\" GPT Language Model \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.block_size = config.block_size\n\n        self.transformer = nn.ModuleDict(dict(\n            wte = nn.Embedding(config.vocab_size, config.n_embd),\n            wpe = nn.Embedding(config.block_size, config.n_embd),\n            h = nn.ModuleList([Block(config) for _ in range(config.n_layer)]),\n            ln_f = nn.LayerNorm(config.n_embd),\n        ))\n        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n\n        # report number of parameters (note we don't count the decoder parameters in lm_head)\n        n_params = sum(p.numel() for p in self.transformer.parameters())\n        print(\"number of parameters: %.2fM\" % (n_params/1e6,))\n\n    def forward(self, idx, targets=None):\n        device = idx.device\n        b, t = idx.size()\n        assert t <= self.block_size, f\"Cannot forward sequence of length {t}, block size is only {self.block_size}\"\n        pos = torch.arange(0, t, dtype=torch.long, device=device).unsqueeze(0) # shape (1, t)\n\n        # forward the GPT model itself\n        tok_emb = self.transformer.wte(idx) # token embeddings of shape (b, t, n_embd)\n        pos_emb = self.transformer.wpe(pos) # position embeddings of shape (1, t, n_embd)\n        x = tok_emb + pos_emb\n        for block in self.transformer.h:\n            x = block(x)\n        x = self.transformer.ln_f(x)\n        logits = self.lm_head(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n    @torch.no_grad()\n    def generate(self, idx, max_new_tokens, temperature=1.0, do_sample=False, top_k=None):\n        \"\"\"\n        Take a conditioning sequence of indices idx (LongTensor of shape (b,t)) and complete\n        the sequence max_new_tokens times, feeding the predictions back into the model each time.\n        Most likely you'll want to make sure to be in model.eval() mode of operation for this.\n        \"\"\"\n        for _ in range(max_new_tokens):\n            # if the sequence context is growing too long we must crop it at block_size\n            idx_cond = idx if idx.size(1) <= self.block_size else idx[:, -self.block_size:]\n            # forward the model to get the logits for the index in the sequence\n            logits, _ = self(idx_cond)\n            # pluck the logits at the final step and scale by desired temperature\n            logits = logits[:, -1, :] / temperature\n            # optionally crop the logits to only the top k options\n            if top_k is not None:\n                v, _ = torch.topk(logits, top_k)\n                logits[logits < v[:, [-1]]] = -float('Inf')\n            # apply softmax to convert logits to (normalized) probabilities\n            probs = F.softmax(logits, dim=-1)\n            # either sample from the distribution or take the most likely element\n            if do_sample:\n                idx_next = torch.multinomial(probs, num_samples=1)\n            else:\n                _, idx_next = torch.topk(probs, k=1, dim=-1)\n            # append sampled index to the running sequence and continue\n            idx = torch.cat((idx, idx_next), dim=1)\n\n        return idx\n\n# -----------------------------------------------------------------------------\n# helper functions for evaluating and sampling from the model\n\ndef print_samples(num=10):\n    \"\"\" samples from the model and pretty prints the decoded samples \"\"\"\n    X_init = torch.zeros(num, 1, dtype=torch.long).to(args.device)\n    top_k = args.top_k if args.top_k != -1 else None\n    steps = train_dataset.get_output_length() - 1 # -1 because we already start with <START> token (index 0)\n    X_samp = model.generate(X_init, steps, top_k=top_k, do_sample=True).to('cpu')\n    train_samples, test_samples, new_samples = [], [], []\n    for i in range(X_samp.size(0)):\n        # get the i'th row of sampled integers, as python list\n        row = X_samp[i, 1:].tolist() # note: we need to crop out the first <START> token\n        # token 0 is the <STOP> token, so we crop the output sequence at that point\n        crop_index = row.index(0) if 0 in row else len(row)\n        row = row[:crop_index]\n        word_samp = train_dataset.decode(row)\n        # separately track samples that we have and have not seen before\n        if train_dataset.contains(word_samp):\n            train_samples.append(word_samp)\n        elif test_dataset.contains(word_samp):\n            test_samples.append(word_samp)\n        else:\n            new_samples.append(word_samp)\n    print('-'*80)\n    for lst, desc in [(train_samples, 'in train'), (test_samples, 'in test'), (new_samples, 'new')]:\n        print(f\"{len(lst)} samples that are {desc}:\")\n        for word in lst:\n            print(word)\n    print('-'*80)\n\n@torch.inference_mode()\ndef evaluate(model, dataset, batch_size=50, max_batches=None):\n    model.eval()\n    loader = DataLoader(dataset, shuffle=True, batch_size=batch_size, num_workers=0)\n    losses = []\n    for i, batch in enumerate(loader):\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n        logits, loss = model(X, Y)\n        losses.append(loss.item())\n        if max_batches is not None and i >= max_batches:\n            break\n    mean_loss = torch.tensor(losses).mean().item()\n    model.train() # reset model back to training mode\n    return mean_loss\n\n# -----------------------------------------------------------------------------\n# helper functions for creating the training and test Datasets that emit words\n\nclass CharDataset(Dataset):\n\n    def __init__(self, words, chars, max_word_length):\n        self.words = words\n        self.chars = chars\n        self.max_word_length = max_word_length\n        self.stoi = {ch:i+1 for i,ch in enumerate(chars)}\n        self.itos = {i:s for s,i in self.stoi.items()} # inverse mapping\n\n    def __len__(self):\n        return len(self.words)\n\n    def contains(self, word):\n        return word in self.words\n\n    def get_vocab_size(self):\n        return len(self.chars) + 1 # all the possible characters and special 0 token\n\n    def get_output_length(self):\n        return self.max_word_length + 1 # <START> token followed by words\n\n    def encode(self, word):\n        ix = torch.tensor([self.stoi[w] for w in word], dtype=torch.long)\n        return ix\n\n    def decode(self, ix):\n        word = ''.join(self.itos[i] for i in ix)\n        return word\n\n    def __getitem__(self, idx):\n        word = self.words[idx]\n        ix = self.encode(word)\n        x = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        y = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        x[1:1+len(ix)] = ix\n        y[:len(ix)] = ix\n        y[len(ix)+1:] = -1 # index -1 will mask the loss at the inactive locations\n        return x, y\n\ndef create_datasets(input_file):\n\n    # preprocessing of the input text file\n    with open(input_file, 'r') as f:\n        data = f.read()\n    words = data.splitlines()\n    words = [w.strip() for w in words] # get rid of any leading or trailing white space\n    words = [w for w in words if w] # get rid of any empty strings\n    chars = sorted(list(set(''.join(words)))) # all the possible characters\n    max_word_length = max(len(w) for w in words)\n    print(f\"number of examples in the dataset: {len(words)}\")\n    print(f\"max word length: {max_word_length}\")\n    print(f\"number of unique characters in the vocabulary: {len(chars)}\")\n    print(\"vocabulary:\")\n    print(''.join(chars))\n\n    # partition the input data into a training and the test set\n    test_set_size = min(1000, int(len(words) * 0.1)) # 10% of the training set, or up to 1000 examples\n    rp = torch.randperm(len(words)).tolist()\n    train_words = [words[i] for i in rp[:-test_set_size]]\n    test_words = [words[i] for i in rp[-test_set_size:]]\n    print(f\"split up the dataset into {len(train_words)} training examples and {len(test_words)} test examples\")\n\n    # wrap in dataset objects\n    train_dataset = CharDataset(train_words, chars, max_word_length)\n    test_dataset = CharDataset(test_words, chars, max_word_length)\n\n    return train_dataset, test_dataset\n\nclass InfiniteDataLoader:\n    \"\"\"\n    this is really hacky and I'm not proud of it, but there doesn't seem to be\n    a better way in PyTorch to just create an infinite dataloader?\n    \"\"\"\n\n    def __init__(self, dataset, **kwargs):\n        train_sampler = torch.utils.data.RandomSampler(dataset, replacement=True, num_samples=int(1e10))\n        self.train_loader = DataLoader(dataset, sampler=train_sampler, **kwargs)\n        self.data_iter = iter(self.train_loader)\n\n    def next(self):\n        try:\n            batch = next(self.data_iter)\n        except StopIteration: # this will technically only happen after 1e10 samples... (i.e. basically never)\n            self.data_iter = iter(self.train_loader)\n            batch = next(self.data_iter)\n        return batch\n\n# -----------------------------------------------------------------------------\nif __name__ == '__main__':\n\n    # parse command line args\n    parser = argparse.ArgumentParser(description=\"Make More\")\n    # system/input/output\n    parser.add_argument('--input-file', '-i', type=str, default='names.txt', help=\"input file with things one per line\")\n    parser.add_argument('--work-dir', '-o', type=str, default='out', help=\"output working directory\")\n    parser.add_argument('--resume', action='store_true', help=\"when this flag is used, we will resume optimization from existing model in the workdir\")\n    parser.add_argument('--sample-only', action='store_true', help=\"just sample from the model and quit, don't train\")\n    parser.add_argument('--num-workers', '-n', type=int, default=4, help=\"number of data workers for both train/test\")\n    parser.add_argument('--max-steps', type=int, default=-1, help=\"max number of optimization steps to run for, or -1 for infinite.\")\n    parser.add_argument('--device', type=str, default='cpu', help=\"device to use for compute, examples: cpu|cuda|cuda:2|mps\")\n    parser.add_argument('--seed', type=int, default=3407, help=\"seed\")\n    # sampling\n    parser.add_argument('--top-k', type=int, default=-1, help=\"top-k for sampling, -1 means no top-k\")\n    # model\n    parser.add_argument('--n-layer', type=int, default=4, help=\"number of layers in the transformer\")\n    parser.add_argument('--n-head', type=int, default=4, help=\"number of heads in the transformer\")\n    parser.add_argument('--n-embd', type=int, default=64, help=\"number of feature channels in the transformer\")\n    # optimization\n    parser.add_argument('--batch-size', '-b', type=int, default=32, help=\"batch size during optimization\")\n    parser.add_argument('--learning-rate', '-l', type=float, default=5e-4, help=\"learning rate\")\n    parser.add_argument('--weight-decay', '-w', type=float, default=0.01, help=\"weight decay\")\n    args = parser.parse_args()\n    print(vars(args))\n\n    # system inits\n    torch.manual_seed(args.seed)\n    torch.cuda.manual_seed_all(args.seed)\n    os.makedirs(args.work_dir, exist_ok=True)\n    writer = SummaryWriter(log_dir=args.work_dir)\n\n    # init datasets\n    train_dataset, test_dataset = create_datasets(args.input_file)\n    vocab_size = train_dataset.get_vocab_size()\n    block_size = train_dataset.get_output_length()\n    print(f\"dataset determined that: {vocab_size=}, {block_size=}\")\n\n    # init model\n    config = GPTConfig(vocab_size=vocab_size, block_size=block_size,\n                       n_layer=args.n_layer, n_head=args.n_head, n_embd=args.n_embd)\n    model = GPT(config)\n    model.to(args.device)\n    print(f\"model #params: {sum(p.numel() for p in model.parameters())}\")\n    if args.resume or args.sample_only: # note: if we sample-only then we also assume we are resuming\n        print(\"resuming from existing model in the workdir\")\n        model.load_state_dict(torch.load(os.path.join(args.work_dir, 'model.pt')))\n    if args.sample_only:\n        print_samples(num=50)\n        sys.exit()\n\n    # init optimizer\n    optimizer = torch.optim.AdamW(model.parameters(), lr=args.learning_rate, weight_decay=args.weight_decay, betas=(0.9, 0.99), eps=1e-8)\n\n    # init dataloader\n    batch_loader = InfiniteDataLoader(train_dataset, batch_size=args.batch_size, pin_memory=True, num_workers=args.num_workers)\n\n    # training loop\n    best_loss = None\n    step = 0\n    while True:\n\n        t0 = time.time()\n\n        # get the next batch, ship to device, and unpack it to input and target\n        batch = batch_loader.next()\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n\n        # feed into the model\n        logits, loss = model(X, Y)\n\n        # calculate the gradient, update the weights\n        model.zero_grad(set_to_none=True)\n        loss.backward()\n        optimizer.step()\n\n        # wait for all CUDA work on the GPU to finish then calculate iteration time taken\n        if args.device.startswith('cuda'):\n            torch.cuda.synchronize()\n        t1 = time.time()\n\n        # logging\n        if step % 10 == 0:\n            print(f\"step {step} | loss {loss.item():.4f} | step time {(t1-t0)*1000:.2f}ms\")\n\n        # evaluate the model\n        if step > 0 and step % 500 == 0:\n            train_loss = evaluate(model, train_dataset, batch_size=100, max_batches=10)\n            test_loss  = evaluate(model, test_dataset,  batch_size=100, max_batches=10)\n            writer.add_scalar(\"Loss/train\", train_loss, step)\n            writer.add_scalar(\"Loss/test\", test_loss, step)\n            writer.flush()\n            print(f\"step {step} train loss: {train_loss} test loss: {test_loss}\")\n            # save the model to disk if it has improved\n            if best_loss is None or test_loss < best_loss:\n                out_path = os.path.join(args.work_dir, \"model.pt\")\n                print(f\"test loss {test_loss} is the best so far, saving model to {out_path}\")\n                torch.save(model.state_dict(), out_path)\n                best_loss = test_loss\n\n        # sample from the model\n        if step > 0 and step % 200 == 0:\n            print_samples(num=10)\n\n        step += 1\n        # termination conditions\n        if args.max_steps >= 0 and step >= args.max_steps:\n            break\n\n", "diff": "@@ -389,10 +389,12 @@ def next(self):\n         # feed into the model\n         logits, loss = model(X, Y)\n \n-        # calculate the gradient, clip it, update the weights\n+        # calculate the gradient, update the weights\n         model.zero_grad(set_to_none=True)\n         loss.backward()\n         optimizer.step()\n+\n+        # wait for all CUDA work on the GPU to finish then calculate iteration time taken\n         if args.device.startswith('cuda'):\n             torch.cuda.synchronize()\n         t1 = time.time()", "status": "modified"}, {"commit_id": "d4ede452083ded078103231ec6ea9176f343a7d7", "commit_message": "implementation of InfiniteDataLoader sad", "relative_path": "makemore.py", "previous_code_file": "\"\"\"\nyou give this script some words (one per line) and it will generate more things like it.\nuses super state of the art Transformer AI tech\nthis code is intended to be super hackable. tune it to your needs.\n\nChanges from minGPT:\n- I removed the from_pretrained function where we init with GPT2 weights\n- I removed dropout layers because the models we train here are small,\n  it's not necessary to understand at this stage and at this scale.\n- I removed weight decay and all of the complexity around what parameters are\n  and are not weight decayed. I don't believe this should make a massive\n  difference at the scale that we operate on here.\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport math\nimport argparse\nfrom dataclasses import dataclass\nfrom typing import List\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\nfrom torch.utils.data import Dataset\nfrom torch.utils.data.dataloader import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\n# -----------------------------------------------------------------------------\n# GPT model definition\n\n@dataclass\nclass GPTConfig:\n    # size of the model\n    n_layer: int = 4\n    n_head: int = 4\n    n_embd: int = 64\n    vocab_size: int = None\n    block_size: int = None\n\nclass NewGELU(nn.Module):\n    \"\"\"\n    Implementation of the GELU activation function currently in Google BERT repo (identical to OpenAI GPT).\n    Reference: Gaussian Error Linear Units (GELU) paper: https://arxiv.org/abs/1606.08415\n    \"\"\"\n    def forward(self, x):\n        return 0.5 * x * (1.0 + torch.tanh(math.sqrt(2.0 / math.pi) * (x + 0.044715 * torch.pow(x, 3.0))))\n\nclass CausalSelfAttention(nn.Module):\n    \"\"\"\n    A vanilla multi-head masked self-attention layer with a projection at the end.\n    It is possible to use torch.nn.MultiheadAttention here but I am including an\n    explicit implementation here to show that there is nothing too scary here.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.n_embd % config.n_head == 0\n        # key, query, value projections for all heads, but in a batch\n        self.c_attn = nn.Linear(config.n_embd, 3 * config.n_embd)\n        # output projection\n        self.c_proj = nn.Linear(config.n_embd, config.n_embd)\n        # causal mask to ensure that attention is only applied to the left in the input sequence\n        self.register_buffer(\"bias\", torch.tril(torch.ones(config.block_size, config.block_size))\n                                     .view(1, 1, config.block_size, config.block_size))\n        self.n_head = config.n_head\n        self.n_embd = config.n_embd\n\n    def forward(self, x):\n        B, T, C = x.size() # batch size, sequence length, embedding dimensionality (n_embd)\n\n        # calculate query, key, values for all heads in batch and move head forward to be the batch dim\n        q, k ,v  = self.c_attn(x).split(self.n_embd, dim=2)\n        k = k.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        q = q.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        v = v.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n\n        # causal self-attention; Self-attend: (B, nh, T, hs) x (B, nh, hs, T) -> (B, nh, T, T)\n        att = (q @ k.transpose(-2, -1)) * (1.0 / math.sqrt(k.size(-1)))\n        att = att.masked_fill(self.bias[:,:,:T,:T] == 0, float('-inf'))\n        att = F.softmax(att, dim=-1)\n        y = att @ v # (B, nh, T, T) x (B, nh, T, hs) -> (B, nh, T, hs)\n        y = y.transpose(1, 2).contiguous().view(B, T, C) # re-assemble all head outputs side by side\n\n        # output projection\n        y = self.c_proj(y)\n        return y\n\nclass Block(nn.Module):\n    \"\"\" an unassuming Transformer block \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.ln_1 = nn.LayerNorm(config.n_embd)\n        self.attn = CausalSelfAttention(config)\n        self.ln_2 = nn.LayerNorm(config.n_embd)\n        self.mlp = nn.ModuleDict(dict(\n            c_fc    = nn.Linear(config.n_embd, 4 * config.n_embd),\n            c_proj  = nn.Linear(4 * config.n_embd, config.n_embd),\n            act     = NewGELU(),\n        ))\n        m = self.mlp\n        self.mlpf = lambda x: m.c_proj(m.act(m.c_fc(x))) # MLP forward\n\n    def forward(self, x):\n        x = x + self.attn(self.ln_1(x))\n        x = x + self.mlpf(self.ln_2(x))\n        return x\n\nclass GPT(nn.Module):\n    \"\"\" GPT Language Model \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.block_size = config.block_size\n\n        self.transformer = nn.ModuleDict(dict(\n            wte = nn.Embedding(config.vocab_size, config.n_embd),\n            wpe = nn.Embedding(config.block_size, config.n_embd),\n            h = nn.ModuleList([Block(config) for _ in range(config.n_layer)]),\n            ln_f = nn.LayerNorm(config.n_embd),\n        ))\n        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n\n        # report number of parameters (note we don't count the decoder parameters in lm_head)\n        n_params = sum(p.numel() for p in self.transformer.parameters())\n        print(\"number of parameters: %.2fM\" % (n_params/1e6,))\n\n    def forward(self, idx, targets=None):\n        device = idx.device\n        b, t = idx.size()\n        assert t <= self.block_size, f\"Cannot forward sequence of length {t}, block size is only {self.block_size}\"\n        pos = torch.arange(0, t, dtype=torch.long, device=device).unsqueeze(0) # shape (1, t)\n\n        # forward the GPT model itself\n        tok_emb = self.transformer.wte(idx) # token embeddings of shape (b, t, n_embd)\n        pos_emb = self.transformer.wpe(pos) # position embeddings of shape (1, t, n_embd)\n        x = tok_emb + pos_emb\n        for block in self.transformer.h:\n            x = block(x)\n        x = self.transformer.ln_f(x)\n        logits = self.lm_head(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n    @torch.no_grad()\n    def generate(self, idx, max_new_tokens, temperature=1.0, do_sample=False, top_k=None):\n        \"\"\"\n        Take a conditioning sequence of indices idx (LongTensor of shape (b,t)) and complete\n        the sequence max_new_tokens times, feeding the predictions back into the model each time.\n        Most likely you'll want to make sure to be in model.eval() mode of operation for this.\n        \"\"\"\n        for _ in range(max_new_tokens):\n            # if the sequence context is growing too long we must crop it at block_size\n            idx_cond = idx if idx.size(1) <= self.block_size else idx[:, -self.block_size:]\n            # forward the model to get the logits for the index in the sequence\n            logits, _ = self(idx_cond)\n            # pluck the logits at the final step and scale by desired temperature\n            logits = logits[:, -1, :] / temperature\n            # optionally crop the logits to only the top k options\n            if top_k is not None:\n                v, _ = torch.topk(logits, top_k)\n                logits[logits < v[:, [-1]]] = -float('Inf')\n            # apply softmax to convert logits to (normalized) probabilities\n            probs = F.softmax(logits, dim=-1)\n            # either sample from the distribution or take the most likely element\n            if do_sample:\n                idx_next = torch.multinomial(probs, num_samples=1)\n            else:\n                _, idx_next = torch.topk(probs, k=1, dim=-1)\n            # append sampled index to the running sequence and continue\n            idx = torch.cat((idx, idx_next), dim=1)\n\n        return idx\n\n# -----------------------------------------------------------------------------\n# helper functions for evaluating and sampling from the model\n\ndef print_samples(num=10):\n    \"\"\" samples from the model and pretty prints the decoded samples \"\"\"\n    X_init = torch.zeros(num, 1, dtype=torch.long).to(args.device)\n    top_k = args.top_k if args.top_k != -1 else None\n    steps = train_dataset.get_output_length() - 1 # -1 because we already start with <START> token (index 0)\n    X_samp = model.generate(X_init, steps, top_k=top_k, do_sample=True).to('cpu')\n    train_samples, test_samples, new_samples = [], [], []\n    for i in range(X_samp.size(0)):\n        # get the i'th row of sampled integers, as python list\n        row = X_samp[i, 1:].tolist() # note: we need to crop out the first <START> token\n        # token 0 is the <STOP> token, so we crop the output sequence at that point\n        crop_index = row.index(0) if 0 in row else len(row)\n        row = row[:crop_index]\n        word_samp = train_dataset.decode(row)\n        # separately track samples that we have and have not seen before\n        if train_dataset.contains(word_samp):\n            train_samples.append(word_samp)\n        elif test_dataset.contains(word_samp):\n            test_samples.append(word_samp)\n        else:\n            new_samples.append(word_samp)\n    print('-'*80)\n    for lst, desc in [(train_samples, 'in train'), (test_samples, 'in test'), (new_samples, 'new')]:\n        print(f\"{len(lst)} samples that are {desc}:\")\n        for word in lst:\n            print(word)\n    print('-'*80)\n\n@torch.inference_mode()\ndef evaluate(model, dataset, batch_size=50, max_batches=None):\n    model.eval()\n    loader = DataLoader(dataset, shuffle=True, batch_size=batch_size, num_workers=0)\n    losses = []\n    for i, batch in enumerate(loader):\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n        logits, loss = model(X, Y)\n        losses.append(loss.item())\n        if max_batches is not None and i >= max_batches:\n            break\n    mean_loss = torch.tensor(losses).mean().item()\n    model.train() # reset model back to training mode\n    return mean_loss\n\n# -----------------------------------------------------------------------------\n# helper functions for creating the training and test Datasets that emit words\n\nclass CharDataset(Dataset):\n\n    def __init__(self, words, chars, max_word_length):\n        self.words = words\n        self.chars = chars\n        self.max_word_length = max_word_length\n        self.stoi = {ch:i+1 for i,ch in enumerate(chars)}\n        self.itos = {i:s for s,i in self.stoi.items()} # inverse mapping\n\n    def __len__(self):\n        return len(self.words)\n\n    def contains(self, word):\n        return word in self.words\n\n    def get_vocab_size(self):\n        return len(self.chars) + 1 # all the possible characters and special 0 token\n\n    def get_output_length(self):\n        return self.max_word_length + 1 # <START> token followed by words\n\n    def encode(self, word):\n        ix = torch.tensor([self.stoi[w] for w in word], dtype=torch.long)\n        return ix\n\n    def decode(self, ix):\n        word = ''.join(self.itos[i] for i in ix)\n        return word\n\n    def __getitem__(self, idx):\n        word = self.words[idx]\n        ix = self.encode(word)\n        x = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        y = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        x[1:1+len(ix)] = ix\n        y[:len(ix)] = ix\n        y[len(ix)+1:] = -1 # index -1 will mask the loss at the inactive locations\n        return x, y\n\ndef create_datasets(input_file):\n\n    # preprocessing of the input text file\n    with open(input_file, 'r') as f:\n        data = f.read()\n    words = data.splitlines()\n    words = [w.strip() for w in words] # get rid of any leading or trailing white space\n    words = [w for w in words if w] # get rid of any empty strings\n    chars = sorted(list(set(''.join(words)))) # all the possible characters\n    max_word_length = max(len(w) for w in words)\n    print(f\"number of examples in the dataset: {len(words)}\")\n    print(f\"max word length: {max_word_length}\")\n    print(f\"number of unique characters in the vocabulary: {len(chars)}\")\n    print(\"vocabulary:\")\n    print(''.join(chars))\n\n    # partition the input data into a training and the test set\n    test_set_size = min(1000, int(len(words) * 0.1)) # 10% of the training set, or up to 1000 examples\n    rp = torch.randperm(len(words)).tolist()\n    train_words = [words[i] for i in rp[:-test_set_size]]\n    test_words = [words[i] for i in rp[-test_set_size:]]\n    print(f\"split up the dataset into {len(train_words)} training examples and {len(test_words)} test examples\")\n\n    # wrap in dataset objects\n    train_dataset = CharDataset(train_words, chars, max_word_length)\n    test_dataset = CharDataset(test_words, chars, max_word_length)\n\n    return train_dataset, test_dataset\n\n# -----------------------------------------------------------------------------\nif __name__ == '__main__':\n\n    # parse command line args\n    parser = argparse.ArgumentParser(description=\"Make More\")\n    # system/input/output\n    parser.add_argument('--input-file', '-i', type=str, default='names.txt', help=\"input file with things one per line\")\n    parser.add_argument('--work-dir', '-o', type=str, default='out', help=\"output working directory\")\n    parser.add_argument('--resume', action='store_true', help=\"when this flag is used, we will resume optimization from existing model in the workdir\")\n    parser.add_argument('--sample-only', action='store_true', help=\"just sample from the model and quit, don't train\")\n    parser.add_argument('--num-workers', '-n', type=int, default=4, help=\"number of data workers for both train/test\")\n    parser.add_argument('--max-steps', type=int, default=-1, help=\"max number of optimization steps to run for, or -1 for infinite.\")\n    parser.add_argument('--device', type=str, default='cpu', help=\"device to use for compute, examples: cpu|cuda|cuda:2|mps\")\n    parser.add_argument('--seed', type=int, default=3407, help=\"seed\")\n    # sampling\n    parser.add_argument('--top-k', type=int, default=-1, help=\"top-k for sampling, -1 means no top-k\")\n    # model\n    parser.add_argument('--n-layer', type=int, default=4, help=\"number of layers in the transformer\")\n    parser.add_argument('--n-head', type=int, default=4, help=\"number of heads in the transformer\")\n    parser.add_argument('--n-embd', type=int, default=64, help=\"number of feature channels in the transformer\")\n    # optimization\n    parser.add_argument('--batch-size', '-b', type=int, default=32, help=\"batch size during optimization\")\n    parser.add_argument('--learning-rate', '-l', type=float, default=5e-4, help=\"learning rate\")\n    parser.add_argument('--weight-decay', '-w', type=float, default=0.01, help=\"weight decay\")\n    args = parser.parse_args()\n    print(vars(args))\n\n    # system inits\n    torch.manual_seed(args.seed)\n    torch.cuda.manual_seed_all(args.seed)\n    os.makedirs(args.work_dir, exist_ok=True)\n    writer = SummaryWriter(log_dir=args.work_dir)\n\n    # init datasets\n    train_dataset, test_dataset = create_datasets(args.input_file)\n    vocab_size = train_dataset.get_vocab_size()\n    block_size = train_dataset.get_output_length()\n    print(f\"dataset determined that: {vocab_size=}, {block_size=}\")\n\n    # init model\n    config = GPTConfig(vocab_size=vocab_size, block_size=block_size,\n                       n_layer=args.n_layer, n_head=args.n_head, n_embd=args.n_embd)\n    model = GPT(config)\n    model.to(args.device)\n    print(f\"model #params: {sum(p.numel() for p in model.parameters())}\")\n    if args.resume or args.sample_only: # note: if we sample-only then we also assume we're resuming\n        print(\"resuming from existing model in the workdir\")\n        model.load_state_dict(torch.load(os.path.join(args.work_dir, 'model.pt')))\n    if args.sample_only:\n        print_samples(num=50)\n        sys.exit()\n\n    # init optimizer\n    optimizer = torch.optim.AdamW(model.parameters(), lr=args.learning_rate, weight_decay=args.weight_decay,\n                                betas=(0.9, 0.99), eps=1e-8)\n\n    # init dataloader\n    train_sampler = torch.utils.data.RandomSampler(train_dataset, replacement=True, num_samples=int(1e10))\n    train_loader = DataLoader(train_dataset, batch_size=args.batch_size, pin_memory=True,\n                              num_workers=args.num_workers, sampler=train_sampler)\n    data_iter = iter(train_loader)\n\n    # training loop\n    best_loss = None\n    step = 0\n    while True:\n\n        t0 = time.time()\n        # fetch the next batch and reset dataloader every epoch as necessary\n        try:\n            batch = next(data_iter)\n        except StopIteration:\n            data_iter = iter(train_loader)\n            batch = next(data_iter)\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n\n        # feed into the model\n        logits, loss = model(X, Y)\n\n        # calculate the gradient, clip it, update the weights\n        model.zero_grad(set_to_none=True)\n        loss.backward()\n        optimizer.step()\n        if args.device.startswith('cuda'):\n            torch.cuda.synchronize()\n        t1 = time.time()\n\n        # logging\n        if step % 10 == 0:\n            print(f\"step {step} | loss {loss.item():.4f} | step time {(t1-t0)*1000:.2f}ms\")\n\n        # evaluate the model\n        if step > 0 and step % 500 == 0:\n            train_loss = evaluate(model, train_dataset, batch_size=100, max_batches=10)\n            test_loss  = evaluate(model, test_dataset,  batch_size=100, max_batches=10)\n            writer.add_scalar(\"Loss/train\", train_loss, step)\n            writer.add_scalar(\"Loss/test\", test_loss, step)\n            writer.flush()\n            print(f\"step {step} train loss: {train_loss} test loss: {test_loss}\")\n            # save the model to disk if it has improved\n            if best_loss is None or test_loss < best_loss:\n                out_path = os.path.join(args.work_dir, \"model.pt\")\n                print(f\"test loss {test_loss} is the best so far, saving model to {out_path}\")\n                torch.save(model.state_dict(), out_path)\n                best_loss = test_loss\n\n        # sample from the model\n        if step > 0 and step % 200 == 0:\n            print_samples(num=10)\n\n        step += 1\n        # termination conditions\n        if args.max_steps >= 0 and step >= args.max_steps:\n            break\n\n", "previous_id": "a7c52cd4d0938d778da72a281eae479077064d10", "new_code_file": "\"\"\"\nyou give this script some words (one per line) and it will generate more things like it.\nuses super state of the art Transformer AI tech\nthis code is intended to be super hackable. tune it to your needs.\n\nChanges from minGPT:\n- I removed the from_pretrained function where we init with GPT2 weights\n- I removed dropout layers because the models we train here are small,\n  it's not necessary to understand at this stage and at this scale.\n- I removed weight decay and all of the complexity around what parameters are\n  and are not weight decayed. I don't believe this should make a massive\n  difference at the scale that we operate on here.\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport math\nimport argparse\nfrom dataclasses import dataclass\nfrom typing import List\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\nfrom torch.utils.data import Dataset\nfrom torch.utils.data.dataloader import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\n# -----------------------------------------------------------------------------\n# GPT model definition\n\n@dataclass\nclass GPTConfig:\n    # size of the model\n    n_layer: int = 4\n    n_head: int = 4\n    n_embd: int = 64\n    vocab_size: int = None\n    block_size: int = None\n\nclass NewGELU(nn.Module):\n    \"\"\"\n    Implementation of the GELU activation function currently in Google BERT repo (identical to OpenAI GPT).\n    Reference: Gaussian Error Linear Units (GELU) paper: https://arxiv.org/abs/1606.08415\n    \"\"\"\n    def forward(self, x):\n        return 0.5 * x * (1.0 + torch.tanh(math.sqrt(2.0 / math.pi) * (x + 0.044715 * torch.pow(x, 3.0))))\n\nclass CausalSelfAttention(nn.Module):\n    \"\"\"\n    A vanilla multi-head masked self-attention layer with a projection at the end.\n    It is possible to use torch.nn.MultiheadAttention here but I am including an\n    explicit implementation here to show that there is nothing too scary here.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.n_embd % config.n_head == 0\n        # key, query, value projections for all heads, but in a batch\n        self.c_attn = nn.Linear(config.n_embd, 3 * config.n_embd)\n        # output projection\n        self.c_proj = nn.Linear(config.n_embd, config.n_embd)\n        # causal mask to ensure that attention is only applied to the left in the input sequence\n        self.register_buffer(\"bias\", torch.tril(torch.ones(config.block_size, config.block_size))\n                                     .view(1, 1, config.block_size, config.block_size))\n        self.n_head = config.n_head\n        self.n_embd = config.n_embd\n\n    def forward(self, x):\n        B, T, C = x.size() # batch size, sequence length, embedding dimensionality (n_embd)\n\n        # calculate query, key, values for all heads in batch and move head forward to be the batch dim\n        q, k ,v  = self.c_attn(x).split(self.n_embd, dim=2)\n        k = k.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        q = q.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        v = v.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n\n        # causal self-attention; Self-attend: (B, nh, T, hs) x (B, nh, hs, T) -> (B, nh, T, T)\n        att = (q @ k.transpose(-2, -1)) * (1.0 / math.sqrt(k.size(-1)))\n        att = att.masked_fill(self.bias[:,:,:T,:T] == 0, float('-inf'))\n        att = F.softmax(att, dim=-1)\n        y = att @ v # (B, nh, T, T) x (B, nh, T, hs) -> (B, nh, T, hs)\n        y = y.transpose(1, 2).contiguous().view(B, T, C) # re-assemble all head outputs side by side\n\n        # output projection\n        y = self.c_proj(y)\n        return y\n\nclass Block(nn.Module):\n    \"\"\" an unassuming Transformer block \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.ln_1 = nn.LayerNorm(config.n_embd)\n        self.attn = CausalSelfAttention(config)\n        self.ln_2 = nn.LayerNorm(config.n_embd)\n        self.mlp = nn.ModuleDict(dict(\n            c_fc    = nn.Linear(config.n_embd, 4 * config.n_embd),\n            c_proj  = nn.Linear(4 * config.n_embd, config.n_embd),\n            act     = NewGELU(),\n        ))\n        m = self.mlp\n        self.mlpf = lambda x: m.c_proj(m.act(m.c_fc(x))) # MLP forward\n\n    def forward(self, x):\n        x = x + self.attn(self.ln_1(x))\n        x = x + self.mlpf(self.ln_2(x))\n        return x\n\nclass GPT(nn.Module):\n    \"\"\" GPT Language Model \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.block_size = config.block_size\n\n        self.transformer = nn.ModuleDict(dict(\n            wte = nn.Embedding(config.vocab_size, config.n_embd),\n            wpe = nn.Embedding(config.block_size, config.n_embd),\n            h = nn.ModuleList([Block(config) for _ in range(config.n_layer)]),\n            ln_f = nn.LayerNorm(config.n_embd),\n        ))\n        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n\n        # report number of parameters (note we don't count the decoder parameters in lm_head)\n        n_params = sum(p.numel() for p in self.transformer.parameters())\n        print(\"number of parameters: %.2fM\" % (n_params/1e6,))\n\n    def forward(self, idx, targets=None):\n        device = idx.device\n        b, t = idx.size()\n        assert t <= self.block_size, f\"Cannot forward sequence of length {t}, block size is only {self.block_size}\"\n        pos = torch.arange(0, t, dtype=torch.long, device=device).unsqueeze(0) # shape (1, t)\n\n        # forward the GPT model itself\n        tok_emb = self.transformer.wte(idx) # token embeddings of shape (b, t, n_embd)\n        pos_emb = self.transformer.wpe(pos) # position embeddings of shape (1, t, n_embd)\n        x = tok_emb + pos_emb\n        for block in self.transformer.h:\n            x = block(x)\n        x = self.transformer.ln_f(x)\n        logits = self.lm_head(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n    @torch.no_grad()\n    def generate(self, idx, max_new_tokens, temperature=1.0, do_sample=False, top_k=None):\n        \"\"\"\n        Take a conditioning sequence of indices idx (LongTensor of shape (b,t)) and complete\n        the sequence max_new_tokens times, feeding the predictions back into the model each time.\n        Most likely you'll want to make sure to be in model.eval() mode of operation for this.\n        \"\"\"\n        for _ in range(max_new_tokens):\n            # if the sequence context is growing too long we must crop it at block_size\n            idx_cond = idx if idx.size(1) <= self.block_size else idx[:, -self.block_size:]\n            # forward the model to get the logits for the index in the sequence\n            logits, _ = self(idx_cond)\n            # pluck the logits at the final step and scale by desired temperature\n            logits = logits[:, -1, :] / temperature\n            # optionally crop the logits to only the top k options\n            if top_k is not None:\n                v, _ = torch.topk(logits, top_k)\n                logits[logits < v[:, [-1]]] = -float('Inf')\n            # apply softmax to convert logits to (normalized) probabilities\n            probs = F.softmax(logits, dim=-1)\n            # either sample from the distribution or take the most likely element\n            if do_sample:\n                idx_next = torch.multinomial(probs, num_samples=1)\n            else:\n                _, idx_next = torch.topk(probs, k=1, dim=-1)\n            # append sampled index to the running sequence and continue\n            idx = torch.cat((idx, idx_next), dim=1)\n\n        return idx\n\n# -----------------------------------------------------------------------------\n# helper functions for evaluating and sampling from the model\n\ndef print_samples(num=10):\n    \"\"\" samples from the model and pretty prints the decoded samples \"\"\"\n    X_init = torch.zeros(num, 1, dtype=torch.long).to(args.device)\n    top_k = args.top_k if args.top_k != -1 else None\n    steps = train_dataset.get_output_length() - 1 # -1 because we already start with <START> token (index 0)\n    X_samp = model.generate(X_init, steps, top_k=top_k, do_sample=True).to('cpu')\n    train_samples, test_samples, new_samples = [], [], []\n    for i in range(X_samp.size(0)):\n        # get the i'th row of sampled integers, as python list\n        row = X_samp[i, 1:].tolist() # note: we need to crop out the first <START> token\n        # token 0 is the <STOP> token, so we crop the output sequence at that point\n        crop_index = row.index(0) if 0 in row else len(row)\n        row = row[:crop_index]\n        word_samp = train_dataset.decode(row)\n        # separately track samples that we have and have not seen before\n        if train_dataset.contains(word_samp):\n            train_samples.append(word_samp)\n        elif test_dataset.contains(word_samp):\n            test_samples.append(word_samp)\n        else:\n            new_samples.append(word_samp)\n    print('-'*80)\n    for lst, desc in [(train_samples, 'in train'), (test_samples, 'in test'), (new_samples, 'new')]:\n        print(f\"{len(lst)} samples that are {desc}:\")\n        for word in lst:\n            print(word)\n    print('-'*80)\n\n@torch.inference_mode()\ndef evaluate(model, dataset, batch_size=50, max_batches=None):\n    model.eval()\n    loader = DataLoader(dataset, shuffle=True, batch_size=batch_size, num_workers=0)\n    losses = []\n    for i, batch in enumerate(loader):\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n        logits, loss = model(X, Y)\n        losses.append(loss.item())\n        if max_batches is not None and i >= max_batches:\n            break\n    mean_loss = torch.tensor(losses).mean().item()\n    model.train() # reset model back to training mode\n    return mean_loss\n\n# -----------------------------------------------------------------------------\n# helper functions for creating the training and test Datasets that emit words\n\nclass CharDataset(Dataset):\n\n    def __init__(self, words, chars, max_word_length):\n        self.words = words\n        self.chars = chars\n        self.max_word_length = max_word_length\n        self.stoi = {ch:i+1 for i,ch in enumerate(chars)}\n        self.itos = {i:s for s,i in self.stoi.items()} # inverse mapping\n\n    def __len__(self):\n        return len(self.words)\n\n    def contains(self, word):\n        return word in self.words\n\n    def get_vocab_size(self):\n        return len(self.chars) + 1 # all the possible characters and special 0 token\n\n    def get_output_length(self):\n        return self.max_word_length + 1 # <START> token followed by words\n\n    def encode(self, word):\n        ix = torch.tensor([self.stoi[w] for w in word], dtype=torch.long)\n        return ix\n\n    def decode(self, ix):\n        word = ''.join(self.itos[i] for i in ix)\n        return word\n\n    def __getitem__(self, idx):\n        word = self.words[idx]\n        ix = self.encode(word)\n        x = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        y = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        x[1:1+len(ix)] = ix\n        y[:len(ix)] = ix\n        y[len(ix)+1:] = -1 # index -1 will mask the loss at the inactive locations\n        return x, y\n\ndef create_datasets(input_file):\n\n    # preprocessing of the input text file\n    with open(input_file, 'r') as f:\n        data = f.read()\n    words = data.splitlines()\n    words = [w.strip() for w in words] # get rid of any leading or trailing white space\n    words = [w for w in words if w] # get rid of any empty strings\n    chars = sorted(list(set(''.join(words)))) # all the possible characters\n    max_word_length = max(len(w) for w in words)\n    print(f\"number of examples in the dataset: {len(words)}\")\n    print(f\"max word length: {max_word_length}\")\n    print(f\"number of unique characters in the vocabulary: {len(chars)}\")\n    print(\"vocabulary:\")\n    print(''.join(chars))\n\n    # partition the input data into a training and the test set\n    test_set_size = min(1000, int(len(words) * 0.1)) # 10% of the training set, or up to 1000 examples\n    rp = torch.randperm(len(words)).tolist()\n    train_words = [words[i] for i in rp[:-test_set_size]]\n    test_words = [words[i] for i in rp[-test_set_size:]]\n    print(f\"split up the dataset into {len(train_words)} training examples and {len(test_words)} test examples\")\n\n    # wrap in dataset objects\n    train_dataset = CharDataset(train_words, chars, max_word_length)\n    test_dataset = CharDataset(test_words, chars, max_word_length)\n\n    return train_dataset, test_dataset\n\nclass InfiniteDataLoader:\n    \"\"\"\n    this is really hacky and I'm not proud of it, but there doesn't seem to be\n    a better way in PyTorch to just create an infinite dataloader?\n    \"\"\"\n\n    def __init__(self, dataset, **kwargs):\n        train_sampler = torch.utils.data.RandomSampler(dataset, replacement=True, num_samples=int(1e10))\n        self.train_loader = DataLoader(dataset, sampler=train_sampler, **kwargs)\n        self.data_iter = iter(self.train_loader)\n\n    def next(self):\n        try:\n            batch = next(self.data_iter)\n        except StopIteration: # this will technically only happen after 1e10 samples... (i.e. basically never)\n            self.data_iter = iter(self.train_loader)\n            batch = next(self.data_iter)\n        return batch\n\n# -----------------------------------------------------------------------------\nif __name__ == '__main__':\n\n    # parse command line args\n    parser = argparse.ArgumentParser(description=\"Make More\")\n    # system/input/output\n    parser.add_argument('--input-file', '-i', type=str, default='names.txt', help=\"input file with things one per line\")\n    parser.add_argument('--work-dir', '-o', type=str, default='out', help=\"output working directory\")\n    parser.add_argument('--resume', action='store_true', help=\"when this flag is used, we will resume optimization from existing model in the workdir\")\n    parser.add_argument('--sample-only', action='store_true', help=\"just sample from the model and quit, don't train\")\n    parser.add_argument('--num-workers', '-n', type=int, default=4, help=\"number of data workers for both train/test\")\n    parser.add_argument('--max-steps', type=int, default=-1, help=\"max number of optimization steps to run for, or -1 for infinite.\")\n    parser.add_argument('--device', type=str, default='cpu', help=\"device to use for compute, examples: cpu|cuda|cuda:2|mps\")\n    parser.add_argument('--seed', type=int, default=3407, help=\"seed\")\n    # sampling\n    parser.add_argument('--top-k', type=int, default=-1, help=\"top-k for sampling, -1 means no top-k\")\n    # model\n    parser.add_argument('--n-layer', type=int, default=4, help=\"number of layers in the transformer\")\n    parser.add_argument('--n-head', type=int, default=4, help=\"number of heads in the transformer\")\n    parser.add_argument('--n-embd', type=int, default=64, help=\"number of feature channels in the transformer\")\n    # optimization\n    parser.add_argument('--batch-size', '-b', type=int, default=32, help=\"batch size during optimization\")\n    parser.add_argument('--learning-rate', '-l', type=float, default=5e-4, help=\"learning rate\")\n    parser.add_argument('--weight-decay', '-w', type=float, default=0.01, help=\"weight decay\")\n    args = parser.parse_args()\n    print(vars(args))\n\n    # system inits\n    torch.manual_seed(args.seed)\n    torch.cuda.manual_seed_all(args.seed)\n    os.makedirs(args.work_dir, exist_ok=True)\n    writer = SummaryWriter(log_dir=args.work_dir)\n\n    # init datasets\n    train_dataset, test_dataset = create_datasets(args.input_file)\n    vocab_size = train_dataset.get_vocab_size()\n    block_size = train_dataset.get_output_length()\n    print(f\"dataset determined that: {vocab_size=}, {block_size=}\")\n\n    # init model\n    config = GPTConfig(vocab_size=vocab_size, block_size=block_size,\n                       n_layer=args.n_layer, n_head=args.n_head, n_embd=args.n_embd)\n    model = GPT(config)\n    model.to(args.device)\n    print(f\"model #params: {sum(p.numel() for p in model.parameters())}\")\n    if args.resume or args.sample_only: # note: if we sample-only then we also assume we are resuming\n        print(\"resuming from existing model in the workdir\")\n        model.load_state_dict(torch.load(os.path.join(args.work_dir, 'model.pt')))\n    if args.sample_only:\n        print_samples(num=50)\n        sys.exit()\n\n    # init optimizer\n    optimizer = torch.optim.AdamW(model.parameters(), lr=args.learning_rate, weight_decay=args.weight_decay, betas=(0.9, 0.99), eps=1e-8)\n\n    # init dataloader\n    batch_loader = InfiniteDataLoader(train_dataset, batch_size=args.batch_size, pin_memory=True, num_workers=args.num_workers)\n\n    # training loop\n    best_loss = None\n    step = 0\n    while True:\n\n        t0 = time.time()\n\n        # get the next batch, ship to device, and unpack it to input and target\n        batch = batch_loader.next()\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n\n        # feed into the model\n        logits, loss = model(X, Y)\n\n        # calculate the gradient, clip it, update the weights\n        model.zero_grad(set_to_none=True)\n        loss.backward()\n        optimizer.step()\n        if args.device.startswith('cuda'):\n            torch.cuda.synchronize()\n        t1 = time.time()\n\n        # logging\n        if step % 10 == 0:\n            print(f\"step {step} | loss {loss.item():.4f} | step time {(t1-t0)*1000:.2f}ms\")\n\n        # evaluate the model\n        if step > 0 and step % 500 == 0:\n            train_loss = evaluate(model, train_dataset, batch_size=100, max_batches=10)\n            test_loss  = evaluate(model, test_dataset,  batch_size=100, max_batches=10)\n            writer.add_scalar(\"Loss/train\", train_loss, step)\n            writer.add_scalar(\"Loss/test\", test_loss, step)\n            writer.flush()\n            print(f\"step {step} train loss: {train_loss} test loss: {test_loss}\")\n            # save the model to disk if it has improved\n            if best_loss is None or test_loss < best_loss:\n                out_path = os.path.join(args.work_dir, \"model.pt\")\n                print(f\"test loss {test_loss} is the best so far, saving model to {out_path}\")\n                torch.save(model.state_dict(), out_path)\n                best_loss = test_loss\n\n        # sample from the model\n        if step > 0 and step % 200 == 0:\n            print_samples(num=10)\n\n        step += 1\n        # termination conditions\n        if args.max_steps >= 0 and step >= args.max_steps:\n            break\n\n", "diff": "@@ -297,6 +297,25 @@ def create_datasets(input_file):\n \n     return train_dataset, test_dataset\n \n+class InfiniteDataLoader:\n+    \"\"\"\n+    this is really hacky and I'm not proud of it, but there doesn't seem to be\n+    a better way in PyTorch to just create an infinite dataloader?\n+    \"\"\"\n+\n+    def __init__(self, dataset, **kwargs):\n+        train_sampler = torch.utils.data.RandomSampler(dataset, replacement=True, num_samples=int(1e10))\n+        self.train_loader = DataLoader(dataset, sampler=train_sampler, **kwargs)\n+        self.data_iter = iter(self.train_loader)\n+\n+    def next(self):\n+        try:\n+            batch = next(self.data_iter)\n+        except StopIteration: # this will technically only happen after 1e10 samples... (i.e. basically never)\n+            self.data_iter = iter(self.train_loader)\n+            batch = next(self.data_iter)\n+        return batch\n+\n # -----------------------------------------------------------------------------\n if __name__ == '__main__':\n \n@@ -342,35 +361,28 @@ def create_datasets(input_file):\n     model = GPT(config)\n     model.to(args.device)\n     print(f\"model #params: {sum(p.numel() for p in model.parameters())}\")\n-    if args.resume or args.sample_only: # note: if we sample-only then we also assume we're resuming\n+    if args.resume or args.sample_only: # note: if we sample-only then we also assume we are resuming\n         print(\"resuming from existing model in the workdir\")\n         model.load_state_dict(torch.load(os.path.join(args.work_dir, 'model.pt')))\n     if args.sample_only:\n         print_samples(num=50)\n         sys.exit()\n \n     # init optimizer\n-    optimizer = torch.optim.AdamW(model.parameters(), lr=args.learning_rate, weight_decay=args.weight_decay,\n-                                betas=(0.9, 0.99), eps=1e-8)\n+    optimizer = torch.optim.AdamW(model.parameters(), lr=args.learning_rate, weight_decay=args.weight_decay, betas=(0.9, 0.99), eps=1e-8)\n \n     # init dataloader\n-    train_sampler = torch.utils.data.RandomSampler(train_dataset, replacement=True, num_samples=int(1e10))\n-    train_loader = DataLoader(train_dataset, batch_size=args.batch_size, pin_memory=True,\n-                              num_workers=args.num_workers, sampler=train_sampler)\n-    data_iter = iter(train_loader)\n+    batch_loader = InfiniteDataLoader(train_dataset, batch_size=args.batch_size, pin_memory=True, num_workers=args.num_workers)\n \n     # training loop\n     best_loss = None\n     step = 0\n     while True:\n \n         t0 = time.time()\n-        # fetch the next batch and reset dataloader every epoch as necessary\n-        try:\n-            batch = next(data_iter)\n-        except StopIteration:\n-            data_iter = iter(train_loader)\n-            batch = next(data_iter)\n+\n+        # get the next batch, ship to device, and unpack it to input and target\n+        batch = batch_loader.next()\n         batch = [t.to(args.device) for t in batch]\n         X, Y = batch\n ", "status": "modified"}, {"commit_id": "a7c52cd4d0938d778da72a281eae479077064d10", "commit_message": "remove some guardrails for this simple of a use case", "relative_path": "makemore.py", "previous_code_file": "\"\"\"\nyou give this script some words (one per line) and it will generate more things like it.\nuses super state of the art Transformer AI tech\nthis code is intended to be super hackable. tune it to your needs.\n\nChanges from minGPT:\n- I removed the from_pretrained function where we init with GPT2 weights\n- I removed dropout layers because the models we train here are small,\n  it's not necessary to understand at this stage and at this scale.\n- I removed weight decay and all of the complexity around what parameters are\n  and are not weight decayed. I don't believe this should make a massive\n  difference at the scale that we operate on here.\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport math\nimport argparse\nfrom dataclasses import dataclass\nfrom typing import List\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\nfrom torch.utils.data import Dataset\nfrom torch.utils.data.dataloader import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\n# -----------------------------------------------------------------------------\n# GPT model definition\n\n@dataclass\nclass GPTConfig:\n    # size of the model\n    n_layer: int = 4\n    n_head: int = 4\n    n_embd: int = 64\n    vocab_size: int = None\n    block_size: int = None\n\nclass NewGELU(nn.Module):\n    \"\"\"\n    Implementation of the GELU activation function currently in Google BERT repo (identical to OpenAI GPT).\n    Reference: Gaussian Error Linear Units (GELU) paper: https://arxiv.org/abs/1606.08415\n    \"\"\"\n    def forward(self, x):\n        return 0.5 * x * (1.0 + torch.tanh(math.sqrt(2.0 / math.pi) * (x + 0.044715 * torch.pow(x, 3.0))))\n\nclass CausalSelfAttention(nn.Module):\n    \"\"\"\n    A vanilla multi-head masked self-attention layer with a projection at the end.\n    It is possible to use torch.nn.MultiheadAttention here but I am including an\n    explicit implementation here to show that there is nothing too scary here.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.n_embd % config.n_head == 0\n        # key, query, value projections for all heads, but in a batch\n        self.c_attn = nn.Linear(config.n_embd, 3 * config.n_embd)\n        # output projection\n        self.c_proj = nn.Linear(config.n_embd, config.n_embd)\n        # causal mask to ensure that attention is only applied to the left in the input sequence\n        self.register_buffer(\"bias\", torch.tril(torch.ones(config.block_size, config.block_size))\n                                     .view(1, 1, config.block_size, config.block_size))\n        self.n_head = config.n_head\n        self.n_embd = config.n_embd\n\n    def forward(self, x):\n        B, T, C = x.size() # batch size, sequence length, embedding dimensionality (n_embd)\n\n        # calculate query, key, values for all heads in batch and move head forward to be the batch dim\n        q, k ,v  = self.c_attn(x).split(self.n_embd, dim=2)\n        k = k.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        q = q.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        v = v.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n\n        # causal self-attention; Self-attend: (B, nh, T, hs) x (B, nh, hs, T) -> (B, nh, T, T)\n        att = (q @ k.transpose(-2, -1)) * (1.0 / math.sqrt(k.size(-1)))\n        att = att.masked_fill(self.bias[:,:,:T,:T] == 0, float('-inf'))\n        att = F.softmax(att, dim=-1)\n        y = att @ v # (B, nh, T, T) x (B, nh, T, hs) -> (B, nh, T, hs)\n        y = y.transpose(1, 2).contiguous().view(B, T, C) # re-assemble all head outputs side by side\n\n        # output projection\n        y = self.c_proj(y)\n        return y\n\nclass Block(nn.Module):\n    \"\"\" an unassuming Transformer block \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.ln_1 = nn.LayerNorm(config.n_embd)\n        self.attn = CausalSelfAttention(config)\n        self.ln_2 = nn.LayerNorm(config.n_embd)\n        self.mlp = nn.ModuleDict(dict(\n            c_fc    = nn.Linear(config.n_embd, 4 * config.n_embd),\n            c_proj  = nn.Linear(4 * config.n_embd, config.n_embd),\n            act     = NewGELU(),\n        ))\n        m = self.mlp\n        self.mlpf = lambda x: m.c_proj(m.act(m.c_fc(x))) # MLP forward\n\n    def forward(self, x):\n        x = x + self.attn(self.ln_1(x))\n        x = x + self.mlpf(self.ln_2(x))\n        return x\n\nclass GPT(nn.Module):\n    \"\"\" GPT Language Model \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.vocab_size is not None\n        assert config.block_size is not None\n        self.block_size = config.block_size\n\n        self.transformer = nn.ModuleDict(dict(\n            wte = nn.Embedding(config.vocab_size, config.n_embd),\n            wpe = nn.Embedding(config.block_size, config.n_embd),\n            h = nn.ModuleList([Block(config) for _ in range(config.n_layer)]),\n            ln_f = nn.LayerNorm(config.n_embd),\n        ))\n        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n\n        # report number of parameters (note we don't count the decoder parameters in lm_head)\n        n_params = sum(p.numel() for p in self.transformer.parameters())\n        print(\"number of parameters: %.2fM\" % (n_params/1e6,))\n\n    def forward(self, idx, targets=None):\n        device = idx.device\n        b, t = idx.size()\n        assert t <= self.block_size, f\"Cannot forward sequence of length {t}, block size is only {self.block_size}\"\n        pos = torch.arange(0, t, dtype=torch.long, device=device).unsqueeze(0) # shape (1, t)\n\n        # forward the GPT model itself\n        tok_emb = self.transformer.wte(idx) # token embeddings of shape (b, t, n_embd)\n        pos_emb = self.transformer.wpe(pos) # position embeddings of shape (1, t, n_embd)\n        x = tok_emb + pos_emb\n        for block in self.transformer.h:\n            x = block(x)\n        x = self.transformer.ln_f(x)\n        logits = self.lm_head(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n    @torch.no_grad()\n    def generate(self, idx, max_new_tokens, temperature=1.0, do_sample=False, top_k=None):\n        \"\"\"\n        Take a conditioning sequence of indices idx (LongTensor of shape (b,t)) and complete\n        the sequence max_new_tokens times, feeding the predictions back into the model each time.\n        Most likely you'll want to make sure to be in model.eval() mode of operation for this.\n        \"\"\"\n        for _ in range(max_new_tokens):\n            # if the sequence context is growing too long we must crop it at block_size\n            idx_cond = idx if idx.size(1) <= self.block_size else idx[:, -self.block_size:]\n            # forward the model to get the logits for the index in the sequence\n            logits, _ = self(idx_cond)\n            # pluck the logits at the final step and scale by desired temperature\n            logits = logits[:, -1, :] / temperature\n            # optionally crop the logits to only the top k options\n            if top_k is not None:\n                v, _ = torch.topk(logits, top_k)\n                logits[logits < v[:, [-1]]] = -float('Inf')\n            # apply softmax to convert logits to (normalized) probabilities\n            probs = F.softmax(logits, dim=-1)\n            # either sample from the distribution or take the most likely element\n            if do_sample:\n                idx_next = torch.multinomial(probs, num_samples=1)\n            else:\n                _, idx_next = torch.topk(probs, k=1, dim=-1)\n            # append sampled index to the running sequence and continue\n            idx = torch.cat((idx, idx_next), dim=1)\n\n        return idx\n\n# -----------------------------------------------------------------------------\n# helper functions for evaluating and sampling from the model\n\ndef print_samples(num=10):\n    \"\"\" samples from the model and pretty prints the decoded samples \"\"\"\n    X_init = torch.zeros(num, 1, dtype=torch.long).to(args.device)\n    top_k = args.top_k if args.top_k != -1 else None\n    steps = train_dataset.get_output_length() - 1 # -1 because we already start with <START> token (index 0)\n    X_samp = model.generate(X_init, steps, top_k=top_k, do_sample=True).to('cpu')\n    train_samples, test_samples, new_samples = [], [], []\n    for i in range(X_samp.size(0)):\n        # get the i'th row of sampled integers, as python list\n        row = X_samp[i, 1:].tolist() # note: we need to crop out the first <START> token\n        # token 0 is the <STOP> token, so we crop the output sequence at that point\n        crop_index = row.index(0) if 0 in row else len(row)\n        row = row[:crop_index]\n        word_samp = train_dataset.decode(row)\n        # separately track samples that we have and have not seen before\n        if train_dataset.contains(word_samp):\n            train_samples.append(word_samp)\n        elif test_dataset.contains(word_samp):\n            test_samples.append(word_samp)\n        else:\n            new_samples.append(word_samp)\n    print('-'*80)\n    for lst, desc in [(train_samples, 'in train'), (test_samples, 'in test'), (new_samples, 'new')]:\n        print(f\"{len(lst)} samples that are {desc}:\")\n        for word in lst:\n            print(word)\n    print('-'*80)\n\n@torch.inference_mode()\ndef evaluate(model, dataset, batch_size=50, max_batches=None):\n    model.eval()\n    loader = DataLoader(dataset, shuffle=True, batch_size=batch_size, num_workers=0)\n    losses = []\n    for i, batch in enumerate(loader):\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n        logits, loss = model(X, Y)\n        losses.append(loss.item())\n        if max_batches is not None and i >= max_batches:\n            break\n    mean_loss = torch.tensor(losses).mean().item()\n    model.train() # reset model back to training mode\n    return mean_loss\n\n# -----------------------------------------------------------------------------\n# helper functions for creating the training and test Datasets that emit words\n\nclass CharDataset(Dataset):\n\n    def __init__(self, words, chars, max_word_length):\n        self.words = words\n        self.chars = chars\n        self.max_word_length = max_word_length\n        self.stoi = {ch:i+1 for i,ch in enumerate(chars)}\n        self.itos = {i:s for s,i in self.stoi.items()} # inverse mapping\n\n    def __len__(self):\n        return len(self.words)\n\n    def contains(self, word):\n        return word in self.words\n\n    def get_vocab_size(self):\n        return len(self.chars) + 1 # all the possible characters and special 0 token\n\n    def get_output_length(self):\n        return self.max_word_length + 1 # <START> token followed by words\n\n    def encode(self, word):\n        ix = torch.tensor([self.stoi[w] for w in word], dtype=torch.long)\n        return ix\n\n    def decode(self, ix):\n        word = ''.join(self.itos[i] for i in ix)\n        return word\n\n    def __getitem__(self, idx):\n        word = self.words[idx]\n        ix = self.encode(word)\n        x = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        y = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        x[1:1+len(ix)] = ix\n        y[:len(ix)] = ix\n        y[len(ix)+1:] = -1 # index -1 will mask the loss at the inactive locations\n        return x, y\n\ndef create_datasets(input_file):\n\n    # preprocessing of the input text file\n    with open(input_file, 'r') as f:\n        data = f.read()\n    words = data.splitlines()\n    words = [w.strip() for w in words] # get rid of any leading or trailing white space\n    words = [w for w in words if w] # get rid of any empty strings\n    chars = sorted(list(set(''.join(words)))) # all the possible characters\n    max_word_length = max(len(w) for w in words)\n    print(f\"number of examples in the dataset: {len(words)}\")\n    print(f\"max word length: {max_word_length}\")\n    print(f\"number of unique characters in the vocabulary: {len(chars)}\")\n    print(\"vocabulary:\")\n    print(''.join(chars))\n\n    # partition the input data into a training and the test set\n    test_set_size = min(1000, int(len(words) * 0.1)) # 10% of the training set, or up to 1000 examples\n    rp = torch.randperm(len(words)).tolist()\n    train_words = [words[i] for i in rp[:-test_set_size]]\n    test_words = [words[i] for i in rp[-test_set_size:]]\n    print(f\"split up the dataset into {len(train_words)} training examples and {len(test_words)} test examples\")\n\n    # wrap in dataset objects\n    train_dataset = CharDataset(train_words, chars, max_word_length)\n    test_dataset = CharDataset(test_words, chars, max_word_length)\n\n    return train_dataset, test_dataset\n\n# -----------------------------------------------------------------------------\nif __name__ == '__main__':\n\n    # parse command line args\n    parser = argparse.ArgumentParser(description=\"Make More\")\n    # system/input/output\n    parser.add_argument('--input-file', '-i', type=str, default='names.txt', help=\"input file with things one per line\")\n    parser.add_argument('--work-dir', '-o', type=str, default='out', help=\"output working directory\")\n    parser.add_argument('--resume', action='store_true', help=\"when this flag is used, we will resume optimization from existing model in the workdir\")\n    parser.add_argument('--sample-only', action='store_true', help=\"just sample from the model and quit, don't train\")\n    parser.add_argument('--num-workers', '-n', type=int, default=4, help=\"number of data workers for both train/test\")\n    parser.add_argument('--max-steps', type=int, default=-1, help=\"max number of optimization steps to run for, or -1 for infinite.\")\n    parser.add_argument('--device', type=str, default='cpu', help=\"device to use for compute, examples: cpu|cuda|cuda:2|mps\")\n    parser.add_argument('--seed', type=int, default=3407, help=\"seed\")\n    # sampling\n    parser.add_argument('--top-k', type=int, default=-1, help=\"top-k for sampling, -1 means no top-k\")\n    # model\n    parser.add_argument('--n-layer', type=int, default=4, help=\"number of layers in the transformer\")\n    parser.add_argument('--n-head', type=int, default=4, help=\"number of heads in the transformer\")\n    parser.add_argument('--n-embd', type=int, default=64, help=\"number of feature channels in the transformer\")\n    # optimization\n    parser.add_argument('--batch-size', '-b', type=int, default=32, help=\"batch size during optimization\")\n    parser.add_argument('--learning-rate', '-l', type=float, default=5e-4, help=\"learning rate\")\n    parser.add_argument('--weight-decay', '-w', type=float, default=0.01, help=\"weight decay\")\n    args = parser.parse_args()\n    print(vars(args))\n\n    # system inits\n    torch.manual_seed(args.seed)\n    torch.cuda.manual_seed_all(args.seed)\n    os.makedirs(args.work_dir, exist_ok=True)\n    writer = SummaryWriter(log_dir=args.work_dir)\n\n    # init datasets\n    train_dataset, test_dataset = create_datasets(args.input_file)\n    vocab_size = train_dataset.get_vocab_size()\n    block_size = train_dataset.get_output_length()\n    print(f\"dataset determined that: {vocab_size=}, {block_size=}\")\n\n    # init model\n    config = GPTConfig(vocab_size=vocab_size, block_size=block_size,\n                       n_layer=args.n_layer, n_head=args.n_head, n_embd=args.n_embd)\n    model = GPT(config)\n    model.to(args.device)\n    print(f\"model #params: {sum(p.numel() for p in model.parameters())}\")\n    if args.resume or args.sample_only: # note: if we sample-only then we also assume we're resuming\n        print(\"resuming from existing model in the workdir\")\n        model.load_state_dict(torch.load(os.path.join(args.work_dir, 'model.pt')))\n    if args.sample_only:\n        print_samples(num=50)\n        sys.exit()\n\n    # init optimizer\n    optimizer = torch.optim.AdamW(model.parameters(), lr=args.learning_rate, weight_decay=args.weight_decay,\n                                betas=(0.9, 0.99), eps=1e-8)\n\n    # init dataloader\n    train_sampler = torch.utils.data.RandomSampler(train_dataset, replacement=True, num_samples=int(1e10))\n    train_loader = DataLoader(train_dataset, batch_size=args.batch_size, pin_memory=True,\n                              num_workers=args.num_workers, sampler=train_sampler)\n    data_iter = iter(train_loader)\n\n    # training loop\n    best_loss = None\n    step = 0\n    while True:\n\n        t0 = time.time()\n        # fetch the next batch and reset dataloader every epoch as necessary\n        try:\n            batch = next(data_iter)\n        except StopIteration:\n            data_iter = iter(train_loader)\n            batch = next(data_iter)\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n\n        # feed into the model\n        logits, loss = model(X, Y)\n\n        # calculate the gradient, clip it, update the weights\n        model.zero_grad(set_to_none=True)\n        loss.backward()\n        optimizer.step()\n        if args.device.startswith('cuda'):\n            torch.cuda.synchronize()\n        t1 = time.time()\n\n        # logging\n        if step % 10 == 0:\n            print(f\"step {step} | loss {loss.item():.4f} | step time {(t1-t0)*1000:.2f}ms\")\n\n        # evaluate the model\n        if step > 0 and step % 500 == 0:\n            train_loss = evaluate(model, train_dataset, batch_size=100, max_batches=10)\n            test_loss  = evaluate(model, test_dataset,  batch_size=100, max_batches=10)\n            writer.add_scalar(\"Loss/train\", train_loss, step)\n            writer.add_scalar(\"Loss/test\", test_loss, step)\n            writer.flush()\n            print(f\"step {step} train loss: {train_loss} test loss: {test_loss}\")\n            # save the model to disk if it has improved\n            if best_loss is None or test_loss < best_loss:\n                out_path = os.path.join(args.work_dir, \"model.pt\")\n                print(f\"test loss {test_loss} is the best so far, saving model to {out_path}\")\n                torch.save(model.state_dict(), out_path)\n                best_loss = test_loss\n\n        # sample from the model\n        if step > 0 and step % 200 == 0:\n            print_samples(num=10)\n\n        step += 1\n        # termination conditions\n        if args.max_steps >= 0 and step >= args.max_steps:\n            break\n\n", "previous_id": "4e0137ddf64fe864308221605ecb7795d671a446", "new_code_file": "\"\"\"\nyou give this script some words (one per line) and it will generate more things like it.\nuses super state of the art Transformer AI tech\nthis code is intended to be super hackable. tune it to your needs.\n\nChanges from minGPT:\n- I removed the from_pretrained function where we init with GPT2 weights\n- I removed dropout layers because the models we train here are small,\n  it's not necessary to understand at this stage and at this scale.\n- I removed weight decay and all of the complexity around what parameters are\n  and are not weight decayed. I don't believe this should make a massive\n  difference at the scale that we operate on here.\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport math\nimport argparse\nfrom dataclasses import dataclass\nfrom typing import List\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\nfrom torch.utils.data import Dataset\nfrom torch.utils.data.dataloader import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\n# -----------------------------------------------------------------------------\n# GPT model definition\n\n@dataclass\nclass GPTConfig:\n    # size of the model\n    n_layer: int = 4\n    n_head: int = 4\n    n_embd: int = 64\n    vocab_size: int = None\n    block_size: int = None\n\nclass NewGELU(nn.Module):\n    \"\"\"\n    Implementation of the GELU activation function currently in Google BERT repo (identical to OpenAI GPT).\n    Reference: Gaussian Error Linear Units (GELU) paper: https://arxiv.org/abs/1606.08415\n    \"\"\"\n    def forward(self, x):\n        return 0.5 * x * (1.0 + torch.tanh(math.sqrt(2.0 / math.pi) * (x + 0.044715 * torch.pow(x, 3.0))))\n\nclass CausalSelfAttention(nn.Module):\n    \"\"\"\n    A vanilla multi-head masked self-attention layer with a projection at the end.\n    It is possible to use torch.nn.MultiheadAttention here but I am including an\n    explicit implementation here to show that there is nothing too scary here.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.n_embd % config.n_head == 0\n        # key, query, value projections for all heads, but in a batch\n        self.c_attn = nn.Linear(config.n_embd, 3 * config.n_embd)\n        # output projection\n        self.c_proj = nn.Linear(config.n_embd, config.n_embd)\n        # causal mask to ensure that attention is only applied to the left in the input sequence\n        self.register_buffer(\"bias\", torch.tril(torch.ones(config.block_size, config.block_size))\n                                     .view(1, 1, config.block_size, config.block_size))\n        self.n_head = config.n_head\n        self.n_embd = config.n_embd\n\n    def forward(self, x):\n        B, T, C = x.size() # batch size, sequence length, embedding dimensionality (n_embd)\n\n        # calculate query, key, values for all heads in batch and move head forward to be the batch dim\n        q, k ,v  = self.c_attn(x).split(self.n_embd, dim=2)\n        k = k.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        q = q.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        v = v.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n\n        # causal self-attention; Self-attend: (B, nh, T, hs) x (B, nh, hs, T) -> (B, nh, T, T)\n        att = (q @ k.transpose(-2, -1)) * (1.0 / math.sqrt(k.size(-1)))\n        att = att.masked_fill(self.bias[:,:,:T,:T] == 0, float('-inf'))\n        att = F.softmax(att, dim=-1)\n        y = att @ v # (B, nh, T, T) x (B, nh, T, hs) -> (B, nh, T, hs)\n        y = y.transpose(1, 2).contiguous().view(B, T, C) # re-assemble all head outputs side by side\n\n        # output projection\n        y = self.c_proj(y)\n        return y\n\nclass Block(nn.Module):\n    \"\"\" an unassuming Transformer block \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.ln_1 = nn.LayerNorm(config.n_embd)\n        self.attn = CausalSelfAttention(config)\n        self.ln_2 = nn.LayerNorm(config.n_embd)\n        self.mlp = nn.ModuleDict(dict(\n            c_fc    = nn.Linear(config.n_embd, 4 * config.n_embd),\n            c_proj  = nn.Linear(4 * config.n_embd, config.n_embd),\n            act     = NewGELU(),\n        ))\n        m = self.mlp\n        self.mlpf = lambda x: m.c_proj(m.act(m.c_fc(x))) # MLP forward\n\n    def forward(self, x):\n        x = x + self.attn(self.ln_1(x))\n        x = x + self.mlpf(self.ln_2(x))\n        return x\n\nclass GPT(nn.Module):\n    \"\"\" GPT Language Model \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.block_size = config.block_size\n\n        self.transformer = nn.ModuleDict(dict(\n            wte = nn.Embedding(config.vocab_size, config.n_embd),\n            wpe = nn.Embedding(config.block_size, config.n_embd),\n            h = nn.ModuleList([Block(config) for _ in range(config.n_layer)]),\n            ln_f = nn.LayerNorm(config.n_embd),\n        ))\n        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n\n        # report number of parameters (note we don't count the decoder parameters in lm_head)\n        n_params = sum(p.numel() for p in self.transformer.parameters())\n        print(\"number of parameters: %.2fM\" % (n_params/1e6,))\n\n    def forward(self, idx, targets=None):\n        device = idx.device\n        b, t = idx.size()\n        assert t <= self.block_size, f\"Cannot forward sequence of length {t}, block size is only {self.block_size}\"\n        pos = torch.arange(0, t, dtype=torch.long, device=device).unsqueeze(0) # shape (1, t)\n\n        # forward the GPT model itself\n        tok_emb = self.transformer.wte(idx) # token embeddings of shape (b, t, n_embd)\n        pos_emb = self.transformer.wpe(pos) # position embeddings of shape (1, t, n_embd)\n        x = tok_emb + pos_emb\n        for block in self.transformer.h:\n            x = block(x)\n        x = self.transformer.ln_f(x)\n        logits = self.lm_head(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n    @torch.no_grad()\n    def generate(self, idx, max_new_tokens, temperature=1.0, do_sample=False, top_k=None):\n        \"\"\"\n        Take a conditioning sequence of indices idx (LongTensor of shape (b,t)) and complete\n        the sequence max_new_tokens times, feeding the predictions back into the model each time.\n        Most likely you'll want to make sure to be in model.eval() mode of operation for this.\n        \"\"\"\n        for _ in range(max_new_tokens):\n            # if the sequence context is growing too long we must crop it at block_size\n            idx_cond = idx if idx.size(1) <= self.block_size else idx[:, -self.block_size:]\n            # forward the model to get the logits for the index in the sequence\n            logits, _ = self(idx_cond)\n            # pluck the logits at the final step and scale by desired temperature\n            logits = logits[:, -1, :] / temperature\n            # optionally crop the logits to only the top k options\n            if top_k is not None:\n                v, _ = torch.topk(logits, top_k)\n                logits[logits < v[:, [-1]]] = -float('Inf')\n            # apply softmax to convert logits to (normalized) probabilities\n            probs = F.softmax(logits, dim=-1)\n            # either sample from the distribution or take the most likely element\n            if do_sample:\n                idx_next = torch.multinomial(probs, num_samples=1)\n            else:\n                _, idx_next = torch.topk(probs, k=1, dim=-1)\n            # append sampled index to the running sequence and continue\n            idx = torch.cat((idx, idx_next), dim=1)\n\n        return idx\n\n# -----------------------------------------------------------------------------\n# helper functions for evaluating and sampling from the model\n\ndef print_samples(num=10):\n    \"\"\" samples from the model and pretty prints the decoded samples \"\"\"\n    X_init = torch.zeros(num, 1, dtype=torch.long).to(args.device)\n    top_k = args.top_k if args.top_k != -1 else None\n    steps = train_dataset.get_output_length() - 1 # -1 because we already start with <START> token (index 0)\n    X_samp = model.generate(X_init, steps, top_k=top_k, do_sample=True).to('cpu')\n    train_samples, test_samples, new_samples = [], [], []\n    for i in range(X_samp.size(0)):\n        # get the i'th row of sampled integers, as python list\n        row = X_samp[i, 1:].tolist() # note: we need to crop out the first <START> token\n        # token 0 is the <STOP> token, so we crop the output sequence at that point\n        crop_index = row.index(0) if 0 in row else len(row)\n        row = row[:crop_index]\n        word_samp = train_dataset.decode(row)\n        # separately track samples that we have and have not seen before\n        if train_dataset.contains(word_samp):\n            train_samples.append(word_samp)\n        elif test_dataset.contains(word_samp):\n            test_samples.append(word_samp)\n        else:\n            new_samples.append(word_samp)\n    print('-'*80)\n    for lst, desc in [(train_samples, 'in train'), (test_samples, 'in test'), (new_samples, 'new')]:\n        print(f\"{len(lst)} samples that are {desc}:\")\n        for word in lst:\n            print(word)\n    print('-'*80)\n\n@torch.inference_mode()\ndef evaluate(model, dataset, batch_size=50, max_batches=None):\n    model.eval()\n    loader = DataLoader(dataset, shuffle=True, batch_size=batch_size, num_workers=0)\n    losses = []\n    for i, batch in enumerate(loader):\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n        logits, loss = model(X, Y)\n        losses.append(loss.item())\n        if max_batches is not None and i >= max_batches:\n            break\n    mean_loss = torch.tensor(losses).mean().item()\n    model.train() # reset model back to training mode\n    return mean_loss\n\n# -----------------------------------------------------------------------------\n# helper functions for creating the training and test Datasets that emit words\n\nclass CharDataset(Dataset):\n\n    def __init__(self, words, chars, max_word_length):\n        self.words = words\n        self.chars = chars\n        self.max_word_length = max_word_length\n        self.stoi = {ch:i+1 for i,ch in enumerate(chars)}\n        self.itos = {i:s for s,i in self.stoi.items()} # inverse mapping\n\n    def __len__(self):\n        return len(self.words)\n\n    def contains(self, word):\n        return word in self.words\n\n    def get_vocab_size(self):\n        return len(self.chars) + 1 # all the possible characters and special 0 token\n\n    def get_output_length(self):\n        return self.max_word_length + 1 # <START> token followed by words\n\n    def encode(self, word):\n        ix = torch.tensor([self.stoi[w] for w in word], dtype=torch.long)\n        return ix\n\n    def decode(self, ix):\n        word = ''.join(self.itos[i] for i in ix)\n        return word\n\n    def __getitem__(self, idx):\n        word = self.words[idx]\n        ix = self.encode(word)\n        x = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        y = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        x[1:1+len(ix)] = ix\n        y[:len(ix)] = ix\n        y[len(ix)+1:] = -1 # index -1 will mask the loss at the inactive locations\n        return x, y\n\ndef create_datasets(input_file):\n\n    # preprocessing of the input text file\n    with open(input_file, 'r') as f:\n        data = f.read()\n    words = data.splitlines()\n    words = [w.strip() for w in words] # get rid of any leading or trailing white space\n    words = [w for w in words if w] # get rid of any empty strings\n    chars = sorted(list(set(''.join(words)))) # all the possible characters\n    max_word_length = max(len(w) for w in words)\n    print(f\"number of examples in the dataset: {len(words)}\")\n    print(f\"max word length: {max_word_length}\")\n    print(f\"number of unique characters in the vocabulary: {len(chars)}\")\n    print(\"vocabulary:\")\n    print(''.join(chars))\n\n    # partition the input data into a training and the test set\n    test_set_size = min(1000, int(len(words) * 0.1)) # 10% of the training set, or up to 1000 examples\n    rp = torch.randperm(len(words)).tolist()\n    train_words = [words[i] for i in rp[:-test_set_size]]\n    test_words = [words[i] for i in rp[-test_set_size:]]\n    print(f\"split up the dataset into {len(train_words)} training examples and {len(test_words)} test examples\")\n\n    # wrap in dataset objects\n    train_dataset = CharDataset(train_words, chars, max_word_length)\n    test_dataset = CharDataset(test_words, chars, max_word_length)\n\n    return train_dataset, test_dataset\n\n# -----------------------------------------------------------------------------\nif __name__ == '__main__':\n\n    # parse command line args\n    parser = argparse.ArgumentParser(description=\"Make More\")\n    # system/input/output\n    parser.add_argument('--input-file', '-i', type=str, default='names.txt', help=\"input file with things one per line\")\n    parser.add_argument('--work-dir', '-o', type=str, default='out', help=\"output working directory\")\n    parser.add_argument('--resume', action='store_true', help=\"when this flag is used, we will resume optimization from existing model in the workdir\")\n    parser.add_argument('--sample-only', action='store_true', help=\"just sample from the model and quit, don't train\")\n    parser.add_argument('--num-workers', '-n', type=int, default=4, help=\"number of data workers for both train/test\")\n    parser.add_argument('--max-steps', type=int, default=-1, help=\"max number of optimization steps to run for, or -1 for infinite.\")\n    parser.add_argument('--device', type=str, default='cpu', help=\"device to use for compute, examples: cpu|cuda|cuda:2|mps\")\n    parser.add_argument('--seed', type=int, default=3407, help=\"seed\")\n    # sampling\n    parser.add_argument('--top-k', type=int, default=-1, help=\"top-k for sampling, -1 means no top-k\")\n    # model\n    parser.add_argument('--n-layer', type=int, default=4, help=\"number of layers in the transformer\")\n    parser.add_argument('--n-head', type=int, default=4, help=\"number of heads in the transformer\")\n    parser.add_argument('--n-embd', type=int, default=64, help=\"number of feature channels in the transformer\")\n    # optimization\n    parser.add_argument('--batch-size', '-b', type=int, default=32, help=\"batch size during optimization\")\n    parser.add_argument('--learning-rate', '-l', type=float, default=5e-4, help=\"learning rate\")\n    parser.add_argument('--weight-decay', '-w', type=float, default=0.01, help=\"weight decay\")\n    args = parser.parse_args()\n    print(vars(args))\n\n    # system inits\n    torch.manual_seed(args.seed)\n    torch.cuda.manual_seed_all(args.seed)\n    os.makedirs(args.work_dir, exist_ok=True)\n    writer = SummaryWriter(log_dir=args.work_dir)\n\n    # init datasets\n    train_dataset, test_dataset = create_datasets(args.input_file)\n    vocab_size = train_dataset.get_vocab_size()\n    block_size = train_dataset.get_output_length()\n    print(f\"dataset determined that: {vocab_size=}, {block_size=}\")\n\n    # init model\n    config = GPTConfig(vocab_size=vocab_size, block_size=block_size,\n                       n_layer=args.n_layer, n_head=args.n_head, n_embd=args.n_embd)\n    model = GPT(config)\n    model.to(args.device)\n    print(f\"model #params: {sum(p.numel() for p in model.parameters())}\")\n    if args.resume or args.sample_only: # note: if we sample-only then we also assume we're resuming\n        print(\"resuming from existing model in the workdir\")\n        model.load_state_dict(torch.load(os.path.join(args.work_dir, 'model.pt')))\n    if args.sample_only:\n        print_samples(num=50)\n        sys.exit()\n\n    # init optimizer\n    optimizer = torch.optim.AdamW(model.parameters(), lr=args.learning_rate, weight_decay=args.weight_decay,\n                                betas=(0.9, 0.99), eps=1e-8)\n\n    # init dataloader\n    train_sampler = torch.utils.data.RandomSampler(train_dataset, replacement=True, num_samples=int(1e10))\n    train_loader = DataLoader(train_dataset, batch_size=args.batch_size, pin_memory=True,\n                              num_workers=args.num_workers, sampler=train_sampler)\n    data_iter = iter(train_loader)\n\n    # training loop\n    best_loss = None\n    step = 0\n    while True:\n\n        t0 = time.time()\n        # fetch the next batch and reset dataloader every epoch as necessary\n        try:\n            batch = next(data_iter)\n        except StopIteration:\n            data_iter = iter(train_loader)\n            batch = next(data_iter)\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n\n        # feed into the model\n        logits, loss = model(X, Y)\n\n        # calculate the gradient, clip it, update the weights\n        model.zero_grad(set_to_none=True)\n        loss.backward()\n        optimizer.step()\n        if args.device.startswith('cuda'):\n            torch.cuda.synchronize()\n        t1 = time.time()\n\n        # logging\n        if step % 10 == 0:\n            print(f\"step {step} | loss {loss.item():.4f} | step time {(t1-t0)*1000:.2f}ms\")\n\n        # evaluate the model\n        if step > 0 and step % 500 == 0:\n            train_loss = evaluate(model, train_dataset, batch_size=100, max_batches=10)\n            test_loss  = evaluate(model, test_dataset,  batch_size=100, max_batches=10)\n            writer.add_scalar(\"Loss/train\", train_loss, step)\n            writer.add_scalar(\"Loss/test\", test_loss, step)\n            writer.flush()\n            print(f\"step {step} train loss: {train_loss} test loss: {test_loss}\")\n            # save the model to disk if it has improved\n            if best_loss is None or test_loss < best_loss:\n                out_path = os.path.join(args.work_dir, \"model.pt\")\n                print(f\"test loss {test_loss} is the best so far, saving model to {out_path}\")\n                torch.save(model.state_dict(), out_path)\n                best_loss = test_loss\n\n        # sample from the model\n        if step > 0 and step % 200 == 0:\n            print_samples(num=10)\n\n        step += 1\n        # termination conditions\n        if args.max_steps >= 0 and step >= args.max_steps:\n            break\n\n", "diff": "@@ -113,8 +113,6 @@ class GPT(nn.Module):\n \n     def __init__(self, config):\n         super().__init__()\n-        assert config.vocab_size is not None\n-        assert config.block_size is not None\n         self.block_size = config.block_size\n \n         self.transformer = nn.ModuleDict(dict(", "status": "modified"}, {"commit_id": "4e0137ddf64fe864308221605ecb7795d671a446", "commit_message": "remove gradient clipping i dont think its needed at this small scale", "relative_path": "makemore.py", "previous_code_file": "\"\"\"\nyou give this script some words (one per line) and it will generate more things like it.\nuses super state of the art Transformer AI tech\nthis code is intended to be super hackable. tune it to your needs.\n\nChanges from minGPT:\n- I removed the from_pretrained function where we init with GPT2 weights\n- I removed dropout layers because the models we train here are small,\n  it's not necessary to understand at this stage and at this scale.\n- I removed weight decay and all of the complexity around what parameters are\n  and are not weight decayed. I don't believe this should make a massive\n  difference at the scale that we operate on here.\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport math\nimport argparse\nfrom dataclasses import dataclass\nfrom typing import List\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\nfrom torch.utils.data import Dataset\nfrom torch.utils.data.dataloader import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\n# -----------------------------------------------------------------------------\n# GPT model definition\n\n@dataclass\nclass GPTConfig:\n    # size of the model\n    n_layer: int = 4\n    n_head: int = 4\n    n_embd: int = 64\n    vocab_size: int = None\n    block_size: int = None\n\nclass NewGELU(nn.Module):\n    \"\"\"\n    Implementation of the GELU activation function currently in Google BERT repo (identical to OpenAI GPT).\n    Reference: Gaussian Error Linear Units (GELU) paper: https://arxiv.org/abs/1606.08415\n    \"\"\"\n    def forward(self, x):\n        return 0.5 * x * (1.0 + torch.tanh(math.sqrt(2.0 / math.pi) * (x + 0.044715 * torch.pow(x, 3.0))))\n\nclass CausalSelfAttention(nn.Module):\n    \"\"\"\n    A vanilla multi-head masked self-attention layer with a projection at the end.\n    It is possible to use torch.nn.MultiheadAttention here but I am including an\n    explicit implementation here to show that there is nothing too scary here.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.n_embd % config.n_head == 0\n        # key, query, value projections for all heads, but in a batch\n        self.c_attn = nn.Linear(config.n_embd, 3 * config.n_embd)\n        # output projection\n        self.c_proj = nn.Linear(config.n_embd, config.n_embd)\n        # causal mask to ensure that attention is only applied to the left in the input sequence\n        self.register_buffer(\"bias\", torch.tril(torch.ones(config.block_size, config.block_size))\n                                     .view(1, 1, config.block_size, config.block_size))\n        self.n_head = config.n_head\n        self.n_embd = config.n_embd\n\n    def forward(self, x):\n        B, T, C = x.size() # batch size, sequence length, embedding dimensionality (n_embd)\n\n        # calculate query, key, values for all heads in batch and move head forward to be the batch dim\n        q, k ,v  = self.c_attn(x).split(self.n_embd, dim=2)\n        k = k.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        q = q.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        v = v.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n\n        # causal self-attention; Self-attend: (B, nh, T, hs) x (B, nh, hs, T) -> (B, nh, T, T)\n        att = (q @ k.transpose(-2, -1)) * (1.0 / math.sqrt(k.size(-1)))\n        att = att.masked_fill(self.bias[:,:,:T,:T] == 0, float('-inf'))\n        att = F.softmax(att, dim=-1)\n        y = att @ v # (B, nh, T, T) x (B, nh, T, hs) -> (B, nh, T, hs)\n        y = y.transpose(1, 2).contiguous().view(B, T, C) # re-assemble all head outputs side by side\n\n        # output projection\n        y = self.c_proj(y)\n        return y\n\nclass Block(nn.Module):\n    \"\"\" an unassuming Transformer block \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.ln_1 = nn.LayerNorm(config.n_embd)\n        self.attn = CausalSelfAttention(config)\n        self.ln_2 = nn.LayerNorm(config.n_embd)\n        self.mlp = nn.ModuleDict(dict(\n            c_fc    = nn.Linear(config.n_embd, 4 * config.n_embd),\n            c_proj  = nn.Linear(4 * config.n_embd, config.n_embd),\n            act     = NewGELU(),\n        ))\n        m = self.mlp\n        self.mlpf = lambda x: m.c_proj(m.act(m.c_fc(x))) # MLP forward\n\n    def forward(self, x):\n        x = x + self.attn(self.ln_1(x))\n        x = x + self.mlpf(self.ln_2(x))\n        return x\n\nclass GPT(nn.Module):\n    \"\"\" GPT Language Model \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.vocab_size is not None\n        assert config.block_size is not None\n        self.block_size = config.block_size\n\n        self.transformer = nn.ModuleDict(dict(\n            wte = nn.Embedding(config.vocab_size, config.n_embd),\n            wpe = nn.Embedding(config.block_size, config.n_embd),\n            h = nn.ModuleList([Block(config) for _ in range(config.n_layer)]),\n            ln_f = nn.LayerNorm(config.n_embd),\n        ))\n        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n\n        # report number of parameters (note we don't count the decoder parameters in lm_head)\n        n_params = sum(p.numel() for p in self.transformer.parameters())\n        print(\"number of parameters: %.2fM\" % (n_params/1e6,))\n\n    def forward(self, idx, targets=None):\n        device = idx.device\n        b, t = idx.size()\n        assert t <= self.block_size, f\"Cannot forward sequence of length {t}, block size is only {self.block_size}\"\n        pos = torch.arange(0, t, dtype=torch.long, device=device).unsqueeze(0) # shape (1, t)\n\n        # forward the GPT model itself\n        tok_emb = self.transformer.wte(idx) # token embeddings of shape (b, t, n_embd)\n        pos_emb = self.transformer.wpe(pos) # position embeddings of shape (1, t, n_embd)\n        x = tok_emb + pos_emb\n        for block in self.transformer.h:\n            x = block(x)\n        x = self.transformer.ln_f(x)\n        logits = self.lm_head(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n    @torch.no_grad()\n    def generate(self, idx, max_new_tokens, temperature=1.0, do_sample=False, top_k=None):\n        \"\"\"\n        Take a conditioning sequence of indices idx (LongTensor of shape (b,t)) and complete\n        the sequence max_new_tokens times, feeding the predictions back into the model each time.\n        Most likely you'll want to make sure to be in model.eval() mode of operation for this.\n        \"\"\"\n        for _ in range(max_new_tokens):\n            # if the sequence context is growing too long we must crop it at block_size\n            idx_cond = idx if idx.size(1) <= self.block_size else idx[:, -self.block_size:]\n            # forward the model to get the logits for the index in the sequence\n            logits, _ = self(idx_cond)\n            # pluck the logits at the final step and scale by desired temperature\n            logits = logits[:, -1, :] / temperature\n            # optionally crop the logits to only the top k options\n            if top_k is not None:\n                v, _ = torch.topk(logits, top_k)\n                logits[logits < v[:, [-1]]] = -float('Inf')\n            # apply softmax to convert logits to (normalized) probabilities\n            probs = F.softmax(logits, dim=-1)\n            # either sample from the distribution or take the most likely element\n            if do_sample:\n                idx_next = torch.multinomial(probs, num_samples=1)\n            else:\n                _, idx_next = torch.topk(probs, k=1, dim=-1)\n            # append sampled index to the running sequence and continue\n            idx = torch.cat((idx, idx_next), dim=1)\n\n        return idx\n\n# -----------------------------------------------------------------------------\n# helper functions for evaluating and sampling from the model\n\ndef print_samples(num=10):\n    \"\"\" samples from the model and pretty prints the decoded samples \"\"\"\n    X_init = torch.zeros(num, 1, dtype=torch.long).to(args.device)\n    top_k = args.top_k if args.top_k != -1 else None\n    steps = train_dataset.get_output_length() - 1 # -1 because we already start with <START> token (index 0)\n    X_samp = model.generate(X_init, steps, top_k=top_k, do_sample=True).to('cpu')\n    train_samples, test_samples, new_samples = [], [], []\n    for i in range(X_samp.size(0)):\n        # get the i'th row of sampled integers, as python list\n        row = X_samp[i, 1:].tolist() # note: we need to crop out the first <START> token\n        # token 0 is the <STOP> token, so we crop the output sequence at that point\n        crop_index = row.index(0) if 0 in row else len(row)\n        row = row[:crop_index]\n        word_samp = train_dataset.decode(row)\n        # separately track samples that we have and have not seen before\n        if train_dataset.contains(word_samp):\n            train_samples.append(word_samp)\n        elif test_dataset.contains(word_samp):\n            test_samples.append(word_samp)\n        else:\n            new_samples.append(word_samp)\n    print('-'*80)\n    for lst, desc in [(train_samples, 'in train'), (test_samples, 'in test'), (new_samples, 'new')]:\n        print(f\"{len(lst)} samples that are {desc}:\")\n        for word in lst:\n            print(word)\n    print('-'*80)\n\n@torch.inference_mode()\ndef evaluate(model, dataset, batch_size=50, max_batches=None):\n    model.eval()\n    loader = DataLoader(dataset, shuffle=True, batch_size=batch_size, num_workers=0)\n    losses = []\n    for i, batch in enumerate(loader):\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n        logits, loss = model(X, Y)\n        losses.append(loss.item())\n        if max_batches is not None and i >= max_batches:\n            break\n    mean_loss = torch.tensor(losses).mean().item()\n    model.train() # reset model back to training mode\n    return mean_loss\n\n# -----------------------------------------------------------------------------\n# helper functions for creating the training and test Datasets that emit words\n\nclass CharDataset(Dataset):\n\n    def __init__(self, words, chars, max_word_length):\n        self.words = words\n        self.chars = chars\n        self.max_word_length = max_word_length\n        self.stoi = {ch:i+1 for i,ch in enumerate(chars)}\n        self.itos = {i:s for s,i in self.stoi.items()} # inverse mapping\n\n    def __len__(self):\n        return len(self.words)\n\n    def contains(self, word):\n        return word in self.words\n\n    def get_vocab_size(self):\n        return len(self.chars) + 1 # all the possible characters and special 0 token\n\n    def get_output_length(self):\n        return self.max_word_length + 1 # <START> token followed by words\n\n    def encode(self, word):\n        ix = torch.tensor([self.stoi[w] for w in word], dtype=torch.long)\n        return ix\n\n    def decode(self, ix):\n        word = ''.join(self.itos[i] for i in ix)\n        return word\n\n    def __getitem__(self, idx):\n        word = self.words[idx]\n        ix = self.encode(word)\n        x = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        y = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        x[1:1+len(ix)] = ix\n        y[:len(ix)] = ix\n        y[len(ix)+1:] = -1 # index -1 will mask the loss at the inactive locations\n        return x, y\n\ndef create_datasets(input_file):\n\n    # preprocessing of the input text file\n    with open(input_file, 'r') as f:\n        data = f.read()\n    words = data.splitlines()\n    words = [w.strip() for w in words] # get rid of any leading or trailing white space\n    words = [w for w in words if w] # get rid of any empty strings\n    chars = sorted(list(set(''.join(words)))) # all the possible characters\n    max_word_length = max(len(w) for w in words)\n    print(f\"number of examples in the dataset: {len(words)}\")\n    print(f\"max word length: {max_word_length}\")\n    print(f\"number of unique characters in the vocabulary: {len(chars)}\")\n    print(\"vocabulary:\")\n    print(''.join(chars))\n\n    # partition the input data into a training and the test set\n    test_set_size = min(1000, int(len(words) * 0.1)) # 10% of the training set, or up to 1000 examples\n    rp = torch.randperm(len(words)).tolist()\n    train_words = [words[i] for i in rp[:-test_set_size]]\n    test_words = [words[i] for i in rp[-test_set_size:]]\n    print(f\"split up the dataset into {len(train_words)} training examples and {len(test_words)} test examples\")\n\n    # wrap in dataset objects\n    train_dataset = CharDataset(train_words, chars, max_word_length)\n    test_dataset = CharDataset(test_words, chars, max_word_length)\n\n    return train_dataset, test_dataset\n\n# -----------------------------------------------------------------------------\nif __name__ == '__main__':\n\n    # parse command line args\n    parser = argparse.ArgumentParser(description=\"Make More\")\n    # system/input/output\n    parser.add_argument('--input-file', '-i', type=str, default='names.txt', help=\"input file with things one per line\")\n    parser.add_argument('--work-dir', '-o', type=str, default='out', help=\"output working directory\")\n    parser.add_argument('--resume', action='store_true', help=\"when this flag is used, we will resume optimization from existing model in the workdir\")\n    parser.add_argument('--sample-only', action='store_true', help=\"just sample from the model and quit, don't train\")\n    parser.add_argument('--num-workers', '-n', type=int, default=4, help=\"number of data workers for both train/test\")\n    parser.add_argument('--max-steps', type=int, default=-1, help=\"max number of optimization steps to run for, or -1 for infinite.\")\n    parser.add_argument('--device', type=str, default='cpu', help=\"device to use for compute, examples: cpu|cuda|cuda:2|mps\")\n    parser.add_argument('--seed', type=int, default=3407, help=\"seed\")\n    # sampling\n    parser.add_argument('--top-k', type=int, default=-1, help=\"top-k for sampling, -1 means no top-k\")\n    # model\n    parser.add_argument('--n-layer', type=int, default=4, help=\"number of layers in the transformer\")\n    parser.add_argument('--n-head', type=int, default=4, help=\"number of heads in the transformer\")\n    parser.add_argument('--n-embd', type=int, default=64, help=\"number of feature channels in the transformer\")\n    # optimization\n    parser.add_argument('--batch-size', '-b', type=int, default=32, help=\"batch size during optimization\")\n    parser.add_argument('--learning-rate', '-l', type=float, default=5e-4, help=\"learning rate\")\n    parser.add_argument('--weight-decay', '-w', type=float, default=0.01, help=\"weight decay\")\n    args = parser.parse_args()\n    print(vars(args))\n\n    # system inits\n    torch.manual_seed(args.seed)\n    torch.cuda.manual_seed_all(args.seed)\n    os.makedirs(args.work_dir, exist_ok=True)\n    writer = SummaryWriter(log_dir=args.work_dir)\n\n    # init datasets\n    train_dataset, test_dataset = create_datasets(args.input_file)\n    vocab_size = train_dataset.get_vocab_size()\n    block_size = train_dataset.get_output_length()\n    print(f\"dataset determined that: {vocab_size=}, {block_size=}\")\n\n    # init model\n    config = GPTConfig(vocab_size=vocab_size, block_size=block_size,\n                       n_layer=args.n_layer, n_head=args.n_head, n_embd=args.n_embd)\n    model = GPT(config)\n    model.to(args.device)\n    print(f\"model #params: {sum(p.numel() for p in model.parameters())}\")\n    if args.resume or args.sample_only: # note: if we sample-only then we also assume we're resuming\n        print(\"resuming from existing model in the workdir\")\n        model.load_state_dict(torch.load(os.path.join(args.work_dir, 'model.pt')))\n    if args.sample_only:\n        print_samples(num=50)\n        sys.exit()\n\n    # init optimizer\n    optimizer = torch.optim.AdamW(model.parameters(), lr=args.learning_rate, weight_decay=args.weight_decay,\n                                betas=(0.9, 0.99), eps=1e-8)\n\n    # init dataloader\n    train_sampler = torch.utils.data.RandomSampler(train_dataset, replacement=True, num_samples=int(1e10))\n    train_loader = DataLoader(train_dataset, batch_size=args.batch_size, pin_memory=True,\n                              num_workers=args.num_workers, sampler=train_sampler)\n    data_iter = iter(train_loader)\n\n    # training loop\n    best_loss = None\n    step = 0\n    while True:\n\n        t0 = time.time()\n        # fetch the next batch and reset dataloader every epoch as necessary\n        try:\n            batch = next(data_iter)\n        except StopIteration:\n            data_iter = iter(train_loader)\n            batch = next(data_iter)\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n\n        # feed into the model\n        logits, loss = model(X, Y)\n\n        # calculate the gradient, clip it, update the weights\n        model.zero_grad(set_to_none=True)\n        loss.backward()\n        torch.nn.utils.clip_grad_norm_(model.parameters(), 1.0)\n        optimizer.step()\n        if args.device.startswith('cuda'):\n            torch.cuda.synchronize()\n        t1 = time.time()\n\n        # logging\n        if step % 10 == 0:\n            print(f\"step {step} | loss {loss.item():.4f} | step time {(t1-t0)*1000:.2f}ms\")\n\n        # evaluate the model\n        if step > 0 and step % 500 == 0:\n            train_loss = evaluate(model, train_dataset, batch_size=100, max_batches=10)\n            test_loss  = evaluate(model, test_dataset,  batch_size=100, max_batches=10)\n            writer.add_scalar(\"Loss/train\", train_loss, step)\n            writer.add_scalar(\"Loss/test\", test_loss, step)\n            writer.flush()\n            print(f\"step {step} train loss: {train_loss} test loss: {test_loss}\")\n            # save the model to disk if it has improved\n            if best_loss is None or test_loss < best_loss:\n                out_path = os.path.join(args.work_dir, \"model.pt\")\n                print(f\"test loss {test_loss} is the best so far, saving model to {out_path}\")\n                torch.save(model.state_dict(), out_path)\n                best_loss = test_loss\n\n        # sample from the model\n        if step > 0 and step % 200 == 0:\n            print_samples(num=10)\n\n        step += 1\n        # termination conditions\n        if args.max_steps >= 0 and step >= args.max_steps:\n            break\n\n", "previous_id": "35435ec08796c725cc348cdc53b9bae02dd33d05", "new_code_file": "\"\"\"\nyou give this script some words (one per line) and it will generate more things like it.\nuses super state of the art Transformer AI tech\nthis code is intended to be super hackable. tune it to your needs.\n\nChanges from minGPT:\n- I removed the from_pretrained function where we init with GPT2 weights\n- I removed dropout layers because the models we train here are small,\n  it's not necessary to understand at this stage and at this scale.\n- I removed weight decay and all of the complexity around what parameters are\n  and are not weight decayed. I don't believe this should make a massive\n  difference at the scale that we operate on here.\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport math\nimport argparse\nfrom dataclasses import dataclass\nfrom typing import List\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\nfrom torch.utils.data import Dataset\nfrom torch.utils.data.dataloader import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\n# -----------------------------------------------------------------------------\n# GPT model definition\n\n@dataclass\nclass GPTConfig:\n    # size of the model\n    n_layer: int = 4\n    n_head: int = 4\n    n_embd: int = 64\n    vocab_size: int = None\n    block_size: int = None\n\nclass NewGELU(nn.Module):\n    \"\"\"\n    Implementation of the GELU activation function currently in Google BERT repo (identical to OpenAI GPT).\n    Reference: Gaussian Error Linear Units (GELU) paper: https://arxiv.org/abs/1606.08415\n    \"\"\"\n    def forward(self, x):\n        return 0.5 * x * (1.0 + torch.tanh(math.sqrt(2.0 / math.pi) * (x + 0.044715 * torch.pow(x, 3.0))))\n\nclass CausalSelfAttention(nn.Module):\n    \"\"\"\n    A vanilla multi-head masked self-attention layer with a projection at the end.\n    It is possible to use torch.nn.MultiheadAttention here but I am including an\n    explicit implementation here to show that there is nothing too scary here.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.n_embd % config.n_head == 0\n        # key, query, value projections for all heads, but in a batch\n        self.c_attn = nn.Linear(config.n_embd, 3 * config.n_embd)\n        # output projection\n        self.c_proj = nn.Linear(config.n_embd, config.n_embd)\n        # causal mask to ensure that attention is only applied to the left in the input sequence\n        self.register_buffer(\"bias\", torch.tril(torch.ones(config.block_size, config.block_size))\n                                     .view(1, 1, config.block_size, config.block_size))\n        self.n_head = config.n_head\n        self.n_embd = config.n_embd\n\n    def forward(self, x):\n        B, T, C = x.size() # batch size, sequence length, embedding dimensionality (n_embd)\n\n        # calculate query, key, values for all heads in batch and move head forward to be the batch dim\n        q, k ,v  = self.c_attn(x).split(self.n_embd, dim=2)\n        k = k.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        q = q.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        v = v.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n\n        # causal self-attention; Self-attend: (B, nh, T, hs) x (B, nh, hs, T) -> (B, nh, T, T)\n        att = (q @ k.transpose(-2, -1)) * (1.0 / math.sqrt(k.size(-1)))\n        att = att.masked_fill(self.bias[:,:,:T,:T] == 0, float('-inf'))\n        att = F.softmax(att, dim=-1)\n        y = att @ v # (B, nh, T, T) x (B, nh, T, hs) -> (B, nh, T, hs)\n        y = y.transpose(1, 2).contiguous().view(B, T, C) # re-assemble all head outputs side by side\n\n        # output projection\n        y = self.c_proj(y)\n        return y\n\nclass Block(nn.Module):\n    \"\"\" an unassuming Transformer block \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.ln_1 = nn.LayerNorm(config.n_embd)\n        self.attn = CausalSelfAttention(config)\n        self.ln_2 = nn.LayerNorm(config.n_embd)\n        self.mlp = nn.ModuleDict(dict(\n            c_fc    = nn.Linear(config.n_embd, 4 * config.n_embd),\n            c_proj  = nn.Linear(4 * config.n_embd, config.n_embd),\n            act     = NewGELU(),\n        ))\n        m = self.mlp\n        self.mlpf = lambda x: m.c_proj(m.act(m.c_fc(x))) # MLP forward\n\n    def forward(self, x):\n        x = x + self.attn(self.ln_1(x))\n        x = x + self.mlpf(self.ln_2(x))\n        return x\n\nclass GPT(nn.Module):\n    \"\"\" GPT Language Model \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.vocab_size is not None\n        assert config.block_size is not None\n        self.block_size = config.block_size\n\n        self.transformer = nn.ModuleDict(dict(\n            wte = nn.Embedding(config.vocab_size, config.n_embd),\n            wpe = nn.Embedding(config.block_size, config.n_embd),\n            h = nn.ModuleList([Block(config) for _ in range(config.n_layer)]),\n            ln_f = nn.LayerNorm(config.n_embd),\n        ))\n        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n\n        # report number of parameters (note we don't count the decoder parameters in lm_head)\n        n_params = sum(p.numel() for p in self.transformer.parameters())\n        print(\"number of parameters: %.2fM\" % (n_params/1e6,))\n\n    def forward(self, idx, targets=None):\n        device = idx.device\n        b, t = idx.size()\n        assert t <= self.block_size, f\"Cannot forward sequence of length {t}, block size is only {self.block_size}\"\n        pos = torch.arange(0, t, dtype=torch.long, device=device).unsqueeze(0) # shape (1, t)\n\n        # forward the GPT model itself\n        tok_emb = self.transformer.wte(idx) # token embeddings of shape (b, t, n_embd)\n        pos_emb = self.transformer.wpe(pos) # position embeddings of shape (1, t, n_embd)\n        x = tok_emb + pos_emb\n        for block in self.transformer.h:\n            x = block(x)\n        x = self.transformer.ln_f(x)\n        logits = self.lm_head(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n    @torch.no_grad()\n    def generate(self, idx, max_new_tokens, temperature=1.0, do_sample=False, top_k=None):\n        \"\"\"\n        Take a conditioning sequence of indices idx (LongTensor of shape (b,t)) and complete\n        the sequence max_new_tokens times, feeding the predictions back into the model each time.\n        Most likely you'll want to make sure to be in model.eval() mode of operation for this.\n        \"\"\"\n        for _ in range(max_new_tokens):\n            # if the sequence context is growing too long we must crop it at block_size\n            idx_cond = idx if idx.size(1) <= self.block_size else idx[:, -self.block_size:]\n            # forward the model to get the logits for the index in the sequence\n            logits, _ = self(idx_cond)\n            # pluck the logits at the final step and scale by desired temperature\n            logits = logits[:, -1, :] / temperature\n            # optionally crop the logits to only the top k options\n            if top_k is not None:\n                v, _ = torch.topk(logits, top_k)\n                logits[logits < v[:, [-1]]] = -float('Inf')\n            # apply softmax to convert logits to (normalized) probabilities\n            probs = F.softmax(logits, dim=-1)\n            # either sample from the distribution or take the most likely element\n            if do_sample:\n                idx_next = torch.multinomial(probs, num_samples=1)\n            else:\n                _, idx_next = torch.topk(probs, k=1, dim=-1)\n            # append sampled index to the running sequence and continue\n            idx = torch.cat((idx, idx_next), dim=1)\n\n        return idx\n\n# -----------------------------------------------------------------------------\n# helper functions for evaluating and sampling from the model\n\ndef print_samples(num=10):\n    \"\"\" samples from the model and pretty prints the decoded samples \"\"\"\n    X_init = torch.zeros(num, 1, dtype=torch.long).to(args.device)\n    top_k = args.top_k if args.top_k != -1 else None\n    steps = train_dataset.get_output_length() - 1 # -1 because we already start with <START> token (index 0)\n    X_samp = model.generate(X_init, steps, top_k=top_k, do_sample=True).to('cpu')\n    train_samples, test_samples, new_samples = [], [], []\n    for i in range(X_samp.size(0)):\n        # get the i'th row of sampled integers, as python list\n        row = X_samp[i, 1:].tolist() # note: we need to crop out the first <START> token\n        # token 0 is the <STOP> token, so we crop the output sequence at that point\n        crop_index = row.index(0) if 0 in row else len(row)\n        row = row[:crop_index]\n        word_samp = train_dataset.decode(row)\n        # separately track samples that we have and have not seen before\n        if train_dataset.contains(word_samp):\n            train_samples.append(word_samp)\n        elif test_dataset.contains(word_samp):\n            test_samples.append(word_samp)\n        else:\n            new_samples.append(word_samp)\n    print('-'*80)\n    for lst, desc in [(train_samples, 'in train'), (test_samples, 'in test'), (new_samples, 'new')]:\n        print(f\"{len(lst)} samples that are {desc}:\")\n        for word in lst:\n            print(word)\n    print('-'*80)\n\n@torch.inference_mode()\ndef evaluate(model, dataset, batch_size=50, max_batches=None):\n    model.eval()\n    loader = DataLoader(dataset, shuffle=True, batch_size=batch_size, num_workers=0)\n    losses = []\n    for i, batch in enumerate(loader):\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n        logits, loss = model(X, Y)\n        losses.append(loss.item())\n        if max_batches is not None and i >= max_batches:\n            break\n    mean_loss = torch.tensor(losses).mean().item()\n    model.train() # reset model back to training mode\n    return mean_loss\n\n# -----------------------------------------------------------------------------\n# helper functions for creating the training and test Datasets that emit words\n\nclass CharDataset(Dataset):\n\n    def __init__(self, words, chars, max_word_length):\n        self.words = words\n        self.chars = chars\n        self.max_word_length = max_word_length\n        self.stoi = {ch:i+1 for i,ch in enumerate(chars)}\n        self.itos = {i:s for s,i in self.stoi.items()} # inverse mapping\n\n    def __len__(self):\n        return len(self.words)\n\n    def contains(self, word):\n        return word in self.words\n\n    def get_vocab_size(self):\n        return len(self.chars) + 1 # all the possible characters and special 0 token\n\n    def get_output_length(self):\n        return self.max_word_length + 1 # <START> token followed by words\n\n    def encode(self, word):\n        ix = torch.tensor([self.stoi[w] for w in word], dtype=torch.long)\n        return ix\n\n    def decode(self, ix):\n        word = ''.join(self.itos[i] for i in ix)\n        return word\n\n    def __getitem__(self, idx):\n        word = self.words[idx]\n        ix = self.encode(word)\n        x = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        y = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        x[1:1+len(ix)] = ix\n        y[:len(ix)] = ix\n        y[len(ix)+1:] = -1 # index -1 will mask the loss at the inactive locations\n        return x, y\n\ndef create_datasets(input_file):\n\n    # preprocessing of the input text file\n    with open(input_file, 'r') as f:\n        data = f.read()\n    words = data.splitlines()\n    words = [w.strip() for w in words] # get rid of any leading or trailing white space\n    words = [w for w in words if w] # get rid of any empty strings\n    chars = sorted(list(set(''.join(words)))) # all the possible characters\n    max_word_length = max(len(w) for w in words)\n    print(f\"number of examples in the dataset: {len(words)}\")\n    print(f\"max word length: {max_word_length}\")\n    print(f\"number of unique characters in the vocabulary: {len(chars)}\")\n    print(\"vocabulary:\")\n    print(''.join(chars))\n\n    # partition the input data into a training and the test set\n    test_set_size = min(1000, int(len(words) * 0.1)) # 10% of the training set, or up to 1000 examples\n    rp = torch.randperm(len(words)).tolist()\n    train_words = [words[i] for i in rp[:-test_set_size]]\n    test_words = [words[i] for i in rp[-test_set_size:]]\n    print(f\"split up the dataset into {len(train_words)} training examples and {len(test_words)} test examples\")\n\n    # wrap in dataset objects\n    train_dataset = CharDataset(train_words, chars, max_word_length)\n    test_dataset = CharDataset(test_words, chars, max_word_length)\n\n    return train_dataset, test_dataset\n\n# -----------------------------------------------------------------------------\nif __name__ == '__main__':\n\n    # parse command line args\n    parser = argparse.ArgumentParser(description=\"Make More\")\n    # system/input/output\n    parser.add_argument('--input-file', '-i', type=str, default='names.txt', help=\"input file with things one per line\")\n    parser.add_argument('--work-dir', '-o', type=str, default='out', help=\"output working directory\")\n    parser.add_argument('--resume', action='store_true', help=\"when this flag is used, we will resume optimization from existing model in the workdir\")\n    parser.add_argument('--sample-only', action='store_true', help=\"just sample from the model and quit, don't train\")\n    parser.add_argument('--num-workers', '-n', type=int, default=4, help=\"number of data workers for both train/test\")\n    parser.add_argument('--max-steps', type=int, default=-1, help=\"max number of optimization steps to run for, or -1 for infinite.\")\n    parser.add_argument('--device', type=str, default='cpu', help=\"device to use for compute, examples: cpu|cuda|cuda:2|mps\")\n    parser.add_argument('--seed', type=int, default=3407, help=\"seed\")\n    # sampling\n    parser.add_argument('--top-k', type=int, default=-1, help=\"top-k for sampling, -1 means no top-k\")\n    # model\n    parser.add_argument('--n-layer', type=int, default=4, help=\"number of layers in the transformer\")\n    parser.add_argument('--n-head', type=int, default=4, help=\"number of heads in the transformer\")\n    parser.add_argument('--n-embd', type=int, default=64, help=\"number of feature channels in the transformer\")\n    # optimization\n    parser.add_argument('--batch-size', '-b', type=int, default=32, help=\"batch size during optimization\")\n    parser.add_argument('--learning-rate', '-l', type=float, default=5e-4, help=\"learning rate\")\n    parser.add_argument('--weight-decay', '-w', type=float, default=0.01, help=\"weight decay\")\n    args = parser.parse_args()\n    print(vars(args))\n\n    # system inits\n    torch.manual_seed(args.seed)\n    torch.cuda.manual_seed_all(args.seed)\n    os.makedirs(args.work_dir, exist_ok=True)\n    writer = SummaryWriter(log_dir=args.work_dir)\n\n    # init datasets\n    train_dataset, test_dataset = create_datasets(args.input_file)\n    vocab_size = train_dataset.get_vocab_size()\n    block_size = train_dataset.get_output_length()\n    print(f\"dataset determined that: {vocab_size=}, {block_size=}\")\n\n    # init model\n    config = GPTConfig(vocab_size=vocab_size, block_size=block_size,\n                       n_layer=args.n_layer, n_head=args.n_head, n_embd=args.n_embd)\n    model = GPT(config)\n    model.to(args.device)\n    print(f\"model #params: {sum(p.numel() for p in model.parameters())}\")\n    if args.resume or args.sample_only: # note: if we sample-only then we also assume we're resuming\n        print(\"resuming from existing model in the workdir\")\n        model.load_state_dict(torch.load(os.path.join(args.work_dir, 'model.pt')))\n    if args.sample_only:\n        print_samples(num=50)\n        sys.exit()\n\n    # init optimizer\n    optimizer = torch.optim.AdamW(model.parameters(), lr=args.learning_rate, weight_decay=args.weight_decay,\n                                betas=(0.9, 0.99), eps=1e-8)\n\n    # init dataloader\n    train_sampler = torch.utils.data.RandomSampler(train_dataset, replacement=True, num_samples=int(1e10))\n    train_loader = DataLoader(train_dataset, batch_size=args.batch_size, pin_memory=True,\n                              num_workers=args.num_workers, sampler=train_sampler)\n    data_iter = iter(train_loader)\n\n    # training loop\n    best_loss = None\n    step = 0\n    while True:\n\n        t0 = time.time()\n        # fetch the next batch and reset dataloader every epoch as necessary\n        try:\n            batch = next(data_iter)\n        except StopIteration:\n            data_iter = iter(train_loader)\n            batch = next(data_iter)\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n\n        # feed into the model\n        logits, loss = model(X, Y)\n\n        # calculate the gradient, clip it, update the weights\n        model.zero_grad(set_to_none=True)\n        loss.backward()\n        optimizer.step()\n        if args.device.startswith('cuda'):\n            torch.cuda.synchronize()\n        t1 = time.time()\n\n        # logging\n        if step % 10 == 0:\n            print(f\"step {step} | loss {loss.item():.4f} | step time {(t1-t0)*1000:.2f}ms\")\n\n        # evaluate the model\n        if step > 0 and step % 500 == 0:\n            train_loss = evaluate(model, train_dataset, batch_size=100, max_batches=10)\n            test_loss  = evaluate(model, test_dataset,  batch_size=100, max_batches=10)\n            writer.add_scalar(\"Loss/train\", train_loss, step)\n            writer.add_scalar(\"Loss/test\", test_loss, step)\n            writer.flush()\n            print(f\"step {step} train loss: {train_loss} test loss: {test_loss}\")\n            # save the model to disk if it has improved\n            if best_loss is None or test_loss < best_loss:\n                out_path = os.path.join(args.work_dir, \"model.pt\")\n                print(f\"test loss {test_loss} is the best so far, saving model to {out_path}\")\n                torch.save(model.state_dict(), out_path)\n                best_loss = test_loss\n\n        # sample from the model\n        if step > 0 and step % 200 == 0:\n            print_samples(num=10)\n\n        step += 1\n        # termination conditions\n        if args.max_steps >= 0 and step >= args.max_steps:\n            break\n\n", "diff": "@@ -382,7 +382,6 @@ def create_datasets(input_file):\n         # calculate the gradient, clip it, update the weights\n         model.zero_grad(set_to_none=True)\n         loss.backward()\n-        torch.nn.utils.clip_grad_norm_(model.parameters(), 1.0)\n         optimizer.step()\n         if args.device.startswith('cuda'):\n             torch.cuda.synchronize()", "status": "modified"}, {"commit_id": "35435ec08796c725cc348cdc53b9bae02dd33d05", "commit_message": "simplify optimizer init and delete code", "relative_path": "makemore.py", "previous_code_file": "\"\"\"\nyou give this script some words (one per line) and it will generate more things like it.\nuses super state of the art Transformer AI tech\nthis code is intended to be super hackable. tune it to your needs.\n\nChanges from minGPT:\n- I removed the from_pretrained function where we init with GPT2 weights\n- I removed dropout layers because the models we train here are small,\n  it's not necessary to understand at this stage and at this scale.\n- I removed weight decay and all of the complexity around what parameters are\n  and are not weight decayed. I don't believe this should make a massive\n  difference at the scale that we operate on here.\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport math\nimport argparse\nfrom dataclasses import dataclass\nfrom typing import List\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\nfrom torch.utils.data import Dataset\nfrom torch.utils.data.dataloader import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\n# -----------------------------------------------------------------------------\n# GPT model definition\n\n@dataclass\nclass GPTConfig:\n    # size of the model\n    n_layer: int = 4\n    n_head: int = 4\n    n_embd: int = 64\n    vocab_size: int = None\n    block_size: int = None\n\n@dataclass\nclass TrainConfig:\n    # optimization parameters\n    learning_rate: float = 5e-4\n    betas: List[float] = (0.9, 0.99)\n    weight_decay: float = 0.01\n\nclass NewGELU(nn.Module):\n    \"\"\"\n    Implementation of the GELU activation function currently in Google BERT repo (identical to OpenAI GPT).\n    Reference: Gaussian Error Linear Units (GELU) paper: https://arxiv.org/abs/1606.08415\n    \"\"\"\n    def forward(self, x):\n        return 0.5 * x * (1.0 + torch.tanh(math.sqrt(2.0 / math.pi) * (x + 0.044715 * torch.pow(x, 3.0))))\n\nclass CausalSelfAttention(nn.Module):\n    \"\"\"\n    A vanilla multi-head masked self-attention layer with a projection at the end.\n    It is possible to use torch.nn.MultiheadAttention here but I am including an\n    explicit implementation here to show that there is nothing too scary here.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.n_embd % config.n_head == 0\n        # key, query, value projections for all heads, but in a batch\n        self.c_attn = nn.Linear(config.n_embd, 3 * config.n_embd)\n        # output projection\n        self.c_proj = nn.Linear(config.n_embd, config.n_embd)\n        # causal mask to ensure that attention is only applied to the left in the input sequence\n        self.register_buffer(\"bias\", torch.tril(torch.ones(config.block_size, config.block_size))\n                                     .view(1, 1, config.block_size, config.block_size))\n        self.n_head = config.n_head\n        self.n_embd = config.n_embd\n\n    def forward(self, x):\n        B, T, C = x.size() # batch size, sequence length, embedding dimensionality (n_embd)\n\n        # calculate query, key, values for all heads in batch and move head forward to be the batch dim\n        q, k ,v  = self.c_attn(x).split(self.n_embd, dim=2)\n        k = k.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        q = q.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        v = v.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n\n        # causal self-attention; Self-attend: (B, nh, T, hs) x (B, nh, hs, T) -> (B, nh, T, T)\n        att = (q @ k.transpose(-2, -1)) * (1.0 / math.sqrt(k.size(-1)))\n        att = att.masked_fill(self.bias[:,:,:T,:T] == 0, float('-inf'))\n        att = F.softmax(att, dim=-1)\n        y = att @ v # (B, nh, T, T) x (B, nh, T, hs) -> (B, nh, T, hs)\n        y = y.transpose(1, 2).contiguous().view(B, T, C) # re-assemble all head outputs side by side\n\n        # output projection\n        y = self.c_proj(y)\n        return y\n\nclass Block(nn.Module):\n    \"\"\" an unassuming Transformer block \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.ln_1 = nn.LayerNorm(config.n_embd)\n        self.attn = CausalSelfAttention(config)\n        self.ln_2 = nn.LayerNorm(config.n_embd)\n        self.mlp = nn.ModuleDict(dict(\n            c_fc    = nn.Linear(config.n_embd, 4 * config.n_embd),\n            c_proj  = nn.Linear(4 * config.n_embd, config.n_embd),\n            act     = NewGELU(),\n        ))\n        m = self.mlp\n        self.mlpf = lambda x: m.c_proj(m.act(m.c_fc(x))) # MLP forward\n\n    def forward(self, x):\n        x = x + self.attn(self.ln_1(x))\n        x = x + self.mlpf(self.ln_2(x))\n        return x\n\nclass GPT(nn.Module):\n    \"\"\" GPT Language Model \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.vocab_size is not None\n        assert config.block_size is not None\n        self.block_size = config.block_size\n\n        self.transformer = nn.ModuleDict(dict(\n            wte = nn.Embedding(config.vocab_size, config.n_embd),\n            wpe = nn.Embedding(config.block_size, config.n_embd),\n            h = nn.ModuleList([Block(config) for _ in range(config.n_layer)]),\n            ln_f = nn.LayerNorm(config.n_embd),\n        ))\n        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n\n        # report number of parameters (note we don't count the decoder parameters in lm_head)\n        n_params = sum(p.numel() for p in self.transformer.parameters())\n        print(\"number of parameters: %.2fM\" % (n_params/1e6,))\n\n    def configure_optimizers(self, train_config):\n        optimizer = torch.optim.AdamW(self.parameters(), lr=train_config.learning_rate,\n                                      betas=train_config.betas, weight_decay=train_config.weight_decay,\n                                      eps=1e-8)\n        return optimizer\n\n    def forward(self, idx, targets=None):\n        device = idx.device\n        b, t = idx.size()\n        assert t <= self.block_size, f\"Cannot forward sequence of length {t}, block size is only {self.block_size}\"\n        pos = torch.arange(0, t, dtype=torch.long, device=device).unsqueeze(0) # shape (1, t)\n\n        # forward the GPT model itself\n        tok_emb = self.transformer.wte(idx) # token embeddings of shape (b, t, n_embd)\n        pos_emb = self.transformer.wpe(pos) # position embeddings of shape (1, t, n_embd)\n        x = tok_emb + pos_emb\n        for block in self.transformer.h:\n            x = block(x)\n        x = self.transformer.ln_f(x)\n        logits = self.lm_head(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n    @torch.no_grad()\n    def generate(self, idx, max_new_tokens, temperature=1.0, do_sample=False, top_k=None):\n        \"\"\"\n        Take a conditioning sequence of indices idx (LongTensor of shape (b,t)) and complete\n        the sequence max_new_tokens times, feeding the predictions back into the model each time.\n        Most likely you'll want to make sure to be in model.eval() mode of operation for this.\n        \"\"\"\n        for _ in range(max_new_tokens):\n            # if the sequence context is growing too long we must crop it at block_size\n            idx_cond = idx if idx.size(1) <= self.block_size else idx[:, -self.block_size:]\n            # forward the model to get the logits for the index in the sequence\n            logits, _ = self(idx_cond)\n            # pluck the logits at the final step and scale by desired temperature\n            logits = logits[:, -1, :] / temperature\n            # optionally crop the logits to only the top k options\n            if top_k is not None:\n                v, _ = torch.topk(logits, top_k)\n                logits[logits < v[:, [-1]]] = -float('Inf')\n            # apply softmax to convert logits to (normalized) probabilities\n            probs = F.softmax(logits, dim=-1)\n            # either sample from the distribution or take the most likely element\n            if do_sample:\n                idx_next = torch.multinomial(probs, num_samples=1)\n            else:\n                _, idx_next = torch.topk(probs, k=1, dim=-1)\n            # append sampled index to the running sequence and continue\n            idx = torch.cat((idx, idx_next), dim=1)\n\n        return idx\n\n# -----------------------------------------------------------------------------\n# helper functions for evaluating and sampling from the model\n\ndef print_samples(num=10):\n    \"\"\" samples from the model and pretty prints the decoded samples \"\"\"\n    X_init = torch.zeros(num, 1, dtype=torch.long).to(args.device)\n    top_k = args.top_k if args.top_k != -1 else None\n    steps = train_dataset.get_output_length() - 1 # -1 because we already start with <START> token (index 0)\n    X_samp = model.generate(X_init, steps, top_k=top_k, do_sample=True).to('cpu')\n    train_samples, test_samples, new_samples = [], [], []\n    for i in range(X_samp.size(0)):\n        # get the i'th row of sampled integers, as python list\n        row = X_samp[i, 1:].tolist() # note: we need to crop out the first <START> token\n        # token 0 is the <STOP> token, so we crop the output sequence at that point\n        crop_index = row.index(0) if 0 in row else len(row)\n        row = row[:crop_index]\n        word_samp = train_dataset.decode(row)\n        # separately track samples that we have and have not seen before\n        if train_dataset.contains(word_samp):\n            train_samples.append(word_samp)\n        elif test_dataset.contains(word_samp):\n            test_samples.append(word_samp)\n        else:\n            new_samples.append(word_samp)\n    print('-'*80)\n    for lst, desc in [(train_samples, 'in train'), (test_samples, 'in test'), (new_samples, 'new')]:\n        print(f\"{len(lst)} samples that are {desc}:\")\n        for word in lst:\n            print(word)\n    print('-'*80)\n\n@torch.inference_mode()\ndef evaluate(model, dataset, batch_size=50, max_batches=None):\n    model.eval()\n    loader = DataLoader(dataset, shuffle=True, batch_size=batch_size, num_workers=0)\n    losses = []\n    for i, batch in enumerate(loader):\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n        logits, loss = model(X, Y)\n        losses.append(loss.item())\n        if max_batches is not None and i >= max_batches:\n            break\n    mean_loss = torch.tensor(losses).mean().item()\n    model.train() # reset model back to training mode\n    return mean_loss\n\n# -----------------------------------------------------------------------------\n# helper functions for creating the training and test Datasets that emit words\n\nclass CharDataset(Dataset):\n\n    def __init__(self, words, chars, max_word_length):\n        self.words = words\n        self.chars = chars\n        self.max_word_length = max_word_length\n        self.stoi = {ch:i+1 for i,ch in enumerate(chars)}\n        self.itos = {i:s for s,i in self.stoi.items()} # inverse mapping\n\n    def __len__(self):\n        return len(self.words)\n\n    def contains(self, word):\n        return word in self.words\n\n    def get_vocab_size(self):\n        return len(self.chars) + 1 # all the possible characters and special 0 token\n\n    def get_output_length(self):\n        return self.max_word_length + 1 # <START> token followed by words\n\n    def encode(self, word):\n        ix = torch.tensor([self.stoi[w] for w in word], dtype=torch.long)\n        return ix\n\n    def decode(self, ix):\n        word = ''.join(self.itos[i] for i in ix)\n        return word\n\n    def __getitem__(self, idx):\n        word = self.words[idx]\n        ix = self.encode(word)\n        x = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        y = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        x[1:1+len(ix)] = ix\n        y[:len(ix)] = ix\n        y[len(ix)+1:] = -1 # index -1 will mask the loss at the inactive locations\n        return x, y\n\ndef create_datasets(input_file):\n\n    # preprocessing of the input text file\n    with open(input_file, 'r') as f:\n        data = f.read()\n    words = data.splitlines()\n    words = [w.strip() for w in words] # get rid of any leading or trailing white space\n    words = [w for w in words if w] # get rid of any empty strings\n    chars = sorted(list(set(''.join(words)))) # all the possible characters\n    max_word_length = max(len(w) for w in words)\n    print(f\"number of examples in the dataset: {len(words)}\")\n    print(f\"max word length: {max_word_length}\")\n    print(f\"number of unique characters in the vocabulary: {len(chars)}\")\n    print(\"vocabulary:\")\n    print(''.join(chars))\n\n    # partition the input data into a training and the test set\n    test_set_size = min(1000, int(len(words) * 0.1)) # 10% of the training set, or up to 1000 examples\n    rp = torch.randperm(len(words)).tolist()\n    train_words = [words[i] for i in rp[:-test_set_size]]\n    test_words = [words[i] for i in rp[-test_set_size:]]\n    print(f\"split up the dataset into {len(train_words)} training examples and {len(test_words)} test examples\")\n\n    # wrap in dataset objects\n    train_dataset = CharDataset(train_words, chars, max_word_length)\n    test_dataset = CharDataset(test_words, chars, max_word_length)\n\n    return train_dataset, test_dataset\n\n# -----------------------------------------------------------------------------\nif __name__ == '__main__':\n\n    # parse command line args\n    parser = argparse.ArgumentParser(description=\"Make More\")\n    # system/input/output\n    parser.add_argument('--input-file', '-i', type=str, default='names.txt', help=\"input file with things one per line\")\n    parser.add_argument('--work-dir', '-o', type=str, default='out', help=\"output working directory\")\n    parser.add_argument('--resume', action='store_true', help=\"when this flag is used, we will resume optimization from existing model in the workdir\")\n    parser.add_argument('--sample-only', action='store_true', help=\"just sample from the model and quit, don't train\")\n    parser.add_argument('--num-workers', '-n', type=int, default=4, help=\"number of data workers for both train/test\")\n    parser.add_argument('--max-steps', type=int, default=-1, help=\"max number of optimization steps to run for, or -1 for infinite.\")\n    parser.add_argument('--device', type=str, default='cpu', help=\"device to use for compute, examples: cpu|cuda|cuda:2|mps\")\n    parser.add_argument('--seed', type=int, default=3407, help=\"seed\")\n    # sampling\n    parser.add_argument('--top-k', type=int, default=-1, help=\"top-k for sampling, -1 means no top-k\")\n    # model\n    parser.add_argument('--n-layer', type=int, default=4, help=\"number of layers in the transformer\")\n    parser.add_argument('--n-head', type=int, default=4, help=\"number of heads in the transformer\")\n    parser.add_argument('--n-embd', type=int, default=64, help=\"number of feature channels in the transformer\")\n    # optimization\n    parser.add_argument('--batch-size', '-b', type=int, default=32, help=\"batch size during optimization\")\n    parser.add_argument('--learning-rate', '-l', type=float, default=5e-4, help=\"learning rate\")\n    parser.add_argument('--weight-decay', '-w', type=float, default=0.01, help=\"weight decay\")\n    args = parser.parse_args()\n    print(vars(args))\n\n    # system inits\n    torch.manual_seed(args.seed)\n    torch.cuda.manual_seed_all(args.seed)\n    os.makedirs(args.work_dir, exist_ok=True)\n    writer = SummaryWriter(log_dir=args.work_dir)\n\n    # init datasets\n    train_dataset, test_dataset = create_datasets(args.input_file)\n    vocab_size = train_dataset.get_vocab_size()\n    block_size = train_dataset.get_output_length()\n    print(f\"dataset determined that: {vocab_size=}, {block_size=}\")\n\n    # init model\n    config = GPTConfig(vocab_size=vocab_size, block_size=block_size,\n                       n_layer=args.n_layer, n_head=args.n_head, n_embd=args.n_embd)\n    model = GPT(config)\n    model.to(args.device)\n    print(f\"model #params: {sum(p.numel() for p in model.parameters())}\")\n    if args.resume or args.sample_only: # note: if we sample-only then we also assume we're resuming\n        print(\"resuming from existing model in the workdir\")\n        model.load_state_dict(torch.load(os.path.join(args.work_dir, 'model.pt')))\n    if args.sample_only:\n        print_samples(num=50)\n        sys.exit()\n\n    # init optimizer\n    train_config = TrainConfig(learning_rate=args.learning_rate, weight_decay=args.weight_decay)\n    optimizer = model.configure_optimizers(train_config)\n\n    # init dataloader\n    train_sampler = torch.utils.data.RandomSampler(train_dataset, replacement=True, num_samples=int(1e10))\n    train_loader = DataLoader(train_dataset, batch_size=args.batch_size, pin_memory=True,\n                              num_workers=args.num_workers, sampler=train_sampler)\n    data_iter = iter(train_loader)\n\n    # training loop\n    best_loss = None\n    step = 0\n    while True:\n\n        t0 = time.time()\n        # fetch the next batch and reset dataloader every epoch as necessary\n        try:\n            batch = next(data_iter)\n        except StopIteration:\n            data_iter = iter(train_loader)\n            batch = next(data_iter)\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n\n        # feed into the model\n        logits, loss = model(X, Y)\n\n        # calculate the gradient, clip it, update the weights\n        model.zero_grad(set_to_none=True)\n        loss.backward()\n        torch.nn.utils.clip_grad_norm_(model.parameters(), 1.0)\n        optimizer.step()\n        if args.device.startswith('cuda'):\n            torch.cuda.synchronize()\n        t1 = time.time()\n\n        # logging\n        if step % 10 == 0:\n            print(f\"step {step} | loss {loss.item():.4f} | step time {(t1-t0)*1000:.2f}ms\")\n\n        # evaluate the model\n        if step > 0 and step % 500 == 0:\n            train_loss = evaluate(model, train_dataset, batch_size=100, max_batches=10)\n            test_loss  = evaluate(model, test_dataset,  batch_size=100, max_batches=10)\n            writer.add_scalar(\"Loss/train\", train_loss, step)\n            writer.add_scalar(\"Loss/test\", test_loss, step)\n            writer.flush()\n            print(f\"step {step} train loss: {train_loss} test loss: {test_loss}\")\n            # save the model to disk if it has improved\n            if best_loss is None or test_loss < best_loss:\n                out_path = os.path.join(args.work_dir, \"model.pt\")\n                print(f\"test loss {test_loss} is the best so far, saving model to {out_path}\")\n                torch.save(model.state_dict(), out_path)\n                best_loss = test_loss\n\n        # sample from the model\n        if step > 0 and step % 200 == 0:\n            print_samples(num=10)\n\n        step += 1\n        # termination conditions\n        if args.max_steps >= 0 and step >= args.max_steps:\n            break\n\n", "previous_id": "d26d9750ee99206b2aa29e149a5a23dc0df50ded", "new_code_file": "\"\"\"\nyou give this script some words (one per line) and it will generate more things like it.\nuses super state of the art Transformer AI tech\nthis code is intended to be super hackable. tune it to your needs.\n\nChanges from minGPT:\n- I removed the from_pretrained function where we init with GPT2 weights\n- I removed dropout layers because the models we train here are small,\n  it's not necessary to understand at this stage and at this scale.\n- I removed weight decay and all of the complexity around what parameters are\n  and are not weight decayed. I don't believe this should make a massive\n  difference at the scale that we operate on here.\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport math\nimport argparse\nfrom dataclasses import dataclass\nfrom typing import List\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\nfrom torch.utils.data import Dataset\nfrom torch.utils.data.dataloader import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\n# -----------------------------------------------------------------------------\n# GPT model definition\n\n@dataclass\nclass GPTConfig:\n    # size of the model\n    n_layer: int = 4\n    n_head: int = 4\n    n_embd: int = 64\n    vocab_size: int = None\n    block_size: int = None\n\nclass NewGELU(nn.Module):\n    \"\"\"\n    Implementation of the GELU activation function currently in Google BERT repo (identical to OpenAI GPT).\n    Reference: Gaussian Error Linear Units (GELU) paper: https://arxiv.org/abs/1606.08415\n    \"\"\"\n    def forward(self, x):\n        return 0.5 * x * (1.0 + torch.tanh(math.sqrt(2.0 / math.pi) * (x + 0.044715 * torch.pow(x, 3.0))))\n\nclass CausalSelfAttention(nn.Module):\n    \"\"\"\n    A vanilla multi-head masked self-attention layer with a projection at the end.\n    It is possible to use torch.nn.MultiheadAttention here but I am including an\n    explicit implementation here to show that there is nothing too scary here.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.n_embd % config.n_head == 0\n        # key, query, value projections for all heads, but in a batch\n        self.c_attn = nn.Linear(config.n_embd, 3 * config.n_embd)\n        # output projection\n        self.c_proj = nn.Linear(config.n_embd, config.n_embd)\n        # causal mask to ensure that attention is only applied to the left in the input sequence\n        self.register_buffer(\"bias\", torch.tril(torch.ones(config.block_size, config.block_size))\n                                     .view(1, 1, config.block_size, config.block_size))\n        self.n_head = config.n_head\n        self.n_embd = config.n_embd\n\n    def forward(self, x):\n        B, T, C = x.size() # batch size, sequence length, embedding dimensionality (n_embd)\n\n        # calculate query, key, values for all heads in batch and move head forward to be the batch dim\n        q, k ,v  = self.c_attn(x).split(self.n_embd, dim=2)\n        k = k.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        q = q.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        v = v.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n\n        # causal self-attention; Self-attend: (B, nh, T, hs) x (B, nh, hs, T) -> (B, nh, T, T)\n        att = (q @ k.transpose(-2, -1)) * (1.0 / math.sqrt(k.size(-1)))\n        att = att.masked_fill(self.bias[:,:,:T,:T] == 0, float('-inf'))\n        att = F.softmax(att, dim=-1)\n        y = att @ v # (B, nh, T, T) x (B, nh, T, hs) -> (B, nh, T, hs)\n        y = y.transpose(1, 2).contiguous().view(B, T, C) # re-assemble all head outputs side by side\n\n        # output projection\n        y = self.c_proj(y)\n        return y\n\nclass Block(nn.Module):\n    \"\"\" an unassuming Transformer block \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.ln_1 = nn.LayerNorm(config.n_embd)\n        self.attn = CausalSelfAttention(config)\n        self.ln_2 = nn.LayerNorm(config.n_embd)\n        self.mlp = nn.ModuleDict(dict(\n            c_fc    = nn.Linear(config.n_embd, 4 * config.n_embd),\n            c_proj  = nn.Linear(4 * config.n_embd, config.n_embd),\n            act     = NewGELU(),\n        ))\n        m = self.mlp\n        self.mlpf = lambda x: m.c_proj(m.act(m.c_fc(x))) # MLP forward\n\n    def forward(self, x):\n        x = x + self.attn(self.ln_1(x))\n        x = x + self.mlpf(self.ln_2(x))\n        return x\n\nclass GPT(nn.Module):\n    \"\"\" GPT Language Model \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.vocab_size is not None\n        assert config.block_size is not None\n        self.block_size = config.block_size\n\n        self.transformer = nn.ModuleDict(dict(\n            wte = nn.Embedding(config.vocab_size, config.n_embd),\n            wpe = nn.Embedding(config.block_size, config.n_embd),\n            h = nn.ModuleList([Block(config) for _ in range(config.n_layer)]),\n            ln_f = nn.LayerNorm(config.n_embd),\n        ))\n        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n\n        # report number of parameters (note we don't count the decoder parameters in lm_head)\n        n_params = sum(p.numel() for p in self.transformer.parameters())\n        print(\"number of parameters: %.2fM\" % (n_params/1e6,))\n\n    def forward(self, idx, targets=None):\n        device = idx.device\n        b, t = idx.size()\n        assert t <= self.block_size, f\"Cannot forward sequence of length {t}, block size is only {self.block_size}\"\n        pos = torch.arange(0, t, dtype=torch.long, device=device).unsqueeze(0) # shape (1, t)\n\n        # forward the GPT model itself\n        tok_emb = self.transformer.wte(idx) # token embeddings of shape (b, t, n_embd)\n        pos_emb = self.transformer.wpe(pos) # position embeddings of shape (1, t, n_embd)\n        x = tok_emb + pos_emb\n        for block in self.transformer.h:\n            x = block(x)\n        x = self.transformer.ln_f(x)\n        logits = self.lm_head(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n    @torch.no_grad()\n    def generate(self, idx, max_new_tokens, temperature=1.0, do_sample=False, top_k=None):\n        \"\"\"\n        Take a conditioning sequence of indices idx (LongTensor of shape (b,t)) and complete\n        the sequence max_new_tokens times, feeding the predictions back into the model each time.\n        Most likely you'll want to make sure to be in model.eval() mode of operation for this.\n        \"\"\"\n        for _ in range(max_new_tokens):\n            # if the sequence context is growing too long we must crop it at block_size\n            idx_cond = idx if idx.size(1) <= self.block_size else idx[:, -self.block_size:]\n            # forward the model to get the logits for the index in the sequence\n            logits, _ = self(idx_cond)\n            # pluck the logits at the final step and scale by desired temperature\n            logits = logits[:, -1, :] / temperature\n            # optionally crop the logits to only the top k options\n            if top_k is not None:\n                v, _ = torch.topk(logits, top_k)\n                logits[logits < v[:, [-1]]] = -float('Inf')\n            # apply softmax to convert logits to (normalized) probabilities\n            probs = F.softmax(logits, dim=-1)\n            # either sample from the distribution or take the most likely element\n            if do_sample:\n                idx_next = torch.multinomial(probs, num_samples=1)\n            else:\n                _, idx_next = torch.topk(probs, k=1, dim=-1)\n            # append sampled index to the running sequence and continue\n            idx = torch.cat((idx, idx_next), dim=1)\n\n        return idx\n\n# -----------------------------------------------------------------------------\n# helper functions for evaluating and sampling from the model\n\ndef print_samples(num=10):\n    \"\"\" samples from the model and pretty prints the decoded samples \"\"\"\n    X_init = torch.zeros(num, 1, dtype=torch.long).to(args.device)\n    top_k = args.top_k if args.top_k != -1 else None\n    steps = train_dataset.get_output_length() - 1 # -1 because we already start with <START> token (index 0)\n    X_samp = model.generate(X_init, steps, top_k=top_k, do_sample=True).to('cpu')\n    train_samples, test_samples, new_samples = [], [], []\n    for i in range(X_samp.size(0)):\n        # get the i'th row of sampled integers, as python list\n        row = X_samp[i, 1:].tolist() # note: we need to crop out the first <START> token\n        # token 0 is the <STOP> token, so we crop the output sequence at that point\n        crop_index = row.index(0) if 0 in row else len(row)\n        row = row[:crop_index]\n        word_samp = train_dataset.decode(row)\n        # separately track samples that we have and have not seen before\n        if train_dataset.contains(word_samp):\n            train_samples.append(word_samp)\n        elif test_dataset.contains(word_samp):\n            test_samples.append(word_samp)\n        else:\n            new_samples.append(word_samp)\n    print('-'*80)\n    for lst, desc in [(train_samples, 'in train'), (test_samples, 'in test'), (new_samples, 'new')]:\n        print(f\"{len(lst)} samples that are {desc}:\")\n        for word in lst:\n            print(word)\n    print('-'*80)\n\n@torch.inference_mode()\ndef evaluate(model, dataset, batch_size=50, max_batches=None):\n    model.eval()\n    loader = DataLoader(dataset, shuffle=True, batch_size=batch_size, num_workers=0)\n    losses = []\n    for i, batch in enumerate(loader):\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n        logits, loss = model(X, Y)\n        losses.append(loss.item())\n        if max_batches is not None and i >= max_batches:\n            break\n    mean_loss = torch.tensor(losses).mean().item()\n    model.train() # reset model back to training mode\n    return mean_loss\n\n# -----------------------------------------------------------------------------\n# helper functions for creating the training and test Datasets that emit words\n\nclass CharDataset(Dataset):\n\n    def __init__(self, words, chars, max_word_length):\n        self.words = words\n        self.chars = chars\n        self.max_word_length = max_word_length\n        self.stoi = {ch:i+1 for i,ch in enumerate(chars)}\n        self.itos = {i:s for s,i in self.stoi.items()} # inverse mapping\n\n    def __len__(self):\n        return len(self.words)\n\n    def contains(self, word):\n        return word in self.words\n\n    def get_vocab_size(self):\n        return len(self.chars) + 1 # all the possible characters and special 0 token\n\n    def get_output_length(self):\n        return self.max_word_length + 1 # <START> token followed by words\n\n    def encode(self, word):\n        ix = torch.tensor([self.stoi[w] for w in word], dtype=torch.long)\n        return ix\n\n    def decode(self, ix):\n        word = ''.join(self.itos[i] for i in ix)\n        return word\n\n    def __getitem__(self, idx):\n        word = self.words[idx]\n        ix = self.encode(word)\n        x = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        y = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        x[1:1+len(ix)] = ix\n        y[:len(ix)] = ix\n        y[len(ix)+1:] = -1 # index -1 will mask the loss at the inactive locations\n        return x, y\n\ndef create_datasets(input_file):\n\n    # preprocessing of the input text file\n    with open(input_file, 'r') as f:\n        data = f.read()\n    words = data.splitlines()\n    words = [w.strip() for w in words] # get rid of any leading or trailing white space\n    words = [w for w in words if w] # get rid of any empty strings\n    chars = sorted(list(set(''.join(words)))) # all the possible characters\n    max_word_length = max(len(w) for w in words)\n    print(f\"number of examples in the dataset: {len(words)}\")\n    print(f\"max word length: {max_word_length}\")\n    print(f\"number of unique characters in the vocabulary: {len(chars)}\")\n    print(\"vocabulary:\")\n    print(''.join(chars))\n\n    # partition the input data into a training and the test set\n    test_set_size = min(1000, int(len(words) * 0.1)) # 10% of the training set, or up to 1000 examples\n    rp = torch.randperm(len(words)).tolist()\n    train_words = [words[i] for i in rp[:-test_set_size]]\n    test_words = [words[i] for i in rp[-test_set_size:]]\n    print(f\"split up the dataset into {len(train_words)} training examples and {len(test_words)} test examples\")\n\n    # wrap in dataset objects\n    train_dataset = CharDataset(train_words, chars, max_word_length)\n    test_dataset = CharDataset(test_words, chars, max_word_length)\n\n    return train_dataset, test_dataset\n\n# -----------------------------------------------------------------------------\nif __name__ == '__main__':\n\n    # parse command line args\n    parser = argparse.ArgumentParser(description=\"Make More\")\n    # system/input/output\n    parser.add_argument('--input-file', '-i', type=str, default='names.txt', help=\"input file with things one per line\")\n    parser.add_argument('--work-dir', '-o', type=str, default='out', help=\"output working directory\")\n    parser.add_argument('--resume', action='store_true', help=\"when this flag is used, we will resume optimization from existing model in the workdir\")\n    parser.add_argument('--sample-only', action='store_true', help=\"just sample from the model and quit, don't train\")\n    parser.add_argument('--num-workers', '-n', type=int, default=4, help=\"number of data workers for both train/test\")\n    parser.add_argument('--max-steps', type=int, default=-1, help=\"max number of optimization steps to run for, or -1 for infinite.\")\n    parser.add_argument('--device', type=str, default='cpu', help=\"device to use for compute, examples: cpu|cuda|cuda:2|mps\")\n    parser.add_argument('--seed', type=int, default=3407, help=\"seed\")\n    # sampling\n    parser.add_argument('--top-k', type=int, default=-1, help=\"top-k for sampling, -1 means no top-k\")\n    # model\n    parser.add_argument('--n-layer', type=int, default=4, help=\"number of layers in the transformer\")\n    parser.add_argument('--n-head', type=int, default=4, help=\"number of heads in the transformer\")\n    parser.add_argument('--n-embd', type=int, default=64, help=\"number of feature channels in the transformer\")\n    # optimization\n    parser.add_argument('--batch-size', '-b', type=int, default=32, help=\"batch size during optimization\")\n    parser.add_argument('--learning-rate', '-l', type=float, default=5e-4, help=\"learning rate\")\n    parser.add_argument('--weight-decay', '-w', type=float, default=0.01, help=\"weight decay\")\n    args = parser.parse_args()\n    print(vars(args))\n\n    # system inits\n    torch.manual_seed(args.seed)\n    torch.cuda.manual_seed_all(args.seed)\n    os.makedirs(args.work_dir, exist_ok=True)\n    writer = SummaryWriter(log_dir=args.work_dir)\n\n    # init datasets\n    train_dataset, test_dataset = create_datasets(args.input_file)\n    vocab_size = train_dataset.get_vocab_size()\n    block_size = train_dataset.get_output_length()\n    print(f\"dataset determined that: {vocab_size=}, {block_size=}\")\n\n    # init model\n    config = GPTConfig(vocab_size=vocab_size, block_size=block_size,\n                       n_layer=args.n_layer, n_head=args.n_head, n_embd=args.n_embd)\n    model = GPT(config)\n    model.to(args.device)\n    print(f\"model #params: {sum(p.numel() for p in model.parameters())}\")\n    if args.resume or args.sample_only: # note: if we sample-only then we also assume we're resuming\n        print(\"resuming from existing model in the workdir\")\n        model.load_state_dict(torch.load(os.path.join(args.work_dir, 'model.pt')))\n    if args.sample_only:\n        print_samples(num=50)\n        sys.exit()\n\n    # init optimizer\n    optimizer = torch.optim.AdamW(model.parameters(), lr=args.learning_rate, weight_decay=args.weight_decay,\n                                betas=(0.9, 0.99), eps=1e-8)\n\n    # init dataloader\n    train_sampler = torch.utils.data.RandomSampler(train_dataset, replacement=True, num_samples=int(1e10))\n    train_loader = DataLoader(train_dataset, batch_size=args.batch_size, pin_memory=True,\n                              num_workers=args.num_workers, sampler=train_sampler)\n    data_iter = iter(train_loader)\n\n    # training loop\n    best_loss = None\n    step = 0\n    while True:\n\n        t0 = time.time()\n        # fetch the next batch and reset dataloader every epoch as necessary\n        try:\n            batch = next(data_iter)\n        except StopIteration:\n            data_iter = iter(train_loader)\n            batch = next(data_iter)\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n\n        # feed into the model\n        logits, loss = model(X, Y)\n\n        # calculate the gradient, clip it, update the weights\n        model.zero_grad(set_to_none=True)\n        loss.backward()\n        torch.nn.utils.clip_grad_norm_(model.parameters(), 1.0)\n        optimizer.step()\n        if args.device.startswith('cuda'):\n            torch.cuda.synchronize()\n        t1 = time.time()\n\n        # logging\n        if step % 10 == 0:\n            print(f\"step {step} | loss {loss.item():.4f} | step time {(t1-t0)*1000:.2f}ms\")\n\n        # evaluate the model\n        if step > 0 and step % 500 == 0:\n            train_loss = evaluate(model, train_dataset, batch_size=100, max_batches=10)\n            test_loss  = evaluate(model, test_dataset,  batch_size=100, max_batches=10)\n            writer.add_scalar(\"Loss/train\", train_loss, step)\n            writer.add_scalar(\"Loss/test\", test_loss, step)\n            writer.flush()\n            print(f\"step {step} train loss: {train_loss} test loss: {test_loss}\")\n            # save the model to disk if it has improved\n            if best_loss is None or test_loss < best_loss:\n                out_path = os.path.join(args.work_dir, \"model.pt\")\n                print(f\"test loss {test_loss} is the best so far, saving model to {out_path}\")\n                torch.save(model.state_dict(), out_path)\n                best_loss = test_loss\n\n        # sample from the model\n        if step > 0 and step % 200 == 0:\n            print_samples(num=10)\n\n        step += 1\n        # termination conditions\n        if args.max_steps >= 0 and step >= args.max_steps:\n            break\n\n", "diff": "@@ -39,13 +39,6 @@ class GPTConfig:\n     vocab_size: int = None\n     block_size: int = None\n \n-@dataclass\n-class TrainConfig:\n-    # optimization parameters\n-    learning_rate: float = 5e-4\n-    betas: List[float] = (0.9, 0.99)\n-    weight_decay: float = 0.01\n-\n class NewGELU(nn.Module):\n     \"\"\"\n     Implementation of the GELU activation function currently in Google BERT repo (identical to OpenAI GPT).\n@@ -136,12 +129,6 @@ def __init__(self, config):\n         n_params = sum(p.numel() for p in self.transformer.parameters())\n         print(\"number of parameters: %.2fM\" % (n_params/1e6,))\n \n-    def configure_optimizers(self, train_config):\n-        optimizer = torch.optim.AdamW(self.parameters(), lr=train_config.learning_rate,\n-                                      betas=train_config.betas, weight_decay=train_config.weight_decay,\n-                                      eps=1e-8)\n-        return optimizer\n-\n     def forward(self, idx, targets=None):\n         device = idx.device\n         b, t = idx.size()\n@@ -365,8 +352,8 @@ def create_datasets(input_file):\n         sys.exit()\n \n     # init optimizer\n-    train_config = TrainConfig(learning_rate=args.learning_rate, weight_decay=args.weight_decay)\n-    optimizer = model.configure_optimizers(train_config)\n+    optimizer = torch.optim.AdamW(model.parameters(), lr=args.learning_rate, weight_decay=args.weight_decay,\n+                                betas=(0.9, 0.99), eps=1e-8)\n \n     # init dataloader\n     train_sampler = torch.utils.data.RandomSampler(train_dataset, replacement=True, num_samples=int(1e10))", "status": "modified"}, {"commit_id": "d26d9750ee99206b2aa29e149a5a23dc0df50ded", "commit_message": "remove weight init, not needed at this scale", "relative_path": "makemore.py", "previous_code_file": "\"\"\"\nyou give this script some words (one per line) and it will generate more things like it.\nuses super state of the art Transformer AI tech\nthis code is intended to be super hackable. tune it to your needs.\n\nChanges from minGPT:\n- I removed the from_pretrained function where we init with GPT2 weights\n- I removed dropout layers because the models we train here are small,\n  it's not necessary to understand at this stage and at this scale.\n- I removed weight decay and all of the complexity around what parameters are\n  and are not weight decayed. I don't believe this should make a massive\n  difference at the scale that we operate on here.\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport math\nimport argparse\nfrom dataclasses import dataclass\nfrom typing import List\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\nfrom torch.utils.data import Dataset\nfrom torch.utils.data.dataloader import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\n# -----------------------------------------------------------------------------\n# GPT model definition\n\n@dataclass\nclass GPTConfig:\n    # size of the model\n    n_layer: int = 4\n    n_head: int = 4\n    n_embd: int = 64\n    vocab_size: int = None\n    block_size: int = None\n\n@dataclass\nclass TrainConfig:\n    # optimization parameters\n    learning_rate: float = 5e-4\n    betas: List[float] = (0.9, 0.99)\n    weight_decay: float = 0.01\n\nclass NewGELU(nn.Module):\n    \"\"\"\n    Implementation of the GELU activation function currently in Google BERT repo (identical to OpenAI GPT).\n    Reference: Gaussian Error Linear Units (GELU) paper: https://arxiv.org/abs/1606.08415\n    \"\"\"\n    def forward(self, x):\n        return 0.5 * x * (1.0 + torch.tanh(math.sqrt(2.0 / math.pi) * (x + 0.044715 * torch.pow(x, 3.0))))\n\nclass CausalSelfAttention(nn.Module):\n    \"\"\"\n    A vanilla multi-head masked self-attention layer with a projection at the end.\n    It is possible to use torch.nn.MultiheadAttention here but I am including an\n    explicit implementation here to show that there is nothing too scary here.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.n_embd % config.n_head == 0\n        # key, query, value projections for all heads, but in a batch\n        self.c_attn = nn.Linear(config.n_embd, 3 * config.n_embd)\n        # output projection\n        self.c_proj = nn.Linear(config.n_embd, config.n_embd)\n        # causal mask to ensure that attention is only applied to the left in the input sequence\n        self.register_buffer(\"bias\", torch.tril(torch.ones(config.block_size, config.block_size))\n                                     .view(1, 1, config.block_size, config.block_size))\n        self.n_head = config.n_head\n        self.n_embd = config.n_embd\n\n    def forward(self, x):\n        B, T, C = x.size() # batch size, sequence length, embedding dimensionality (n_embd)\n\n        # calculate query, key, values for all heads in batch and move head forward to be the batch dim\n        q, k ,v  = self.c_attn(x).split(self.n_embd, dim=2)\n        k = k.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        q = q.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        v = v.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n\n        # causal self-attention; Self-attend: (B, nh, T, hs) x (B, nh, hs, T) -> (B, nh, T, T)\n        att = (q @ k.transpose(-2, -1)) * (1.0 / math.sqrt(k.size(-1)))\n        att = att.masked_fill(self.bias[:,:,:T,:T] == 0, float('-inf'))\n        att = F.softmax(att, dim=-1)\n        y = att @ v # (B, nh, T, T) x (B, nh, T, hs) -> (B, nh, T, hs)\n        y = y.transpose(1, 2).contiguous().view(B, T, C) # re-assemble all head outputs side by side\n\n        # output projection\n        y = self.c_proj(y)\n        return y\n\nclass Block(nn.Module):\n    \"\"\" an unassuming Transformer block \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.ln_1 = nn.LayerNorm(config.n_embd)\n        self.attn = CausalSelfAttention(config)\n        self.ln_2 = nn.LayerNorm(config.n_embd)\n        self.mlp = nn.ModuleDict(dict(\n            c_fc    = nn.Linear(config.n_embd, 4 * config.n_embd),\n            c_proj  = nn.Linear(4 * config.n_embd, config.n_embd),\n            act     = NewGELU(),\n        ))\n        m = self.mlp\n        self.mlpf = lambda x: m.c_proj(m.act(m.c_fc(x))) # MLP forward\n\n    def forward(self, x):\n        x = x + self.attn(self.ln_1(x))\n        x = x + self.mlpf(self.ln_2(x))\n        return x\n\nclass GPT(nn.Module):\n    \"\"\" GPT Language Model \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.vocab_size is not None\n        assert config.block_size is not None\n        self.block_size = config.block_size\n\n        self.transformer = nn.ModuleDict(dict(\n            wte = nn.Embedding(config.vocab_size, config.n_embd),\n            wpe = nn.Embedding(config.block_size, config.n_embd),\n            h = nn.ModuleList([Block(config) for _ in range(config.n_layer)]),\n            ln_f = nn.LayerNorm(config.n_embd),\n        ))\n        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n\n        # init all weights\n        self.apply(self._init_weights)\n\n        # report number of parameters (note we don't count the decoder parameters in lm_head)\n        n_params = sum(p.numel() for p in self.transformer.parameters())\n        print(\"number of parameters: %.2fM\" % (n_params/1e6,))\n\n    def _init_weights(self, module):\n        # TODO is this function needed?\n        if isinstance(module, nn.Linear):\n            torch.nn.init.normal_(module.weight, mean=0.0, std=0.02)\n            if module.bias is not None:\n                torch.nn.init.zeros_(module.bias)\n        elif isinstance(module, nn.Embedding):\n            torch.nn.init.normal_(module.weight, mean=0.0, std=0.02)\n        elif isinstance(module, nn.LayerNorm):\n            torch.nn.init.zeros_(module.bias)\n            torch.nn.init.ones_(module.weight)\n\n    def configure_optimizers(self, train_config):\n        optimizer = torch.optim.AdamW(self.parameters(), lr=train_config.learning_rate,\n                                      betas=train_config.betas, weight_decay=train_config.weight_decay,\n                                      eps=1e-8)\n        return optimizer\n\n    def forward(self, idx, targets=None):\n        device = idx.device\n        b, t = idx.size()\n        assert t <= self.block_size, f\"Cannot forward sequence of length {t}, block size is only {self.block_size}\"\n        pos = torch.arange(0, t, dtype=torch.long, device=device).unsqueeze(0) # shape (1, t)\n\n        # forward the GPT model itself\n        tok_emb = self.transformer.wte(idx) # token embeddings of shape (b, t, n_embd)\n        pos_emb = self.transformer.wpe(pos) # position embeddings of shape (1, t, n_embd)\n        x = tok_emb + pos_emb\n        for block in self.transformer.h:\n            x = block(x)\n        x = self.transformer.ln_f(x)\n        logits = self.lm_head(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n    @torch.no_grad()\n    def generate(self, idx, max_new_tokens, temperature=1.0, do_sample=False, top_k=None):\n        \"\"\"\n        Take a conditioning sequence of indices idx (LongTensor of shape (b,t)) and complete\n        the sequence max_new_tokens times, feeding the predictions back into the model each time.\n        Most likely you'll want to make sure to be in model.eval() mode of operation for this.\n        \"\"\"\n        for _ in range(max_new_tokens):\n            # if the sequence context is growing too long we must crop it at block_size\n            idx_cond = idx if idx.size(1) <= self.block_size else idx[:, -self.block_size:]\n            # forward the model to get the logits for the index in the sequence\n            logits, _ = self(idx_cond)\n            # pluck the logits at the final step and scale by desired temperature\n            logits = logits[:, -1, :] / temperature\n            # optionally crop the logits to only the top k options\n            if top_k is not None:\n                v, _ = torch.topk(logits, top_k)\n                logits[logits < v[:, [-1]]] = -float('Inf')\n            # apply softmax to convert logits to (normalized) probabilities\n            probs = F.softmax(logits, dim=-1)\n            # either sample from the distribution or take the most likely element\n            if do_sample:\n                idx_next = torch.multinomial(probs, num_samples=1)\n            else:\n                _, idx_next = torch.topk(probs, k=1, dim=-1)\n            # append sampled index to the running sequence and continue\n            idx = torch.cat((idx, idx_next), dim=1)\n\n        return idx\n\n# -----------------------------------------------------------------------------\n# helper functions for evaluating and sampling from the model\n\ndef print_samples(num=10):\n    \"\"\" samples from the model and pretty prints the decoded samples \"\"\"\n    X_init = torch.zeros(num, 1, dtype=torch.long).to(args.device)\n    top_k = args.top_k if args.top_k != -1 else None\n    steps = train_dataset.get_output_length() - 1 # -1 because we already start with <START> token (index 0)\n    X_samp = model.generate(X_init, steps, top_k=top_k, do_sample=True).to('cpu')\n    train_samples, test_samples, new_samples = [], [], []\n    for i in range(X_samp.size(0)):\n        # get the i'th row of sampled integers, as python list\n        row = X_samp[i, 1:].tolist() # note: we need to crop out the first <START> token\n        # token 0 is the <STOP> token, so we crop the output sequence at that point\n        crop_index = row.index(0) if 0 in row else len(row)\n        row = row[:crop_index]\n        word_samp = train_dataset.decode(row)\n        # separately track samples that we have and have not seen before\n        if train_dataset.contains(word_samp):\n            train_samples.append(word_samp)\n        elif test_dataset.contains(word_samp):\n            test_samples.append(word_samp)\n        else:\n            new_samples.append(word_samp)\n    print('-'*80)\n    for lst, desc in [(train_samples, 'in train'), (test_samples, 'in test'), (new_samples, 'new')]:\n        print(f\"{len(lst)} samples that are {desc}:\")\n        for word in lst:\n            print(word)\n    print('-'*80)\n\n@torch.inference_mode()\ndef evaluate(model, dataset, batch_size=50, max_batches=None):\n    model.eval()\n    loader = DataLoader(dataset, shuffle=True, batch_size=batch_size, num_workers=0)\n    losses = []\n    for i, batch in enumerate(loader):\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n        logits, loss = model(X, Y)\n        losses.append(loss.item())\n        if max_batches is not None and i >= max_batches:\n            break\n    mean_loss = torch.tensor(losses).mean().item()\n    model.train() # reset model back to training mode\n    return mean_loss\n\n# -----------------------------------------------------------------------------\n# helper functions for creating the training and test Datasets that emit words\n\nclass CharDataset(Dataset):\n\n    def __init__(self, words, chars, max_word_length):\n        self.words = words\n        self.chars = chars\n        self.max_word_length = max_word_length\n        self.stoi = {ch:i+1 for i,ch in enumerate(chars)}\n        self.itos = {i:s for s,i in self.stoi.items()} # inverse mapping\n\n    def __len__(self):\n        return len(self.words)\n\n    def contains(self, word):\n        return word in self.words\n\n    def get_vocab_size(self):\n        return len(self.chars) + 1 # all the possible characters and special 0 token\n\n    def get_output_length(self):\n        return self.max_word_length + 1 # <START> token followed by words\n\n    def encode(self, word):\n        ix = torch.tensor([self.stoi[w] for w in word], dtype=torch.long)\n        return ix\n\n    def decode(self, ix):\n        word = ''.join(self.itos[i] for i in ix)\n        return word\n\n    def __getitem__(self, idx):\n        word = self.words[idx]\n        ix = self.encode(word)\n        x = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        y = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        x[1:1+len(ix)] = ix\n        y[:len(ix)] = ix\n        y[len(ix)+1:] = -1 # index -1 will mask the loss at the inactive locations\n        return x, y\n\ndef create_datasets(input_file):\n\n    # preprocessing of the input text file\n    with open(input_file, 'r') as f:\n        data = f.read()\n    words = data.splitlines()\n    words = [w.strip() for w in words] # get rid of any leading or trailing white space\n    words = [w for w in words if w] # get rid of any empty strings\n    chars = sorted(list(set(''.join(words)))) # all the possible characters\n    max_word_length = max(len(w) for w in words)\n    print(f\"number of examples in the dataset: {len(words)}\")\n    print(f\"max word length: {max_word_length}\")\n    print(f\"number of unique characters in the vocabulary: {len(chars)}\")\n    print(\"vocabulary:\")\n    print(''.join(chars))\n\n    # partition the input data into a training and the test set\n    test_set_size = min(1000, int(len(words) * 0.1)) # 10% of the training set, or up to 1000 examples\n    rp = torch.randperm(len(words)).tolist()\n    train_words = [words[i] for i in rp[:-test_set_size]]\n    test_words = [words[i] for i in rp[-test_set_size:]]\n    print(f\"split up the dataset into {len(train_words)} training examples and {len(test_words)} test examples\")\n\n    # wrap in dataset objects\n    train_dataset = CharDataset(train_words, chars, max_word_length)\n    test_dataset = CharDataset(test_words, chars, max_word_length)\n\n    return train_dataset, test_dataset\n\n# -----------------------------------------------------------------------------\nif __name__ == '__main__':\n\n    # parse command line args\n    parser = argparse.ArgumentParser(description=\"Make More\")\n    # system/input/output\n    parser.add_argument('--input-file', '-i', type=str, default='names.txt', help=\"input file with things one per line\")\n    parser.add_argument('--work-dir', '-o', type=str, default='out', help=\"output working directory\")\n    parser.add_argument('--resume', action='store_true', help=\"when this flag is used, we will resume optimization from existing model in the workdir\")\n    parser.add_argument('--sample-only', action='store_true', help=\"just sample from the model and quit, don't train\")\n    parser.add_argument('--num-workers', '-n', type=int, default=4, help=\"number of data workers for both train/test\")\n    parser.add_argument('--max-steps', type=int, default=-1, help=\"max number of optimization steps to run for, or -1 for infinite.\")\n    parser.add_argument('--device', type=str, default='cpu', help=\"device to use for compute, examples: cpu|cuda|cuda:2|mps\")\n    parser.add_argument('--seed', type=int, default=3407, help=\"seed\")\n    # sampling\n    parser.add_argument('--top-k', type=int, default=-1, help=\"top-k for sampling, -1 means no top-k\")\n    # model\n    parser.add_argument('--n-layer', type=int, default=4, help=\"number of layers in the transformer\")\n    parser.add_argument('--n-head', type=int, default=4, help=\"number of heads in the transformer\")\n    parser.add_argument('--n-embd', type=int, default=64, help=\"number of feature channels in the transformer\")\n    # optimization\n    parser.add_argument('--batch-size', '-b', type=int, default=32, help=\"batch size during optimization\")\n    parser.add_argument('--learning-rate', '-l', type=float, default=5e-4, help=\"learning rate\")\n    parser.add_argument('--weight-decay', '-w', type=float, default=0.01, help=\"weight decay\")\n    args = parser.parse_args()\n    print(vars(args))\n\n    # system inits\n    torch.manual_seed(args.seed)\n    torch.cuda.manual_seed_all(args.seed)\n    os.makedirs(args.work_dir, exist_ok=True)\n    writer = SummaryWriter(log_dir=args.work_dir)\n\n    # init datasets\n    train_dataset, test_dataset = create_datasets(args.input_file)\n    vocab_size = train_dataset.get_vocab_size()\n    block_size = train_dataset.get_output_length()\n    print(f\"dataset determined that: {vocab_size=}, {block_size=}\")\n\n    # init model\n    config = GPTConfig(vocab_size=vocab_size, block_size=block_size,\n                       n_layer=args.n_layer, n_head=args.n_head, n_embd=args.n_embd)\n    model = GPT(config)\n    model.to(args.device)\n    print(f\"model #params: {sum(p.numel() for p in model.parameters())}\")\n    if args.resume or args.sample_only: # note: if we sample-only then we also assume we're resuming\n        print(\"resuming from existing model in the workdir\")\n        model.load_state_dict(torch.load(os.path.join(args.work_dir, 'model.pt')))\n    if args.sample_only:\n        print_samples(num=50)\n        sys.exit()\n\n    # init optimizer\n    train_config = TrainConfig(learning_rate=args.learning_rate, weight_decay=args.weight_decay)\n    optimizer = model.configure_optimizers(train_config)\n\n    # init dataloader\n    train_sampler = torch.utils.data.RandomSampler(train_dataset, replacement=True, num_samples=int(1e10))\n    train_loader = DataLoader(train_dataset, batch_size=args.batch_size, pin_memory=True,\n                              num_workers=args.num_workers, sampler=train_sampler)\n    data_iter = iter(train_loader)\n\n    # training loop\n    best_loss = None\n    step = 0\n    while True:\n\n        t0 = time.time()\n        # fetch the next batch and reset dataloader every epoch as necessary\n        try:\n            batch = next(data_iter)\n        except StopIteration:\n            data_iter = iter(train_loader)\n            batch = next(data_iter)\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n\n        # feed into the model\n        logits, loss = model(X, Y)\n\n        # calculate the gradient, clip it, update the weights\n        model.zero_grad(set_to_none=True)\n        loss.backward()\n        torch.nn.utils.clip_grad_norm_(model.parameters(), 1.0)\n        optimizer.step()\n        if args.device.startswith('cuda'):\n            torch.cuda.synchronize()\n        t1 = time.time()\n\n        # logging\n        if step % 10 == 0:\n            print(f\"step {step} | loss {loss.item():.4f} | step time {(t1-t0)*1000:.2f}ms\")\n\n        # evaluate the model\n        if step > 0 and step % 500 == 0:\n            train_loss = evaluate(model, train_dataset, batch_size=100, max_batches=10)\n            test_loss  = evaluate(model, test_dataset,  batch_size=100, max_batches=10)\n            writer.add_scalar(\"Loss/train\", train_loss, step)\n            writer.add_scalar(\"Loss/test\", test_loss, step)\n            writer.flush()\n            print(f\"step {step} train loss: {train_loss} test loss: {test_loss}\")\n            # save the model to disk if it has improved\n            if best_loss is None or test_loss < best_loss:\n                out_path = os.path.join(args.work_dir, \"model.pt\")\n                print(f\"test loss {test_loss} is the best so far, saving model to {out_path}\")\n                torch.save(model.state_dict(), out_path)\n                best_loss = test_loss\n\n        # sample from the model\n        if step > 0 and step % 200 == 0:\n            print_samples(num=10)\n\n        step += 1\n        # termination conditions\n        if args.max_steps >= 0 and step >= args.max_steps:\n            break\n\n", "previous_id": "0a19a59564f45f894aa9160e64631f5f26c6b638", "new_code_file": "\"\"\"\nyou give this script some words (one per line) and it will generate more things like it.\nuses super state of the art Transformer AI tech\nthis code is intended to be super hackable. tune it to your needs.\n\nChanges from minGPT:\n- I removed the from_pretrained function where we init with GPT2 weights\n- I removed dropout layers because the models we train here are small,\n  it's not necessary to understand at this stage and at this scale.\n- I removed weight decay and all of the complexity around what parameters are\n  and are not weight decayed. I don't believe this should make a massive\n  difference at the scale that we operate on here.\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport math\nimport argparse\nfrom dataclasses import dataclass\nfrom typing import List\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\nfrom torch.utils.data import Dataset\nfrom torch.utils.data.dataloader import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\n# -----------------------------------------------------------------------------\n# GPT model definition\n\n@dataclass\nclass GPTConfig:\n    # size of the model\n    n_layer: int = 4\n    n_head: int = 4\n    n_embd: int = 64\n    vocab_size: int = None\n    block_size: int = None\n\n@dataclass\nclass TrainConfig:\n    # optimization parameters\n    learning_rate: float = 5e-4\n    betas: List[float] = (0.9, 0.99)\n    weight_decay: float = 0.01\n\nclass NewGELU(nn.Module):\n    \"\"\"\n    Implementation of the GELU activation function currently in Google BERT repo (identical to OpenAI GPT).\n    Reference: Gaussian Error Linear Units (GELU) paper: https://arxiv.org/abs/1606.08415\n    \"\"\"\n    def forward(self, x):\n        return 0.5 * x * (1.0 + torch.tanh(math.sqrt(2.0 / math.pi) * (x + 0.044715 * torch.pow(x, 3.0))))\n\nclass CausalSelfAttention(nn.Module):\n    \"\"\"\n    A vanilla multi-head masked self-attention layer with a projection at the end.\n    It is possible to use torch.nn.MultiheadAttention here but I am including an\n    explicit implementation here to show that there is nothing too scary here.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.n_embd % config.n_head == 0\n        # key, query, value projections for all heads, but in a batch\n        self.c_attn = nn.Linear(config.n_embd, 3 * config.n_embd)\n        # output projection\n        self.c_proj = nn.Linear(config.n_embd, config.n_embd)\n        # causal mask to ensure that attention is only applied to the left in the input sequence\n        self.register_buffer(\"bias\", torch.tril(torch.ones(config.block_size, config.block_size))\n                                     .view(1, 1, config.block_size, config.block_size))\n        self.n_head = config.n_head\n        self.n_embd = config.n_embd\n\n    def forward(self, x):\n        B, T, C = x.size() # batch size, sequence length, embedding dimensionality (n_embd)\n\n        # calculate query, key, values for all heads in batch and move head forward to be the batch dim\n        q, k ,v  = self.c_attn(x).split(self.n_embd, dim=2)\n        k = k.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        q = q.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        v = v.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n\n        # causal self-attention; Self-attend: (B, nh, T, hs) x (B, nh, hs, T) -> (B, nh, T, T)\n        att = (q @ k.transpose(-2, -1)) * (1.0 / math.sqrt(k.size(-1)))\n        att = att.masked_fill(self.bias[:,:,:T,:T] == 0, float('-inf'))\n        att = F.softmax(att, dim=-1)\n        y = att @ v # (B, nh, T, T) x (B, nh, T, hs) -> (B, nh, T, hs)\n        y = y.transpose(1, 2).contiguous().view(B, T, C) # re-assemble all head outputs side by side\n\n        # output projection\n        y = self.c_proj(y)\n        return y\n\nclass Block(nn.Module):\n    \"\"\" an unassuming Transformer block \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.ln_1 = nn.LayerNorm(config.n_embd)\n        self.attn = CausalSelfAttention(config)\n        self.ln_2 = nn.LayerNorm(config.n_embd)\n        self.mlp = nn.ModuleDict(dict(\n            c_fc    = nn.Linear(config.n_embd, 4 * config.n_embd),\n            c_proj  = nn.Linear(4 * config.n_embd, config.n_embd),\n            act     = NewGELU(),\n        ))\n        m = self.mlp\n        self.mlpf = lambda x: m.c_proj(m.act(m.c_fc(x))) # MLP forward\n\n    def forward(self, x):\n        x = x + self.attn(self.ln_1(x))\n        x = x + self.mlpf(self.ln_2(x))\n        return x\n\nclass GPT(nn.Module):\n    \"\"\" GPT Language Model \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.vocab_size is not None\n        assert config.block_size is not None\n        self.block_size = config.block_size\n\n        self.transformer = nn.ModuleDict(dict(\n            wte = nn.Embedding(config.vocab_size, config.n_embd),\n            wpe = nn.Embedding(config.block_size, config.n_embd),\n            h = nn.ModuleList([Block(config) for _ in range(config.n_layer)]),\n            ln_f = nn.LayerNorm(config.n_embd),\n        ))\n        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n\n        # report number of parameters (note we don't count the decoder parameters in lm_head)\n        n_params = sum(p.numel() for p in self.transformer.parameters())\n        print(\"number of parameters: %.2fM\" % (n_params/1e6,))\n\n    def configure_optimizers(self, train_config):\n        optimizer = torch.optim.AdamW(self.parameters(), lr=train_config.learning_rate,\n                                      betas=train_config.betas, weight_decay=train_config.weight_decay,\n                                      eps=1e-8)\n        return optimizer\n\n    def forward(self, idx, targets=None):\n        device = idx.device\n        b, t = idx.size()\n        assert t <= self.block_size, f\"Cannot forward sequence of length {t}, block size is only {self.block_size}\"\n        pos = torch.arange(0, t, dtype=torch.long, device=device).unsqueeze(0) # shape (1, t)\n\n        # forward the GPT model itself\n        tok_emb = self.transformer.wte(idx) # token embeddings of shape (b, t, n_embd)\n        pos_emb = self.transformer.wpe(pos) # position embeddings of shape (1, t, n_embd)\n        x = tok_emb + pos_emb\n        for block in self.transformer.h:\n            x = block(x)\n        x = self.transformer.ln_f(x)\n        logits = self.lm_head(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n    @torch.no_grad()\n    def generate(self, idx, max_new_tokens, temperature=1.0, do_sample=False, top_k=None):\n        \"\"\"\n        Take a conditioning sequence of indices idx (LongTensor of shape (b,t)) and complete\n        the sequence max_new_tokens times, feeding the predictions back into the model each time.\n        Most likely you'll want to make sure to be in model.eval() mode of operation for this.\n        \"\"\"\n        for _ in range(max_new_tokens):\n            # if the sequence context is growing too long we must crop it at block_size\n            idx_cond = idx if idx.size(1) <= self.block_size else idx[:, -self.block_size:]\n            # forward the model to get the logits for the index in the sequence\n            logits, _ = self(idx_cond)\n            # pluck the logits at the final step and scale by desired temperature\n            logits = logits[:, -1, :] / temperature\n            # optionally crop the logits to only the top k options\n            if top_k is not None:\n                v, _ = torch.topk(logits, top_k)\n                logits[logits < v[:, [-1]]] = -float('Inf')\n            # apply softmax to convert logits to (normalized) probabilities\n            probs = F.softmax(logits, dim=-1)\n            # either sample from the distribution or take the most likely element\n            if do_sample:\n                idx_next = torch.multinomial(probs, num_samples=1)\n            else:\n                _, idx_next = torch.topk(probs, k=1, dim=-1)\n            # append sampled index to the running sequence and continue\n            idx = torch.cat((idx, idx_next), dim=1)\n\n        return idx\n\n# -----------------------------------------------------------------------------\n# helper functions for evaluating and sampling from the model\n\ndef print_samples(num=10):\n    \"\"\" samples from the model and pretty prints the decoded samples \"\"\"\n    X_init = torch.zeros(num, 1, dtype=torch.long).to(args.device)\n    top_k = args.top_k if args.top_k != -1 else None\n    steps = train_dataset.get_output_length() - 1 # -1 because we already start with <START> token (index 0)\n    X_samp = model.generate(X_init, steps, top_k=top_k, do_sample=True).to('cpu')\n    train_samples, test_samples, new_samples = [], [], []\n    for i in range(X_samp.size(0)):\n        # get the i'th row of sampled integers, as python list\n        row = X_samp[i, 1:].tolist() # note: we need to crop out the first <START> token\n        # token 0 is the <STOP> token, so we crop the output sequence at that point\n        crop_index = row.index(0) if 0 in row else len(row)\n        row = row[:crop_index]\n        word_samp = train_dataset.decode(row)\n        # separately track samples that we have and have not seen before\n        if train_dataset.contains(word_samp):\n            train_samples.append(word_samp)\n        elif test_dataset.contains(word_samp):\n            test_samples.append(word_samp)\n        else:\n            new_samples.append(word_samp)\n    print('-'*80)\n    for lst, desc in [(train_samples, 'in train'), (test_samples, 'in test'), (new_samples, 'new')]:\n        print(f\"{len(lst)} samples that are {desc}:\")\n        for word in lst:\n            print(word)\n    print('-'*80)\n\n@torch.inference_mode()\ndef evaluate(model, dataset, batch_size=50, max_batches=None):\n    model.eval()\n    loader = DataLoader(dataset, shuffle=True, batch_size=batch_size, num_workers=0)\n    losses = []\n    for i, batch in enumerate(loader):\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n        logits, loss = model(X, Y)\n        losses.append(loss.item())\n        if max_batches is not None and i >= max_batches:\n            break\n    mean_loss = torch.tensor(losses).mean().item()\n    model.train() # reset model back to training mode\n    return mean_loss\n\n# -----------------------------------------------------------------------------\n# helper functions for creating the training and test Datasets that emit words\n\nclass CharDataset(Dataset):\n\n    def __init__(self, words, chars, max_word_length):\n        self.words = words\n        self.chars = chars\n        self.max_word_length = max_word_length\n        self.stoi = {ch:i+1 for i,ch in enumerate(chars)}\n        self.itos = {i:s for s,i in self.stoi.items()} # inverse mapping\n\n    def __len__(self):\n        return len(self.words)\n\n    def contains(self, word):\n        return word in self.words\n\n    def get_vocab_size(self):\n        return len(self.chars) + 1 # all the possible characters and special 0 token\n\n    def get_output_length(self):\n        return self.max_word_length + 1 # <START> token followed by words\n\n    def encode(self, word):\n        ix = torch.tensor([self.stoi[w] for w in word], dtype=torch.long)\n        return ix\n\n    def decode(self, ix):\n        word = ''.join(self.itos[i] for i in ix)\n        return word\n\n    def __getitem__(self, idx):\n        word = self.words[idx]\n        ix = self.encode(word)\n        x = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        y = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        x[1:1+len(ix)] = ix\n        y[:len(ix)] = ix\n        y[len(ix)+1:] = -1 # index -1 will mask the loss at the inactive locations\n        return x, y\n\ndef create_datasets(input_file):\n\n    # preprocessing of the input text file\n    with open(input_file, 'r') as f:\n        data = f.read()\n    words = data.splitlines()\n    words = [w.strip() for w in words] # get rid of any leading or trailing white space\n    words = [w for w in words if w] # get rid of any empty strings\n    chars = sorted(list(set(''.join(words)))) # all the possible characters\n    max_word_length = max(len(w) for w in words)\n    print(f\"number of examples in the dataset: {len(words)}\")\n    print(f\"max word length: {max_word_length}\")\n    print(f\"number of unique characters in the vocabulary: {len(chars)}\")\n    print(\"vocabulary:\")\n    print(''.join(chars))\n\n    # partition the input data into a training and the test set\n    test_set_size = min(1000, int(len(words) * 0.1)) # 10% of the training set, or up to 1000 examples\n    rp = torch.randperm(len(words)).tolist()\n    train_words = [words[i] for i in rp[:-test_set_size]]\n    test_words = [words[i] for i in rp[-test_set_size:]]\n    print(f\"split up the dataset into {len(train_words)} training examples and {len(test_words)} test examples\")\n\n    # wrap in dataset objects\n    train_dataset = CharDataset(train_words, chars, max_word_length)\n    test_dataset = CharDataset(test_words, chars, max_word_length)\n\n    return train_dataset, test_dataset\n\n# -----------------------------------------------------------------------------\nif __name__ == '__main__':\n\n    # parse command line args\n    parser = argparse.ArgumentParser(description=\"Make More\")\n    # system/input/output\n    parser.add_argument('--input-file', '-i', type=str, default='names.txt', help=\"input file with things one per line\")\n    parser.add_argument('--work-dir', '-o', type=str, default='out', help=\"output working directory\")\n    parser.add_argument('--resume', action='store_true', help=\"when this flag is used, we will resume optimization from existing model in the workdir\")\n    parser.add_argument('--sample-only', action='store_true', help=\"just sample from the model and quit, don't train\")\n    parser.add_argument('--num-workers', '-n', type=int, default=4, help=\"number of data workers for both train/test\")\n    parser.add_argument('--max-steps', type=int, default=-1, help=\"max number of optimization steps to run for, or -1 for infinite.\")\n    parser.add_argument('--device', type=str, default='cpu', help=\"device to use for compute, examples: cpu|cuda|cuda:2|mps\")\n    parser.add_argument('--seed', type=int, default=3407, help=\"seed\")\n    # sampling\n    parser.add_argument('--top-k', type=int, default=-1, help=\"top-k for sampling, -1 means no top-k\")\n    # model\n    parser.add_argument('--n-layer', type=int, default=4, help=\"number of layers in the transformer\")\n    parser.add_argument('--n-head', type=int, default=4, help=\"number of heads in the transformer\")\n    parser.add_argument('--n-embd', type=int, default=64, help=\"number of feature channels in the transformer\")\n    # optimization\n    parser.add_argument('--batch-size', '-b', type=int, default=32, help=\"batch size during optimization\")\n    parser.add_argument('--learning-rate', '-l', type=float, default=5e-4, help=\"learning rate\")\n    parser.add_argument('--weight-decay', '-w', type=float, default=0.01, help=\"weight decay\")\n    args = parser.parse_args()\n    print(vars(args))\n\n    # system inits\n    torch.manual_seed(args.seed)\n    torch.cuda.manual_seed_all(args.seed)\n    os.makedirs(args.work_dir, exist_ok=True)\n    writer = SummaryWriter(log_dir=args.work_dir)\n\n    # init datasets\n    train_dataset, test_dataset = create_datasets(args.input_file)\n    vocab_size = train_dataset.get_vocab_size()\n    block_size = train_dataset.get_output_length()\n    print(f\"dataset determined that: {vocab_size=}, {block_size=}\")\n\n    # init model\n    config = GPTConfig(vocab_size=vocab_size, block_size=block_size,\n                       n_layer=args.n_layer, n_head=args.n_head, n_embd=args.n_embd)\n    model = GPT(config)\n    model.to(args.device)\n    print(f\"model #params: {sum(p.numel() for p in model.parameters())}\")\n    if args.resume or args.sample_only: # note: if we sample-only then we also assume we're resuming\n        print(\"resuming from existing model in the workdir\")\n        model.load_state_dict(torch.load(os.path.join(args.work_dir, 'model.pt')))\n    if args.sample_only:\n        print_samples(num=50)\n        sys.exit()\n\n    # init optimizer\n    train_config = TrainConfig(learning_rate=args.learning_rate, weight_decay=args.weight_decay)\n    optimizer = model.configure_optimizers(train_config)\n\n    # init dataloader\n    train_sampler = torch.utils.data.RandomSampler(train_dataset, replacement=True, num_samples=int(1e10))\n    train_loader = DataLoader(train_dataset, batch_size=args.batch_size, pin_memory=True,\n                              num_workers=args.num_workers, sampler=train_sampler)\n    data_iter = iter(train_loader)\n\n    # training loop\n    best_loss = None\n    step = 0\n    while True:\n\n        t0 = time.time()\n        # fetch the next batch and reset dataloader every epoch as necessary\n        try:\n            batch = next(data_iter)\n        except StopIteration:\n            data_iter = iter(train_loader)\n            batch = next(data_iter)\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n\n        # feed into the model\n        logits, loss = model(X, Y)\n\n        # calculate the gradient, clip it, update the weights\n        model.zero_grad(set_to_none=True)\n        loss.backward()\n        torch.nn.utils.clip_grad_norm_(model.parameters(), 1.0)\n        optimizer.step()\n        if args.device.startswith('cuda'):\n            torch.cuda.synchronize()\n        t1 = time.time()\n\n        # logging\n        if step % 10 == 0:\n            print(f\"step {step} | loss {loss.item():.4f} | step time {(t1-t0)*1000:.2f}ms\")\n\n        # evaluate the model\n        if step > 0 and step % 500 == 0:\n            train_loss = evaluate(model, train_dataset, batch_size=100, max_batches=10)\n            test_loss  = evaluate(model, test_dataset,  batch_size=100, max_batches=10)\n            writer.add_scalar(\"Loss/train\", train_loss, step)\n            writer.add_scalar(\"Loss/test\", test_loss, step)\n            writer.flush()\n            print(f\"step {step} train loss: {train_loss} test loss: {test_loss}\")\n            # save the model to disk if it has improved\n            if best_loss is None or test_loss < best_loss:\n                out_path = os.path.join(args.work_dir, \"model.pt\")\n                print(f\"test loss {test_loss} is the best so far, saving model to {out_path}\")\n                torch.save(model.state_dict(), out_path)\n                best_loss = test_loss\n\n        # sample from the model\n        if step > 0 and step % 200 == 0:\n            print_samples(num=10)\n\n        step += 1\n        # termination conditions\n        if args.max_steps >= 0 and step >= args.max_steps:\n            break\n\n", "diff": "@@ -132,25 +132,10 @@ def __init__(self, config):\n         ))\n         self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n \n-        # init all weights\n-        self.apply(self._init_weights)\n-\n         # report number of parameters (note we don't count the decoder parameters in lm_head)\n         n_params = sum(p.numel() for p in self.transformer.parameters())\n         print(\"number of parameters: %.2fM\" % (n_params/1e6,))\n \n-    def _init_weights(self, module):\n-        # TODO is this function needed?\n-        if isinstance(module, nn.Linear):\n-            torch.nn.init.normal_(module.weight, mean=0.0, std=0.02)\n-            if module.bias is not None:\n-                torch.nn.init.zeros_(module.bias)\n-        elif isinstance(module, nn.Embedding):\n-            torch.nn.init.normal_(module.weight, mean=0.0, std=0.02)\n-        elif isinstance(module, nn.LayerNorm):\n-            torch.nn.init.zeros_(module.bias)\n-            torch.nn.init.ones_(module.weight)\n-\n     def configure_optimizers(self, train_config):\n         optimizer = torch.optim.AdamW(self.parameters(), lr=train_config.learning_rate,\n                                       betas=train_config.betas, weight_decay=train_config.weight_decay,", "status": "modified"}, {"commit_id": "0a19a59564f45f894aa9160e64631f5f26c6b638", "commit_message": "add max steps", "relative_path": "makemore.py", "previous_code_file": "\"\"\"\nyou give this script some words (one per line) and it will generate more things like it.\nuses super state of the art Transformer AI tech\nthis code is intended to be super hackable. tune it to your needs.\n\nChanges from minGPT:\n- I removed the from_pretrained function where we init with GPT2 weights\n- I removed dropout layers because the models we train here are small,\n  it's not necessary to understand at this stage and at this scale.\n- I removed weight decay and all of the complexity around what parameters are\n  and are not weight decayed. I don't believe this should make a massive\n  difference at the scale that we operate on here.\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport math\nimport argparse\nfrom dataclasses import dataclass\nfrom typing import List\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\nfrom torch.utils.data import Dataset\nfrom torch.utils.data.dataloader import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\n# -----------------------------------------------------------------------------\n# GPT model definition\n\n@dataclass\nclass GPTConfig:\n    # size of the model\n    n_layer: int = 4\n    n_head: int = 4\n    n_embd: int = 64\n    vocab_size: int = None\n    block_size: int = None\n\n@dataclass\nclass TrainConfig:\n    # optimization parameters\n    learning_rate: float = 5e-4\n    betas: List[float] = (0.9, 0.99)\n    weight_decay: float = 0.01\n\nclass NewGELU(nn.Module):\n    \"\"\"\n    Implementation of the GELU activation function currently in Google BERT repo (identical to OpenAI GPT).\n    Reference: Gaussian Error Linear Units (GELU) paper: https://arxiv.org/abs/1606.08415\n    \"\"\"\n    def forward(self, x):\n        return 0.5 * x * (1.0 + torch.tanh(math.sqrt(2.0 / math.pi) * (x + 0.044715 * torch.pow(x, 3.0))))\n\nclass CausalSelfAttention(nn.Module):\n    \"\"\"\n    A vanilla multi-head masked self-attention layer with a projection at the end.\n    It is possible to use torch.nn.MultiheadAttention here but I am including an\n    explicit implementation here to show that there is nothing too scary here.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.n_embd % config.n_head == 0\n        # key, query, value projections for all heads, but in a batch\n        self.c_attn = nn.Linear(config.n_embd, 3 * config.n_embd)\n        # output projection\n        self.c_proj = nn.Linear(config.n_embd, config.n_embd)\n        # causal mask to ensure that attention is only applied to the left in the input sequence\n        self.register_buffer(\"bias\", torch.tril(torch.ones(config.block_size, config.block_size))\n                                     .view(1, 1, config.block_size, config.block_size))\n        self.n_head = config.n_head\n        self.n_embd = config.n_embd\n\n    def forward(self, x):\n        B, T, C = x.size() # batch size, sequence length, embedding dimensionality (n_embd)\n\n        # calculate query, key, values for all heads in batch and move head forward to be the batch dim\n        q, k ,v  = self.c_attn(x).split(self.n_embd, dim=2)\n        k = k.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        q = q.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        v = v.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n\n        # causal self-attention; Self-attend: (B, nh, T, hs) x (B, nh, hs, T) -> (B, nh, T, T)\n        att = (q @ k.transpose(-2, -1)) * (1.0 / math.sqrt(k.size(-1)))\n        att = att.masked_fill(self.bias[:,:,:T,:T] == 0, float('-inf'))\n        att = F.softmax(att, dim=-1)\n        y = att @ v # (B, nh, T, T) x (B, nh, T, hs) -> (B, nh, T, hs)\n        y = y.transpose(1, 2).contiguous().view(B, T, C) # re-assemble all head outputs side by side\n\n        # output projection\n        y = self.c_proj(y)\n        return y\n\nclass Block(nn.Module):\n    \"\"\" an unassuming Transformer block \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.ln_1 = nn.LayerNorm(config.n_embd)\n        self.attn = CausalSelfAttention(config)\n        self.ln_2 = nn.LayerNorm(config.n_embd)\n        self.mlp = nn.ModuleDict(dict(\n            c_fc    = nn.Linear(config.n_embd, 4 * config.n_embd),\n            c_proj  = nn.Linear(4 * config.n_embd, config.n_embd),\n            act     = NewGELU(),\n        ))\n        m = self.mlp\n        self.mlpf = lambda x: m.c_proj(m.act(m.c_fc(x))) # MLP forward\n\n    def forward(self, x):\n        x = x + self.attn(self.ln_1(x))\n        x = x + self.mlpf(self.ln_2(x))\n        return x\n\nclass GPT(nn.Module):\n    \"\"\" GPT Language Model \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.vocab_size is not None\n        assert config.block_size is not None\n        self.block_size = config.block_size\n\n        self.transformer = nn.ModuleDict(dict(\n            wte = nn.Embedding(config.vocab_size, config.n_embd),\n            wpe = nn.Embedding(config.block_size, config.n_embd),\n            h = nn.ModuleList([Block(config) for _ in range(config.n_layer)]),\n            ln_f = nn.LayerNorm(config.n_embd),\n        ))\n        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n\n        # init all weights\n        self.apply(self._init_weights)\n\n        # report number of parameters (note we don't count the decoder parameters in lm_head)\n        n_params = sum(p.numel() for p in self.transformer.parameters())\n        print(\"number of parameters: %.2fM\" % (n_params/1e6,))\n\n    def _init_weights(self, module):\n        # TODO is this function needed?\n        if isinstance(module, nn.Linear):\n            torch.nn.init.normal_(module.weight, mean=0.0, std=0.02)\n            if module.bias is not None:\n                torch.nn.init.zeros_(module.bias)\n        elif isinstance(module, nn.Embedding):\n            torch.nn.init.normal_(module.weight, mean=0.0, std=0.02)\n        elif isinstance(module, nn.LayerNorm):\n            torch.nn.init.zeros_(module.bias)\n            torch.nn.init.ones_(module.weight)\n\n    def configure_optimizers(self, train_config):\n        optimizer = torch.optim.AdamW(self.parameters(), lr=train_config.learning_rate,\n                                      betas=train_config.betas, weight_decay=train_config.weight_decay,\n                                      eps=1e-8)\n        return optimizer\n\n    def forward(self, idx, targets=None):\n        device = idx.device\n        b, t = idx.size()\n        assert t <= self.block_size, f\"Cannot forward sequence of length {t}, block size is only {self.block_size}\"\n        pos = torch.arange(0, t, dtype=torch.long, device=device).unsqueeze(0) # shape (1, t)\n\n        # forward the GPT model itself\n        tok_emb = self.transformer.wte(idx) # token embeddings of shape (b, t, n_embd)\n        pos_emb = self.transformer.wpe(pos) # position embeddings of shape (1, t, n_embd)\n        x = tok_emb + pos_emb\n        for block in self.transformer.h:\n            x = block(x)\n        x = self.transformer.ln_f(x)\n        logits = self.lm_head(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n    @torch.no_grad()\n    def generate(self, idx, max_new_tokens, temperature=1.0, do_sample=False, top_k=None):\n        \"\"\"\n        Take a conditioning sequence of indices idx (LongTensor of shape (b,t)) and complete\n        the sequence max_new_tokens times, feeding the predictions back into the model each time.\n        Most likely you'll want to make sure to be in model.eval() mode of operation for this.\n        \"\"\"\n        for _ in range(max_new_tokens):\n            # if the sequence context is growing too long we must crop it at block_size\n            idx_cond = idx if idx.size(1) <= self.block_size else idx[:, -self.block_size:]\n            # forward the model to get the logits for the index in the sequence\n            logits, _ = self(idx_cond)\n            # pluck the logits at the final step and scale by desired temperature\n            logits = logits[:, -1, :] / temperature\n            # optionally crop the logits to only the top k options\n            if top_k is not None:\n                v, _ = torch.topk(logits, top_k)\n                logits[logits < v[:, [-1]]] = -float('Inf')\n            # apply softmax to convert logits to (normalized) probabilities\n            probs = F.softmax(logits, dim=-1)\n            # either sample from the distribution or take the most likely element\n            if do_sample:\n                idx_next = torch.multinomial(probs, num_samples=1)\n            else:\n                _, idx_next = torch.topk(probs, k=1, dim=-1)\n            # append sampled index to the running sequence and continue\n            idx = torch.cat((idx, idx_next), dim=1)\n\n        return idx\n\n# -----------------------------------------------------------------------------\n# helper functions for evaluating and sampling from the model\n\ndef print_samples(num=10):\n    \"\"\" samples from the model and pretty prints the decoded samples \"\"\"\n    X_init = torch.zeros(num, 1, dtype=torch.long).to(args.device)\n    top_k = args.top_k if args.top_k != -1 else None\n    steps = train_dataset.get_output_length() - 1 # -1 because we already start with <START> token (index 0)\n    X_samp = model.generate(X_init, steps, top_k=top_k, do_sample=True).to('cpu')\n    train_samples, test_samples, new_samples = [], [], []\n    for i in range(X_samp.size(0)):\n        # get the i'th row of sampled integers, as python list\n        row = X_samp[i, 1:].tolist() # note: we need to crop out the first <START> token\n        # token 0 is the <STOP> token, so we crop the output sequence at that point\n        crop_index = row.index(0) if 0 in row else len(row)\n        row = row[:crop_index]\n        word_samp = train_dataset.decode(row)\n        # separately track samples that we have and have not seen before\n        if train_dataset.contains(word_samp):\n            train_samples.append(word_samp)\n        elif test_dataset.contains(word_samp):\n            test_samples.append(word_samp)\n        else:\n            new_samples.append(word_samp)\n    print('-'*80)\n    for lst, desc in [(train_samples, 'in train'), (test_samples, 'in test'), (new_samples, 'new')]:\n        print(f\"{len(lst)} samples that are {desc}:\")\n        for word in lst:\n            print(word)\n    print('-'*80)\n\n@torch.inference_mode()\ndef evaluate(model, dataset, batch_size=50, max_batches=None):\n    model.eval()\n    loader = DataLoader(dataset, shuffle=True, batch_size=batch_size, num_workers=0)\n    losses = []\n    for i, batch in enumerate(loader):\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n        logits, loss = model(X, Y)\n        losses.append(loss.item())\n        if max_batches is not None and i >= max_batches:\n            break\n    mean_loss = torch.tensor(losses).mean().item()\n    model.train() # reset model back to training mode\n    return mean_loss\n\n# -----------------------------------------------------------------------------\n# helper functions for creating the training and test Datasets that emit words\n\nclass CharDataset(Dataset):\n\n    def __init__(self, words, chars, max_word_length):\n        self.words = words\n        self.chars = chars\n        self.max_word_length = max_word_length\n        self.stoi = {ch:i+1 for i,ch in enumerate(chars)}\n        self.itos = {i:s for s,i in self.stoi.items()} # inverse mapping\n\n    def __len__(self):\n        return len(self.words)\n\n    def contains(self, word):\n        return word in self.words\n\n    def get_vocab_size(self):\n        return len(self.chars) + 1 # all the possible characters and special 0 token\n\n    def get_output_length(self):\n        return self.max_word_length + 1 # <START> token followed by words\n\n    def encode(self, word):\n        ix = torch.tensor([self.stoi[w] for w in word], dtype=torch.long)\n        return ix\n\n    def decode(self, ix):\n        word = ''.join(self.itos[i] for i in ix)\n        return word\n\n    def __getitem__(self, idx):\n        word = self.words[idx]\n        ix = self.encode(word)\n        x = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        y = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        x[1:1+len(ix)] = ix\n        y[:len(ix)] = ix\n        y[len(ix)+1:] = -1 # index -1 will mask the loss at the inactive locations\n        return x, y\n\ndef create_datasets(input_file):\n\n    # preprocessing of the input text file\n    with open(input_file, 'r') as f:\n        data = f.read()\n    words = data.splitlines()\n    words = [w.strip() for w in words] # get rid of any leading or trailing white space\n    words = [w for w in words if w] # get rid of any empty strings\n    chars = sorted(list(set(''.join(words)))) # all the possible characters\n    max_word_length = max(len(w) for w in words)\n    print(f\"number of examples in the dataset: {len(words)}\")\n    print(f\"max word length: {max_word_length}\")\n    print(f\"number of unique characters in the vocabulary: {len(chars)}\")\n    print(\"vocabulary:\")\n    print(''.join(chars))\n\n    # partition the input data into a training and the test set\n    test_set_size = min(1000, int(len(words) * 0.1)) # 10% of the training set, or up to 1000 examples\n    rp = torch.randperm(len(words)).tolist()\n    train_words = [words[i] for i in rp[:-test_set_size]]\n    test_words = [words[i] for i in rp[-test_set_size:]]\n    print(f\"split up the dataset into {len(train_words)} training examples and {len(test_words)} test examples\")\n\n    # wrap in dataset objects\n    train_dataset = CharDataset(train_words, chars, max_word_length)\n    test_dataset = CharDataset(test_words, chars, max_word_length)\n\n    return train_dataset, test_dataset\n\n# -----------------------------------------------------------------------------\nif __name__ == '__main__':\n\n    # parse command line args\n    parser = argparse.ArgumentParser(description=\"Make More\")\n    # system/input/output\n    parser.add_argument('--input-file', '-i', type=str, default='names.txt', help=\"input file with things one per line\")\n    parser.add_argument('--work-dir', '-o', type=str, default='out', help=\"output working directory\")\n    parser.add_argument('--resume', action='store_true', help=\"when this flag is used, we will resume optimization from existing model in the workdir\")\n    parser.add_argument('--sample-only', action='store_true', help=\"just sample from the model and quit, don't train\")\n    parser.add_argument('--num-workers', '-n', type=int, default=0, help=\"number of data workers for both train/test\")\n    parser.add_argument('--device', type=str, default='cpu', help=\"device to use for compute, examples: cpu|cuda|cuda:2|mps\")\n    parser.add_argument('--seed', type=int, default=3407, help=\"seed\")\n    # sampling\n    parser.add_argument('--top-k', type=int, default=-1, help=\"top-k for sampling, -1 means no top-k\")\n    # model\n    parser.add_argument('--n-layer', type=int, default=4, help=\"number of layers in the transformer\")\n    parser.add_argument('--n-head', type=int, default=4, help=\"number of heads in the transformer\")\n    parser.add_argument('--n-embd', type=int, default=64, help=\"number of feature channels in the transformer\")\n    # optimization\n    parser.add_argument('--batch-size', '-b', type=int, default=32, help=\"batch size during optimization\")\n    parser.add_argument('--learning-rate', '-l', type=float, default=5e-4, help=\"learning rate\")\n    parser.add_argument('--weight-decay', '-w', type=float, default=0.01, help=\"weight decay\")\n    args = parser.parse_args()\n    print(vars(args))\n\n    # system inits\n    torch.manual_seed(args.seed)\n    torch.cuda.manual_seed_all(args.seed)\n    os.makedirs(args.work_dir, exist_ok=True)\n    writer = SummaryWriter(log_dir=args.work_dir)\n\n    # init datasets\n    train_dataset, test_dataset = create_datasets(args.input_file)\n    vocab_size = train_dataset.get_vocab_size()\n    block_size = train_dataset.get_output_length()\n    print(f\"dataset determined that: {vocab_size=}, {block_size=}\")\n\n    # init model\n    config = GPTConfig(vocab_size=vocab_size, block_size=block_size,\n                       n_layer=args.n_layer, n_head=args.n_head, n_embd=args.n_embd)\n    model = GPT(config)\n    model.to(args.device)\n    print(f\"model #params: {sum(p.numel() for p in model.parameters())}\")\n    if args.resume or args.sample_only: # note: if we sample-only then we also assume we're resuming\n        print(\"resuming from existing model in the workdir\")\n        model.load_state_dict(torch.load(os.path.join(args.work_dir, 'model.pt')))\n    if args.sample_only:\n        print_samples(num=50)\n        sys.exit()\n\n    # init optimizer\n    train_config = TrainConfig(learning_rate=args.learning_rate, weight_decay=args.weight_decay)\n    optimizer = model.configure_optimizers(train_config)\n\n    # init dataloader\n    train_sampler = torch.utils.data.RandomSampler(train_dataset, replacement=True, num_samples=int(1e10))\n    train_loader = DataLoader(train_dataset, batch_size=args.batch_size, pin_memory=True,\n                              num_workers=args.num_workers, sampler=train_sampler)\n    data_iter = iter(train_loader)\n\n    # training loop\n    best_loss = None\n    step = 0\n    while True:\n\n        t0 = time.time()\n        # fetch the next batch and reset dataloader every epoch as necessary\n        try:\n            batch = next(data_iter)\n        except StopIteration:\n            data_iter = iter(train_loader)\n            batch = next(data_iter)\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n\n        # feed into the model\n        logits, loss = model(X, Y)\n\n        # calculate the gradient, clip it, update the weights\n        model.zero_grad(set_to_none=True)\n        loss.backward()\n        torch.nn.utils.clip_grad_norm_(model.parameters(), 1.0)\n        optimizer.step()\n        if args.device.startswith('cuda'):\n            torch.cuda.synchronize()\n        t1 = time.time()\n\n        # logging\n        if step % 10 == 0:\n            print(f\"step {step} | loss {loss.item():.4f} | step time {(t1-t0)*1000:.2f}ms\")\n\n        # evaluate the model\n        if step > 0 and step % 500 == 0:\n            train_loss = evaluate(model, train_dataset, batch_size=100, max_batches=10)\n            test_loss  = evaluate(model, test_dataset,  batch_size=100, max_batches=10)\n            writer.add_scalar(\"Loss/train\", train_loss, step)\n            writer.add_scalar(\"Loss/test\", test_loss, step)\n            writer.flush()\n            print(f\"step {step} train loss: {train_loss} test loss: {test_loss}\")\n            # save the model to disk if it has improved\n            if best_loss is None or test_loss < best_loss:\n                out_path = os.path.join(args.work_dir, \"model.pt\")\n                print(f\"test loss {test_loss} is the best so far, saving model to {out_path}\")\n                torch.save(model.state_dict(), out_path)\n                best_loss = test_loss\n\n        # sample from the model\n        if step > 0 and step % 200 == 0:\n            print_samples(num=10)\n\n        step += 1\n", "previous_id": "055e7ee48a610dade030c1888dc70d503bf6a1f8", "new_code_file": "\"\"\"\nyou give this script some words (one per line) and it will generate more things like it.\nuses super state of the art Transformer AI tech\nthis code is intended to be super hackable. tune it to your needs.\n\nChanges from minGPT:\n- I removed the from_pretrained function where we init with GPT2 weights\n- I removed dropout layers because the models we train here are small,\n  it's not necessary to understand at this stage and at this scale.\n- I removed weight decay and all of the complexity around what parameters are\n  and are not weight decayed. I don't believe this should make a massive\n  difference at the scale that we operate on here.\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport math\nimport argparse\nfrom dataclasses import dataclass\nfrom typing import List\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\nfrom torch.utils.data import Dataset\nfrom torch.utils.data.dataloader import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\n# -----------------------------------------------------------------------------\n# GPT model definition\n\n@dataclass\nclass GPTConfig:\n    # size of the model\n    n_layer: int = 4\n    n_head: int = 4\n    n_embd: int = 64\n    vocab_size: int = None\n    block_size: int = None\n\n@dataclass\nclass TrainConfig:\n    # optimization parameters\n    learning_rate: float = 5e-4\n    betas: List[float] = (0.9, 0.99)\n    weight_decay: float = 0.01\n\nclass NewGELU(nn.Module):\n    \"\"\"\n    Implementation of the GELU activation function currently in Google BERT repo (identical to OpenAI GPT).\n    Reference: Gaussian Error Linear Units (GELU) paper: https://arxiv.org/abs/1606.08415\n    \"\"\"\n    def forward(self, x):\n        return 0.5 * x * (1.0 + torch.tanh(math.sqrt(2.0 / math.pi) * (x + 0.044715 * torch.pow(x, 3.0))))\n\nclass CausalSelfAttention(nn.Module):\n    \"\"\"\n    A vanilla multi-head masked self-attention layer with a projection at the end.\n    It is possible to use torch.nn.MultiheadAttention here but I am including an\n    explicit implementation here to show that there is nothing too scary here.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.n_embd % config.n_head == 0\n        # key, query, value projections for all heads, but in a batch\n        self.c_attn = nn.Linear(config.n_embd, 3 * config.n_embd)\n        # output projection\n        self.c_proj = nn.Linear(config.n_embd, config.n_embd)\n        # causal mask to ensure that attention is only applied to the left in the input sequence\n        self.register_buffer(\"bias\", torch.tril(torch.ones(config.block_size, config.block_size))\n                                     .view(1, 1, config.block_size, config.block_size))\n        self.n_head = config.n_head\n        self.n_embd = config.n_embd\n\n    def forward(self, x):\n        B, T, C = x.size() # batch size, sequence length, embedding dimensionality (n_embd)\n\n        # calculate query, key, values for all heads in batch and move head forward to be the batch dim\n        q, k ,v  = self.c_attn(x).split(self.n_embd, dim=2)\n        k = k.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        q = q.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        v = v.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n\n        # causal self-attention; Self-attend: (B, nh, T, hs) x (B, nh, hs, T) -> (B, nh, T, T)\n        att = (q @ k.transpose(-2, -1)) * (1.0 / math.sqrt(k.size(-1)))\n        att = att.masked_fill(self.bias[:,:,:T,:T] == 0, float('-inf'))\n        att = F.softmax(att, dim=-1)\n        y = att @ v # (B, nh, T, T) x (B, nh, T, hs) -> (B, nh, T, hs)\n        y = y.transpose(1, 2).contiguous().view(B, T, C) # re-assemble all head outputs side by side\n\n        # output projection\n        y = self.c_proj(y)\n        return y\n\nclass Block(nn.Module):\n    \"\"\" an unassuming Transformer block \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.ln_1 = nn.LayerNorm(config.n_embd)\n        self.attn = CausalSelfAttention(config)\n        self.ln_2 = nn.LayerNorm(config.n_embd)\n        self.mlp = nn.ModuleDict(dict(\n            c_fc    = nn.Linear(config.n_embd, 4 * config.n_embd),\n            c_proj  = nn.Linear(4 * config.n_embd, config.n_embd),\n            act     = NewGELU(),\n        ))\n        m = self.mlp\n        self.mlpf = lambda x: m.c_proj(m.act(m.c_fc(x))) # MLP forward\n\n    def forward(self, x):\n        x = x + self.attn(self.ln_1(x))\n        x = x + self.mlpf(self.ln_2(x))\n        return x\n\nclass GPT(nn.Module):\n    \"\"\" GPT Language Model \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.vocab_size is not None\n        assert config.block_size is not None\n        self.block_size = config.block_size\n\n        self.transformer = nn.ModuleDict(dict(\n            wte = nn.Embedding(config.vocab_size, config.n_embd),\n            wpe = nn.Embedding(config.block_size, config.n_embd),\n            h = nn.ModuleList([Block(config) for _ in range(config.n_layer)]),\n            ln_f = nn.LayerNorm(config.n_embd),\n        ))\n        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n\n        # init all weights\n        self.apply(self._init_weights)\n\n        # report number of parameters (note we don't count the decoder parameters in lm_head)\n        n_params = sum(p.numel() for p in self.transformer.parameters())\n        print(\"number of parameters: %.2fM\" % (n_params/1e6,))\n\n    def _init_weights(self, module):\n        # TODO is this function needed?\n        if isinstance(module, nn.Linear):\n            torch.nn.init.normal_(module.weight, mean=0.0, std=0.02)\n            if module.bias is not None:\n                torch.nn.init.zeros_(module.bias)\n        elif isinstance(module, nn.Embedding):\n            torch.nn.init.normal_(module.weight, mean=0.0, std=0.02)\n        elif isinstance(module, nn.LayerNorm):\n            torch.nn.init.zeros_(module.bias)\n            torch.nn.init.ones_(module.weight)\n\n    def configure_optimizers(self, train_config):\n        optimizer = torch.optim.AdamW(self.parameters(), lr=train_config.learning_rate,\n                                      betas=train_config.betas, weight_decay=train_config.weight_decay,\n                                      eps=1e-8)\n        return optimizer\n\n    def forward(self, idx, targets=None):\n        device = idx.device\n        b, t = idx.size()\n        assert t <= self.block_size, f\"Cannot forward sequence of length {t}, block size is only {self.block_size}\"\n        pos = torch.arange(0, t, dtype=torch.long, device=device).unsqueeze(0) # shape (1, t)\n\n        # forward the GPT model itself\n        tok_emb = self.transformer.wte(idx) # token embeddings of shape (b, t, n_embd)\n        pos_emb = self.transformer.wpe(pos) # position embeddings of shape (1, t, n_embd)\n        x = tok_emb + pos_emb\n        for block in self.transformer.h:\n            x = block(x)\n        x = self.transformer.ln_f(x)\n        logits = self.lm_head(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n    @torch.no_grad()\n    def generate(self, idx, max_new_tokens, temperature=1.0, do_sample=False, top_k=None):\n        \"\"\"\n        Take a conditioning sequence of indices idx (LongTensor of shape (b,t)) and complete\n        the sequence max_new_tokens times, feeding the predictions back into the model each time.\n        Most likely you'll want to make sure to be in model.eval() mode of operation for this.\n        \"\"\"\n        for _ in range(max_new_tokens):\n            # if the sequence context is growing too long we must crop it at block_size\n            idx_cond = idx if idx.size(1) <= self.block_size else idx[:, -self.block_size:]\n            # forward the model to get the logits for the index in the sequence\n            logits, _ = self(idx_cond)\n            # pluck the logits at the final step and scale by desired temperature\n            logits = logits[:, -1, :] / temperature\n            # optionally crop the logits to only the top k options\n            if top_k is not None:\n                v, _ = torch.topk(logits, top_k)\n                logits[logits < v[:, [-1]]] = -float('Inf')\n            # apply softmax to convert logits to (normalized) probabilities\n            probs = F.softmax(logits, dim=-1)\n            # either sample from the distribution or take the most likely element\n            if do_sample:\n                idx_next = torch.multinomial(probs, num_samples=1)\n            else:\n                _, idx_next = torch.topk(probs, k=1, dim=-1)\n            # append sampled index to the running sequence and continue\n            idx = torch.cat((idx, idx_next), dim=1)\n\n        return idx\n\n# -----------------------------------------------------------------------------\n# helper functions for evaluating and sampling from the model\n\ndef print_samples(num=10):\n    \"\"\" samples from the model and pretty prints the decoded samples \"\"\"\n    X_init = torch.zeros(num, 1, dtype=torch.long).to(args.device)\n    top_k = args.top_k if args.top_k != -1 else None\n    steps = train_dataset.get_output_length() - 1 # -1 because we already start with <START> token (index 0)\n    X_samp = model.generate(X_init, steps, top_k=top_k, do_sample=True).to('cpu')\n    train_samples, test_samples, new_samples = [], [], []\n    for i in range(X_samp.size(0)):\n        # get the i'th row of sampled integers, as python list\n        row = X_samp[i, 1:].tolist() # note: we need to crop out the first <START> token\n        # token 0 is the <STOP> token, so we crop the output sequence at that point\n        crop_index = row.index(0) if 0 in row else len(row)\n        row = row[:crop_index]\n        word_samp = train_dataset.decode(row)\n        # separately track samples that we have and have not seen before\n        if train_dataset.contains(word_samp):\n            train_samples.append(word_samp)\n        elif test_dataset.contains(word_samp):\n            test_samples.append(word_samp)\n        else:\n            new_samples.append(word_samp)\n    print('-'*80)\n    for lst, desc in [(train_samples, 'in train'), (test_samples, 'in test'), (new_samples, 'new')]:\n        print(f\"{len(lst)} samples that are {desc}:\")\n        for word in lst:\n            print(word)\n    print('-'*80)\n\n@torch.inference_mode()\ndef evaluate(model, dataset, batch_size=50, max_batches=None):\n    model.eval()\n    loader = DataLoader(dataset, shuffle=True, batch_size=batch_size, num_workers=0)\n    losses = []\n    for i, batch in enumerate(loader):\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n        logits, loss = model(X, Y)\n        losses.append(loss.item())\n        if max_batches is not None and i >= max_batches:\n            break\n    mean_loss = torch.tensor(losses).mean().item()\n    model.train() # reset model back to training mode\n    return mean_loss\n\n# -----------------------------------------------------------------------------\n# helper functions for creating the training and test Datasets that emit words\n\nclass CharDataset(Dataset):\n\n    def __init__(self, words, chars, max_word_length):\n        self.words = words\n        self.chars = chars\n        self.max_word_length = max_word_length\n        self.stoi = {ch:i+1 for i,ch in enumerate(chars)}\n        self.itos = {i:s for s,i in self.stoi.items()} # inverse mapping\n\n    def __len__(self):\n        return len(self.words)\n\n    def contains(self, word):\n        return word in self.words\n\n    def get_vocab_size(self):\n        return len(self.chars) + 1 # all the possible characters and special 0 token\n\n    def get_output_length(self):\n        return self.max_word_length + 1 # <START> token followed by words\n\n    def encode(self, word):\n        ix = torch.tensor([self.stoi[w] for w in word], dtype=torch.long)\n        return ix\n\n    def decode(self, ix):\n        word = ''.join(self.itos[i] for i in ix)\n        return word\n\n    def __getitem__(self, idx):\n        word = self.words[idx]\n        ix = self.encode(word)\n        x = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        y = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        x[1:1+len(ix)] = ix\n        y[:len(ix)] = ix\n        y[len(ix)+1:] = -1 # index -1 will mask the loss at the inactive locations\n        return x, y\n\ndef create_datasets(input_file):\n\n    # preprocessing of the input text file\n    with open(input_file, 'r') as f:\n        data = f.read()\n    words = data.splitlines()\n    words = [w.strip() for w in words] # get rid of any leading or trailing white space\n    words = [w for w in words if w] # get rid of any empty strings\n    chars = sorted(list(set(''.join(words)))) # all the possible characters\n    max_word_length = max(len(w) for w in words)\n    print(f\"number of examples in the dataset: {len(words)}\")\n    print(f\"max word length: {max_word_length}\")\n    print(f\"number of unique characters in the vocabulary: {len(chars)}\")\n    print(\"vocabulary:\")\n    print(''.join(chars))\n\n    # partition the input data into a training and the test set\n    test_set_size = min(1000, int(len(words) * 0.1)) # 10% of the training set, or up to 1000 examples\n    rp = torch.randperm(len(words)).tolist()\n    train_words = [words[i] for i in rp[:-test_set_size]]\n    test_words = [words[i] for i in rp[-test_set_size:]]\n    print(f\"split up the dataset into {len(train_words)} training examples and {len(test_words)} test examples\")\n\n    # wrap in dataset objects\n    train_dataset = CharDataset(train_words, chars, max_word_length)\n    test_dataset = CharDataset(test_words, chars, max_word_length)\n\n    return train_dataset, test_dataset\n\n# -----------------------------------------------------------------------------\nif __name__ == '__main__':\n\n    # parse command line args\n    parser = argparse.ArgumentParser(description=\"Make More\")\n    # system/input/output\n    parser.add_argument('--input-file', '-i', type=str, default='names.txt', help=\"input file with things one per line\")\n    parser.add_argument('--work-dir', '-o', type=str, default='out', help=\"output working directory\")\n    parser.add_argument('--resume', action='store_true', help=\"when this flag is used, we will resume optimization from existing model in the workdir\")\n    parser.add_argument('--sample-only', action='store_true', help=\"just sample from the model and quit, don't train\")\n    parser.add_argument('--num-workers', '-n', type=int, default=4, help=\"number of data workers for both train/test\")\n    parser.add_argument('--max-steps', type=int, default=-1, help=\"max number of optimization steps to run for, or -1 for infinite.\")\n    parser.add_argument('--device', type=str, default='cpu', help=\"device to use for compute, examples: cpu|cuda|cuda:2|mps\")\n    parser.add_argument('--seed', type=int, default=3407, help=\"seed\")\n    # sampling\n    parser.add_argument('--top-k', type=int, default=-1, help=\"top-k for sampling, -1 means no top-k\")\n    # model\n    parser.add_argument('--n-layer', type=int, default=4, help=\"number of layers in the transformer\")\n    parser.add_argument('--n-head', type=int, default=4, help=\"number of heads in the transformer\")\n    parser.add_argument('--n-embd', type=int, default=64, help=\"number of feature channels in the transformer\")\n    # optimization\n    parser.add_argument('--batch-size', '-b', type=int, default=32, help=\"batch size during optimization\")\n    parser.add_argument('--learning-rate', '-l', type=float, default=5e-4, help=\"learning rate\")\n    parser.add_argument('--weight-decay', '-w', type=float, default=0.01, help=\"weight decay\")\n    args = parser.parse_args()\n    print(vars(args))\n\n    # system inits\n    torch.manual_seed(args.seed)\n    torch.cuda.manual_seed_all(args.seed)\n    os.makedirs(args.work_dir, exist_ok=True)\n    writer = SummaryWriter(log_dir=args.work_dir)\n\n    # init datasets\n    train_dataset, test_dataset = create_datasets(args.input_file)\n    vocab_size = train_dataset.get_vocab_size()\n    block_size = train_dataset.get_output_length()\n    print(f\"dataset determined that: {vocab_size=}, {block_size=}\")\n\n    # init model\n    config = GPTConfig(vocab_size=vocab_size, block_size=block_size,\n                       n_layer=args.n_layer, n_head=args.n_head, n_embd=args.n_embd)\n    model = GPT(config)\n    model.to(args.device)\n    print(f\"model #params: {sum(p.numel() for p in model.parameters())}\")\n    if args.resume or args.sample_only: # note: if we sample-only then we also assume we're resuming\n        print(\"resuming from existing model in the workdir\")\n        model.load_state_dict(torch.load(os.path.join(args.work_dir, 'model.pt')))\n    if args.sample_only:\n        print_samples(num=50)\n        sys.exit()\n\n    # init optimizer\n    train_config = TrainConfig(learning_rate=args.learning_rate, weight_decay=args.weight_decay)\n    optimizer = model.configure_optimizers(train_config)\n\n    # init dataloader\n    train_sampler = torch.utils.data.RandomSampler(train_dataset, replacement=True, num_samples=int(1e10))\n    train_loader = DataLoader(train_dataset, batch_size=args.batch_size, pin_memory=True,\n                              num_workers=args.num_workers, sampler=train_sampler)\n    data_iter = iter(train_loader)\n\n    # training loop\n    best_loss = None\n    step = 0\n    while True:\n\n        t0 = time.time()\n        # fetch the next batch and reset dataloader every epoch as necessary\n        try:\n            batch = next(data_iter)\n        except StopIteration:\n            data_iter = iter(train_loader)\n            batch = next(data_iter)\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n\n        # feed into the model\n        logits, loss = model(X, Y)\n\n        # calculate the gradient, clip it, update the weights\n        model.zero_grad(set_to_none=True)\n        loss.backward()\n        torch.nn.utils.clip_grad_norm_(model.parameters(), 1.0)\n        optimizer.step()\n        if args.device.startswith('cuda'):\n            torch.cuda.synchronize()\n        t1 = time.time()\n\n        # logging\n        if step % 10 == 0:\n            print(f\"step {step} | loss {loss.item():.4f} | step time {(t1-t0)*1000:.2f}ms\")\n\n        # evaluate the model\n        if step > 0 and step % 500 == 0:\n            train_loss = evaluate(model, train_dataset, batch_size=100, max_batches=10)\n            test_loss  = evaluate(model, test_dataset,  batch_size=100, max_batches=10)\n            writer.add_scalar(\"Loss/train\", train_loss, step)\n            writer.add_scalar(\"Loss/test\", test_loss, step)\n            writer.flush()\n            print(f\"step {step} train loss: {train_loss} test loss: {test_loss}\")\n            # save the model to disk if it has improved\n            if best_loss is None or test_loss < best_loss:\n                out_path = os.path.join(args.work_dir, \"model.pt\")\n                print(f\"test loss {test_loss} is the best so far, saving model to {out_path}\")\n                torch.save(model.state_dict(), out_path)\n                best_loss = test_loss\n\n        # sample from the model\n        if step > 0 and step % 200 == 0:\n            print_samples(num=10)\n\n        step += 1\n        # termination conditions\n        if args.max_steps >= 0 and step >= args.max_steps:\n            break\n\n", "diff": "@@ -337,7 +337,8 @@ def create_datasets(input_file):\n     parser.add_argument('--work-dir', '-o', type=str, default='out', help=\"output working directory\")\n     parser.add_argument('--resume', action='store_true', help=\"when this flag is used, we will resume optimization from existing model in the workdir\")\n     parser.add_argument('--sample-only', action='store_true', help=\"just sample from the model and quit, don't train\")\n-    parser.add_argument('--num-workers', '-n', type=int, default=0, help=\"number of data workers for both train/test\")\n+    parser.add_argument('--num-workers', '-n', type=int, default=4, help=\"number of data workers for both train/test\")\n+    parser.add_argument('--max-steps', type=int, default=-1, help=\"max number of optimization steps to run for, or -1 for infinite.\")\n     parser.add_argument('--device', type=str, default='cpu', help=\"device to use for compute, examples: cpu|cuda|cuda:2|mps\")\n     parser.add_argument('--seed', type=int, default=3407, help=\"seed\")\n     # sampling\n@@ -439,3 +440,7 @@ def create_datasets(input_file):\n             print_samples(num=10)\n \n         step += 1\n+        # termination conditions\n+        if args.max_steps >= 0 and step >= args.max_steps:\n+            break\n+", "status": "modified"}, {"commit_id": "055e7ee48a610dade030c1888dc70d503bf6a1f8", "commit_message": "respect multigpu envs, e.g. cuda:2 designation should work", "relative_path": "makemore.py", "previous_code_file": "\"\"\"\nyou give this script some words (one per line) and it will generate more things like it.\nuses super state of the art Transformer AI tech\nthis code is intended to be super hackable. tune it to your needs.\n\nChanges from minGPT:\n- I removed the from_pretrained function where we init with GPT2 weights\n- I removed dropout layers because the models we train here are small,\n  it's not necessary to understand at this stage and at this scale.\n- I removed weight decay and all of the complexity around what parameters are\n  and are not weight decayed. I don't believe this should make a massive\n  difference at the scale that we operate on here.\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport math\nimport argparse\nfrom dataclasses import dataclass\nfrom typing import List\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\nfrom torch.utils.data import Dataset\nfrom torch.utils.data.dataloader import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\n# -----------------------------------------------------------------------------\n# GPT model definition\n\n@dataclass\nclass GPTConfig:\n    # size of the model\n    n_layer: int = 4\n    n_head: int = 4\n    n_embd: int = 64\n    vocab_size: int = None\n    block_size: int = None\n\n@dataclass\nclass TrainConfig:\n    # optimization parameters\n    learning_rate: float = 5e-4\n    betas: List[float] = (0.9, 0.99)\n    weight_decay: float = 0.01\n\nclass NewGELU(nn.Module):\n    \"\"\"\n    Implementation of the GELU activation function currently in Google BERT repo (identical to OpenAI GPT).\n    Reference: Gaussian Error Linear Units (GELU) paper: https://arxiv.org/abs/1606.08415\n    \"\"\"\n    def forward(self, x):\n        return 0.5 * x * (1.0 + torch.tanh(math.sqrt(2.0 / math.pi) * (x + 0.044715 * torch.pow(x, 3.0))))\n\nclass CausalSelfAttention(nn.Module):\n    \"\"\"\n    A vanilla multi-head masked self-attention layer with a projection at the end.\n    It is possible to use torch.nn.MultiheadAttention here but I am including an\n    explicit implementation here to show that there is nothing too scary here.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.n_embd % config.n_head == 0\n        # key, query, value projections for all heads, but in a batch\n        self.c_attn = nn.Linear(config.n_embd, 3 * config.n_embd)\n        # output projection\n        self.c_proj = nn.Linear(config.n_embd, config.n_embd)\n        # causal mask to ensure that attention is only applied to the left in the input sequence\n        self.register_buffer(\"bias\", torch.tril(torch.ones(config.block_size, config.block_size))\n                                     .view(1, 1, config.block_size, config.block_size))\n        self.n_head = config.n_head\n        self.n_embd = config.n_embd\n\n    def forward(self, x):\n        B, T, C = x.size() # batch size, sequence length, embedding dimensionality (n_embd)\n\n        # calculate query, key, values for all heads in batch and move head forward to be the batch dim\n        q, k ,v  = self.c_attn(x).split(self.n_embd, dim=2)\n        k = k.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        q = q.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        v = v.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n\n        # causal self-attention; Self-attend: (B, nh, T, hs) x (B, nh, hs, T) -> (B, nh, T, T)\n        att = (q @ k.transpose(-2, -1)) * (1.0 / math.sqrt(k.size(-1)))\n        att = att.masked_fill(self.bias[:,:,:T,:T] == 0, float('-inf'))\n        att = F.softmax(att, dim=-1)\n        y = att @ v # (B, nh, T, T) x (B, nh, T, hs) -> (B, nh, T, hs)\n        y = y.transpose(1, 2).contiguous().view(B, T, C) # re-assemble all head outputs side by side\n\n        # output projection\n        y = self.c_proj(y)\n        return y\n\nclass Block(nn.Module):\n    \"\"\" an unassuming Transformer block \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.ln_1 = nn.LayerNorm(config.n_embd)\n        self.attn = CausalSelfAttention(config)\n        self.ln_2 = nn.LayerNorm(config.n_embd)\n        self.mlp = nn.ModuleDict(dict(\n            c_fc    = nn.Linear(config.n_embd, 4 * config.n_embd),\n            c_proj  = nn.Linear(4 * config.n_embd, config.n_embd),\n            act     = NewGELU(),\n        ))\n        m = self.mlp\n        self.mlpf = lambda x: m.c_proj(m.act(m.c_fc(x))) # MLP forward\n\n    def forward(self, x):\n        x = x + self.attn(self.ln_1(x))\n        x = x + self.mlpf(self.ln_2(x))\n        return x\n\nclass GPT(nn.Module):\n    \"\"\" GPT Language Model \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.vocab_size is not None\n        assert config.block_size is not None\n        self.block_size = config.block_size\n\n        self.transformer = nn.ModuleDict(dict(\n            wte = nn.Embedding(config.vocab_size, config.n_embd),\n            wpe = nn.Embedding(config.block_size, config.n_embd),\n            h = nn.ModuleList([Block(config) for _ in range(config.n_layer)]),\n            ln_f = nn.LayerNorm(config.n_embd),\n        ))\n        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n\n        # init all weights\n        self.apply(self._init_weights)\n\n        # report number of parameters (note we don't count the decoder parameters in lm_head)\n        n_params = sum(p.numel() for p in self.transformer.parameters())\n        print(\"number of parameters: %.2fM\" % (n_params/1e6,))\n\n    def _init_weights(self, module):\n        # TODO is this function needed?\n        if isinstance(module, nn.Linear):\n            torch.nn.init.normal_(module.weight, mean=0.0, std=0.02)\n            if module.bias is not None:\n                torch.nn.init.zeros_(module.bias)\n        elif isinstance(module, nn.Embedding):\n            torch.nn.init.normal_(module.weight, mean=0.0, std=0.02)\n        elif isinstance(module, nn.LayerNorm):\n            torch.nn.init.zeros_(module.bias)\n            torch.nn.init.ones_(module.weight)\n\n    def configure_optimizers(self, train_config):\n        optimizer = torch.optim.AdamW(self.parameters(), lr=train_config.learning_rate,\n                                      betas=train_config.betas, weight_decay=train_config.weight_decay,\n                                      eps=1e-8)\n        return optimizer\n\n    def forward(self, idx, targets=None):\n        device = idx.device\n        b, t = idx.size()\n        assert t <= self.block_size, f\"Cannot forward sequence of length {t}, block size is only {self.block_size}\"\n        pos = torch.arange(0, t, dtype=torch.long, device=device).unsqueeze(0) # shape (1, t)\n\n        # forward the GPT model itself\n        tok_emb = self.transformer.wte(idx) # token embeddings of shape (b, t, n_embd)\n        pos_emb = self.transformer.wpe(pos) # position embeddings of shape (1, t, n_embd)\n        x = tok_emb + pos_emb\n        for block in self.transformer.h:\n            x = block(x)\n        x = self.transformer.ln_f(x)\n        logits = self.lm_head(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n    @torch.no_grad()\n    def generate(self, idx, max_new_tokens, temperature=1.0, do_sample=False, top_k=None):\n        \"\"\"\n        Take a conditioning sequence of indices idx (LongTensor of shape (b,t)) and complete\n        the sequence max_new_tokens times, feeding the predictions back into the model each time.\n        Most likely you'll want to make sure to be in model.eval() mode of operation for this.\n        \"\"\"\n        for _ in range(max_new_tokens):\n            # if the sequence context is growing too long we must crop it at block_size\n            idx_cond = idx if idx.size(1) <= self.block_size else idx[:, -self.block_size:]\n            # forward the model to get the logits for the index in the sequence\n            logits, _ = self(idx_cond)\n            # pluck the logits at the final step and scale by desired temperature\n            logits = logits[:, -1, :] / temperature\n            # optionally crop the logits to only the top k options\n            if top_k is not None:\n                v, _ = torch.topk(logits, top_k)\n                logits[logits < v[:, [-1]]] = -float('Inf')\n            # apply softmax to convert logits to (normalized) probabilities\n            probs = F.softmax(logits, dim=-1)\n            # either sample from the distribution or take the most likely element\n            if do_sample:\n                idx_next = torch.multinomial(probs, num_samples=1)\n            else:\n                _, idx_next = torch.topk(probs, k=1, dim=-1)\n            # append sampled index to the running sequence and continue\n            idx = torch.cat((idx, idx_next), dim=1)\n\n        return idx\n\n# -----------------------------------------------------------------------------\n# helper functions for evaluating and sampling from the model\n\ndef print_samples(num=10):\n    \"\"\" samples from the model and pretty prints the decoded samples \"\"\"\n    X_init = torch.zeros(num, 1, dtype=torch.long).to(args.device)\n    top_k = args.top_k if args.top_k != -1 else None\n    steps = train_dataset.get_output_length() - 1 # -1 because we already start with <START> token (index 0)\n    X_samp = model.generate(X_init, steps, top_k=top_k, do_sample=True).to('cpu')\n    train_samples, test_samples, new_samples = [], [], []\n    for i in range(X_samp.size(0)):\n        # get the i'th row of sampled integers, as python list\n        row = X_samp[i, 1:].tolist() # note: we need to crop out the first <START> token\n        # token 0 is the <STOP> token, so we crop the output sequence at that point\n        crop_index = row.index(0) if 0 in row else len(row)\n        row = row[:crop_index]\n        word_samp = train_dataset.decode(row)\n        # separately track samples that we have and have not seen before\n        if train_dataset.contains(word_samp):\n            train_samples.append(word_samp)\n        elif test_dataset.contains(word_samp):\n            test_samples.append(word_samp)\n        else:\n            new_samples.append(word_samp)\n    print('-'*80)\n    for lst, desc in [(train_samples, 'in train'), (test_samples, 'in test'), (new_samples, 'new')]:\n        print(f\"{len(lst)} samples that are {desc}:\")\n        for word in lst:\n            print(word)\n    print('-'*80)\n\n@torch.inference_mode()\ndef evaluate(model, dataset, batch_size=50, max_batches=None):\n    model.eval()\n    loader = DataLoader(dataset, shuffle=True, batch_size=batch_size, num_workers=0)\n    losses = []\n    for i, batch in enumerate(loader):\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n        logits, loss = model(X, Y)\n        losses.append(loss.item())\n        if max_batches is not None and i >= max_batches:\n            break\n    mean_loss = torch.tensor(losses).mean().item()\n    model.train() # reset model back to training mode\n    return mean_loss\n\n# -----------------------------------------------------------------------------\n# helper functions for creating the training and test Datasets that emit words\n\nclass CharDataset(Dataset):\n\n    def __init__(self, words, chars, max_word_length):\n        self.words = words\n        self.chars = chars\n        self.max_word_length = max_word_length\n        self.stoi = {ch:i+1 for i,ch in enumerate(chars)}\n        self.itos = {i:s for s,i in self.stoi.items()} # inverse mapping\n\n    def __len__(self):\n        return len(self.words)\n\n    def contains(self, word):\n        return word in self.words\n\n    def get_vocab_size(self):\n        return len(self.chars) + 1 # all the possible characters and special 0 token\n\n    def get_output_length(self):\n        return self.max_word_length + 1 # <START> token followed by words\n\n    def encode(self, word):\n        ix = torch.tensor([self.stoi[w] for w in word], dtype=torch.long)\n        return ix\n\n    def decode(self, ix):\n        word = ''.join(self.itos[i] for i in ix)\n        return word\n\n    def __getitem__(self, idx):\n        word = self.words[idx]\n        ix = self.encode(word)\n        x = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        y = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        x[1:1+len(ix)] = ix\n        y[:len(ix)] = ix\n        y[len(ix)+1:] = -1 # index -1 will mask the loss at the inactive locations\n        return x, y\n\ndef create_datasets(input_file):\n\n    # preprocessing of the input text file\n    with open(input_file, 'r') as f:\n        data = f.read()\n    words = data.splitlines()\n    words = [w.strip() for w in words] # get rid of any leading or trailing white space\n    words = [w for w in words if w] # get rid of any empty strings\n    chars = sorted(list(set(''.join(words)))) # all the possible characters\n    max_word_length = max(len(w) for w in words)\n    print(f\"number of examples in the dataset: {len(words)}\")\n    print(f\"max word length: {max_word_length}\")\n    print(f\"number of unique characters in the vocabulary: {len(chars)}\")\n    print(\"vocabulary:\")\n    print(''.join(chars))\n\n    # partition the input data into a training and the test set\n    test_set_size = min(1000, int(len(words) * 0.1)) # 10% of the training set, or up to 1000 examples\n    rp = torch.randperm(len(words)).tolist()\n    train_words = [words[i] for i in rp[:-test_set_size]]\n    test_words = [words[i] for i in rp[-test_set_size:]]\n    print(f\"split up the dataset into {len(train_words)} training examples and {len(test_words)} test examples\")\n\n    # wrap in dataset objects\n    train_dataset = CharDataset(train_words, chars, max_word_length)\n    test_dataset = CharDataset(test_words, chars, max_word_length)\n\n    return train_dataset, test_dataset\n\n# -----------------------------------------------------------------------------\nif __name__ == '__main__':\n\n    # parse command line args\n    parser = argparse.ArgumentParser(description=\"Make More\")\n    # system/input/output\n    parser.add_argument('--input-file', '-i', type=str, default='names.txt', help=\"input file with things one per line\")\n    parser.add_argument('--work-dir', '-o', type=str, default='out', help=\"output working directory\")\n    parser.add_argument('--resume', action='store_true', help=\"when this flag is used, we will resume optimization from existing model in the workdir\")\n    parser.add_argument('--sample-only', action='store_true', help=\"just sample from the model and quit, don't train\")\n    parser.add_argument('--num-workers', '-n', type=int, default=0, help=\"number of data workers for both train/test\")\n    parser.add_argument('--device', type=str, default='cpu', help=\"device to use for compute, examples: cpu|cuda|cuda:2|mps\")\n    parser.add_argument('--seed', type=int, default=3407, help=\"seed\")\n    # sampling\n    parser.add_argument('--top-k', type=int, default=-1, help=\"top-k for sampling, -1 means no top-k\")\n    # model\n    parser.add_argument('--n-layer', type=int, default=4, help=\"number of layers in the transformer\")\n    parser.add_argument('--n-head', type=int, default=4, help=\"number of heads in the transformer\")\n    parser.add_argument('--n-embd', type=int, default=64, help=\"number of feature channels in the transformer\")\n    # optimization\n    parser.add_argument('--batch-size', '-b', type=int, default=32, help=\"batch size during optimization\")\n    parser.add_argument('--learning-rate', '-l', type=float, default=5e-4, help=\"learning rate\")\n    parser.add_argument('--weight-decay', '-w', type=float, default=0.01, help=\"weight decay\")\n    args = parser.parse_args()\n    print(vars(args))\n\n    # system inits\n    torch.manual_seed(args.seed)\n    torch.cuda.manual_seed_all(args.seed)\n    os.makedirs(args.work_dir, exist_ok=True)\n    writer = SummaryWriter(log_dir=args.work_dir)\n\n    # init datasets\n    train_dataset, test_dataset = create_datasets(args.input_file)\n    vocab_size = train_dataset.get_vocab_size()\n    block_size = train_dataset.get_output_length()\n    print(f\"dataset determined that: {vocab_size=}, {block_size=}\")\n\n    # init model\n    config = GPTConfig(vocab_size=vocab_size, block_size=block_size,\n                       n_layer=args.n_layer, n_head=args.n_head, n_embd=args.n_embd)\n    model = GPT(config)\n    model.to(args.device)\n    print(f\"model #params: {sum(p.numel() for p in model.parameters())}\")\n    if args.resume or args.sample_only: # note: if we sample-only then we also assume we're resuming\n        print(\"resuming from existing model in the workdir\")\n        model.load_state_dict(torch.load(os.path.join(args.work_dir, 'model.pt')))\n    if args.sample_only:\n        print_samples(num=50)\n        sys.exit()\n\n    # init optimizer\n    train_config = TrainConfig(learning_rate=args.learning_rate, weight_decay=args.weight_decay)\n    optimizer = model.configure_optimizers(train_config)\n\n    # init dataloader\n    train_sampler = torch.utils.data.RandomSampler(train_dataset, replacement=True, num_samples=int(1e10))\n    train_loader = DataLoader(train_dataset, batch_size=args.batch_size, pin_memory=True,\n                              num_workers=args.num_workers, sampler=train_sampler)\n    data_iter = iter(train_loader)\n\n    # training loop\n    best_loss = None\n    step = 0\n    while True:\n\n        t0 = time.time()\n        # fetch the next batch and reset dataloader every epoch as necessary\n        try:\n            batch = next(data_iter)\n        except StopIteration:\n            data_iter = iter(train_loader)\n            batch = next(data_iter)\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n\n        # feed into the model\n        logits, loss = model(X, Y)\n\n        # calculate the gradient, clip it, update the weights\n        model.zero_grad(set_to_none=True)\n        loss.backward()\n        torch.nn.utils.clip_grad_norm_(model.parameters(), 1.0)\n        optimizer.step()\n        if args.device == 'cuda':\n            torch.cuda.synchronize()\n        t1 = time.time()\n\n        # logging\n        if step % 10 == 0:\n            print(f\"step {step} | loss {loss.item():.4f} | step time {(t1-t0)*1000:.2f}ms\")\n\n        # evaluate the model\n        if step > 0 and step % 500 == 0:\n            train_loss = evaluate(model, train_dataset, batch_size=100, max_batches=10)\n            test_loss  = evaluate(model, test_dataset,  batch_size=100, max_batches=10)\n            writer.add_scalar(\"Loss/train\", train_loss, step)\n            writer.add_scalar(\"Loss/test\", test_loss, step)\n            writer.flush()\n            print(f\"step {step} train loss: {train_loss} test loss: {test_loss}\")\n            # save the model to disk if it has improved\n            if best_loss is None or test_loss < best_loss:\n                out_path = os.path.join(args.work_dir, \"model.pt\")\n                print(f\"test loss {test_loss} is the best so far, saving model to {out_path}\")\n                torch.save(model.state_dict(), out_path)\n                best_loss = test_loss\n\n        # sample from the model\n        if step > 0 and step % 200 == 0:\n            print_samples(num=10)\n\n        step += 1\n", "previous_id": "013af92770a9749e3d77745e502b0124329ae238", "new_code_file": "\"\"\"\nyou give this script some words (one per line) and it will generate more things like it.\nuses super state of the art Transformer AI tech\nthis code is intended to be super hackable. tune it to your needs.\n\nChanges from minGPT:\n- I removed the from_pretrained function where we init with GPT2 weights\n- I removed dropout layers because the models we train here are small,\n  it's not necessary to understand at this stage and at this scale.\n- I removed weight decay and all of the complexity around what parameters are\n  and are not weight decayed. I don't believe this should make a massive\n  difference at the scale that we operate on here.\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport math\nimport argparse\nfrom dataclasses import dataclass\nfrom typing import List\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\nfrom torch.utils.data import Dataset\nfrom torch.utils.data.dataloader import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\n# -----------------------------------------------------------------------------\n# GPT model definition\n\n@dataclass\nclass GPTConfig:\n    # size of the model\n    n_layer: int = 4\n    n_head: int = 4\n    n_embd: int = 64\n    vocab_size: int = None\n    block_size: int = None\n\n@dataclass\nclass TrainConfig:\n    # optimization parameters\n    learning_rate: float = 5e-4\n    betas: List[float] = (0.9, 0.99)\n    weight_decay: float = 0.01\n\nclass NewGELU(nn.Module):\n    \"\"\"\n    Implementation of the GELU activation function currently in Google BERT repo (identical to OpenAI GPT).\n    Reference: Gaussian Error Linear Units (GELU) paper: https://arxiv.org/abs/1606.08415\n    \"\"\"\n    def forward(self, x):\n        return 0.5 * x * (1.0 + torch.tanh(math.sqrt(2.0 / math.pi) * (x + 0.044715 * torch.pow(x, 3.0))))\n\nclass CausalSelfAttention(nn.Module):\n    \"\"\"\n    A vanilla multi-head masked self-attention layer with a projection at the end.\n    It is possible to use torch.nn.MultiheadAttention here but I am including an\n    explicit implementation here to show that there is nothing too scary here.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.n_embd % config.n_head == 0\n        # key, query, value projections for all heads, but in a batch\n        self.c_attn = nn.Linear(config.n_embd, 3 * config.n_embd)\n        # output projection\n        self.c_proj = nn.Linear(config.n_embd, config.n_embd)\n        # causal mask to ensure that attention is only applied to the left in the input sequence\n        self.register_buffer(\"bias\", torch.tril(torch.ones(config.block_size, config.block_size))\n                                     .view(1, 1, config.block_size, config.block_size))\n        self.n_head = config.n_head\n        self.n_embd = config.n_embd\n\n    def forward(self, x):\n        B, T, C = x.size() # batch size, sequence length, embedding dimensionality (n_embd)\n\n        # calculate query, key, values for all heads in batch and move head forward to be the batch dim\n        q, k ,v  = self.c_attn(x).split(self.n_embd, dim=2)\n        k = k.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        q = q.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        v = v.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n\n        # causal self-attention; Self-attend: (B, nh, T, hs) x (B, nh, hs, T) -> (B, nh, T, T)\n        att = (q @ k.transpose(-2, -1)) * (1.0 / math.sqrt(k.size(-1)))\n        att = att.masked_fill(self.bias[:,:,:T,:T] == 0, float('-inf'))\n        att = F.softmax(att, dim=-1)\n        y = att @ v # (B, nh, T, T) x (B, nh, T, hs) -> (B, nh, T, hs)\n        y = y.transpose(1, 2).contiguous().view(B, T, C) # re-assemble all head outputs side by side\n\n        # output projection\n        y = self.c_proj(y)\n        return y\n\nclass Block(nn.Module):\n    \"\"\" an unassuming Transformer block \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.ln_1 = nn.LayerNorm(config.n_embd)\n        self.attn = CausalSelfAttention(config)\n        self.ln_2 = nn.LayerNorm(config.n_embd)\n        self.mlp = nn.ModuleDict(dict(\n            c_fc    = nn.Linear(config.n_embd, 4 * config.n_embd),\n            c_proj  = nn.Linear(4 * config.n_embd, config.n_embd),\n            act     = NewGELU(),\n        ))\n        m = self.mlp\n        self.mlpf = lambda x: m.c_proj(m.act(m.c_fc(x))) # MLP forward\n\n    def forward(self, x):\n        x = x + self.attn(self.ln_1(x))\n        x = x + self.mlpf(self.ln_2(x))\n        return x\n\nclass GPT(nn.Module):\n    \"\"\" GPT Language Model \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.vocab_size is not None\n        assert config.block_size is not None\n        self.block_size = config.block_size\n\n        self.transformer = nn.ModuleDict(dict(\n            wte = nn.Embedding(config.vocab_size, config.n_embd),\n            wpe = nn.Embedding(config.block_size, config.n_embd),\n            h = nn.ModuleList([Block(config) for _ in range(config.n_layer)]),\n            ln_f = nn.LayerNorm(config.n_embd),\n        ))\n        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n\n        # init all weights\n        self.apply(self._init_weights)\n\n        # report number of parameters (note we don't count the decoder parameters in lm_head)\n        n_params = sum(p.numel() for p in self.transformer.parameters())\n        print(\"number of parameters: %.2fM\" % (n_params/1e6,))\n\n    def _init_weights(self, module):\n        # TODO is this function needed?\n        if isinstance(module, nn.Linear):\n            torch.nn.init.normal_(module.weight, mean=0.0, std=0.02)\n            if module.bias is not None:\n                torch.nn.init.zeros_(module.bias)\n        elif isinstance(module, nn.Embedding):\n            torch.nn.init.normal_(module.weight, mean=0.0, std=0.02)\n        elif isinstance(module, nn.LayerNorm):\n            torch.nn.init.zeros_(module.bias)\n            torch.nn.init.ones_(module.weight)\n\n    def configure_optimizers(self, train_config):\n        optimizer = torch.optim.AdamW(self.parameters(), lr=train_config.learning_rate,\n                                      betas=train_config.betas, weight_decay=train_config.weight_decay,\n                                      eps=1e-8)\n        return optimizer\n\n    def forward(self, idx, targets=None):\n        device = idx.device\n        b, t = idx.size()\n        assert t <= self.block_size, f\"Cannot forward sequence of length {t}, block size is only {self.block_size}\"\n        pos = torch.arange(0, t, dtype=torch.long, device=device).unsqueeze(0) # shape (1, t)\n\n        # forward the GPT model itself\n        tok_emb = self.transformer.wte(idx) # token embeddings of shape (b, t, n_embd)\n        pos_emb = self.transformer.wpe(pos) # position embeddings of shape (1, t, n_embd)\n        x = tok_emb + pos_emb\n        for block in self.transformer.h:\n            x = block(x)\n        x = self.transformer.ln_f(x)\n        logits = self.lm_head(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n    @torch.no_grad()\n    def generate(self, idx, max_new_tokens, temperature=1.0, do_sample=False, top_k=None):\n        \"\"\"\n        Take a conditioning sequence of indices idx (LongTensor of shape (b,t)) and complete\n        the sequence max_new_tokens times, feeding the predictions back into the model each time.\n        Most likely you'll want to make sure to be in model.eval() mode of operation for this.\n        \"\"\"\n        for _ in range(max_new_tokens):\n            # if the sequence context is growing too long we must crop it at block_size\n            idx_cond = idx if idx.size(1) <= self.block_size else idx[:, -self.block_size:]\n            # forward the model to get the logits for the index in the sequence\n            logits, _ = self(idx_cond)\n            # pluck the logits at the final step and scale by desired temperature\n            logits = logits[:, -1, :] / temperature\n            # optionally crop the logits to only the top k options\n            if top_k is not None:\n                v, _ = torch.topk(logits, top_k)\n                logits[logits < v[:, [-1]]] = -float('Inf')\n            # apply softmax to convert logits to (normalized) probabilities\n            probs = F.softmax(logits, dim=-1)\n            # either sample from the distribution or take the most likely element\n            if do_sample:\n                idx_next = torch.multinomial(probs, num_samples=1)\n            else:\n                _, idx_next = torch.topk(probs, k=1, dim=-1)\n            # append sampled index to the running sequence and continue\n            idx = torch.cat((idx, idx_next), dim=1)\n\n        return idx\n\n# -----------------------------------------------------------------------------\n# helper functions for evaluating and sampling from the model\n\ndef print_samples(num=10):\n    \"\"\" samples from the model and pretty prints the decoded samples \"\"\"\n    X_init = torch.zeros(num, 1, dtype=torch.long).to(args.device)\n    top_k = args.top_k if args.top_k != -1 else None\n    steps = train_dataset.get_output_length() - 1 # -1 because we already start with <START> token (index 0)\n    X_samp = model.generate(X_init, steps, top_k=top_k, do_sample=True).to('cpu')\n    train_samples, test_samples, new_samples = [], [], []\n    for i in range(X_samp.size(0)):\n        # get the i'th row of sampled integers, as python list\n        row = X_samp[i, 1:].tolist() # note: we need to crop out the first <START> token\n        # token 0 is the <STOP> token, so we crop the output sequence at that point\n        crop_index = row.index(0) if 0 in row else len(row)\n        row = row[:crop_index]\n        word_samp = train_dataset.decode(row)\n        # separately track samples that we have and have not seen before\n        if train_dataset.contains(word_samp):\n            train_samples.append(word_samp)\n        elif test_dataset.contains(word_samp):\n            test_samples.append(word_samp)\n        else:\n            new_samples.append(word_samp)\n    print('-'*80)\n    for lst, desc in [(train_samples, 'in train'), (test_samples, 'in test'), (new_samples, 'new')]:\n        print(f\"{len(lst)} samples that are {desc}:\")\n        for word in lst:\n            print(word)\n    print('-'*80)\n\n@torch.inference_mode()\ndef evaluate(model, dataset, batch_size=50, max_batches=None):\n    model.eval()\n    loader = DataLoader(dataset, shuffle=True, batch_size=batch_size, num_workers=0)\n    losses = []\n    for i, batch in enumerate(loader):\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n        logits, loss = model(X, Y)\n        losses.append(loss.item())\n        if max_batches is not None and i >= max_batches:\n            break\n    mean_loss = torch.tensor(losses).mean().item()\n    model.train() # reset model back to training mode\n    return mean_loss\n\n# -----------------------------------------------------------------------------\n# helper functions for creating the training and test Datasets that emit words\n\nclass CharDataset(Dataset):\n\n    def __init__(self, words, chars, max_word_length):\n        self.words = words\n        self.chars = chars\n        self.max_word_length = max_word_length\n        self.stoi = {ch:i+1 for i,ch in enumerate(chars)}\n        self.itos = {i:s for s,i in self.stoi.items()} # inverse mapping\n\n    def __len__(self):\n        return len(self.words)\n\n    def contains(self, word):\n        return word in self.words\n\n    def get_vocab_size(self):\n        return len(self.chars) + 1 # all the possible characters and special 0 token\n\n    def get_output_length(self):\n        return self.max_word_length + 1 # <START> token followed by words\n\n    def encode(self, word):\n        ix = torch.tensor([self.stoi[w] for w in word], dtype=torch.long)\n        return ix\n\n    def decode(self, ix):\n        word = ''.join(self.itos[i] for i in ix)\n        return word\n\n    def __getitem__(self, idx):\n        word = self.words[idx]\n        ix = self.encode(word)\n        x = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        y = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        x[1:1+len(ix)] = ix\n        y[:len(ix)] = ix\n        y[len(ix)+1:] = -1 # index -1 will mask the loss at the inactive locations\n        return x, y\n\ndef create_datasets(input_file):\n\n    # preprocessing of the input text file\n    with open(input_file, 'r') as f:\n        data = f.read()\n    words = data.splitlines()\n    words = [w.strip() for w in words] # get rid of any leading or trailing white space\n    words = [w for w in words if w] # get rid of any empty strings\n    chars = sorted(list(set(''.join(words)))) # all the possible characters\n    max_word_length = max(len(w) for w in words)\n    print(f\"number of examples in the dataset: {len(words)}\")\n    print(f\"max word length: {max_word_length}\")\n    print(f\"number of unique characters in the vocabulary: {len(chars)}\")\n    print(\"vocabulary:\")\n    print(''.join(chars))\n\n    # partition the input data into a training and the test set\n    test_set_size = min(1000, int(len(words) * 0.1)) # 10% of the training set, or up to 1000 examples\n    rp = torch.randperm(len(words)).tolist()\n    train_words = [words[i] for i in rp[:-test_set_size]]\n    test_words = [words[i] for i in rp[-test_set_size:]]\n    print(f\"split up the dataset into {len(train_words)} training examples and {len(test_words)} test examples\")\n\n    # wrap in dataset objects\n    train_dataset = CharDataset(train_words, chars, max_word_length)\n    test_dataset = CharDataset(test_words, chars, max_word_length)\n\n    return train_dataset, test_dataset\n\n# -----------------------------------------------------------------------------\nif __name__ == '__main__':\n\n    # parse command line args\n    parser = argparse.ArgumentParser(description=\"Make More\")\n    # system/input/output\n    parser.add_argument('--input-file', '-i', type=str, default='names.txt', help=\"input file with things one per line\")\n    parser.add_argument('--work-dir', '-o', type=str, default='out', help=\"output working directory\")\n    parser.add_argument('--resume', action='store_true', help=\"when this flag is used, we will resume optimization from existing model in the workdir\")\n    parser.add_argument('--sample-only', action='store_true', help=\"just sample from the model and quit, don't train\")\n    parser.add_argument('--num-workers', '-n', type=int, default=0, help=\"number of data workers for both train/test\")\n    parser.add_argument('--device', type=str, default='cpu', help=\"device to use for compute, examples: cpu|cuda|cuda:2|mps\")\n    parser.add_argument('--seed', type=int, default=3407, help=\"seed\")\n    # sampling\n    parser.add_argument('--top-k', type=int, default=-1, help=\"top-k for sampling, -1 means no top-k\")\n    # model\n    parser.add_argument('--n-layer', type=int, default=4, help=\"number of layers in the transformer\")\n    parser.add_argument('--n-head', type=int, default=4, help=\"number of heads in the transformer\")\n    parser.add_argument('--n-embd', type=int, default=64, help=\"number of feature channels in the transformer\")\n    # optimization\n    parser.add_argument('--batch-size', '-b', type=int, default=32, help=\"batch size during optimization\")\n    parser.add_argument('--learning-rate', '-l', type=float, default=5e-4, help=\"learning rate\")\n    parser.add_argument('--weight-decay', '-w', type=float, default=0.01, help=\"weight decay\")\n    args = parser.parse_args()\n    print(vars(args))\n\n    # system inits\n    torch.manual_seed(args.seed)\n    torch.cuda.manual_seed_all(args.seed)\n    os.makedirs(args.work_dir, exist_ok=True)\n    writer = SummaryWriter(log_dir=args.work_dir)\n\n    # init datasets\n    train_dataset, test_dataset = create_datasets(args.input_file)\n    vocab_size = train_dataset.get_vocab_size()\n    block_size = train_dataset.get_output_length()\n    print(f\"dataset determined that: {vocab_size=}, {block_size=}\")\n\n    # init model\n    config = GPTConfig(vocab_size=vocab_size, block_size=block_size,\n                       n_layer=args.n_layer, n_head=args.n_head, n_embd=args.n_embd)\n    model = GPT(config)\n    model.to(args.device)\n    print(f\"model #params: {sum(p.numel() for p in model.parameters())}\")\n    if args.resume or args.sample_only: # note: if we sample-only then we also assume we're resuming\n        print(\"resuming from existing model in the workdir\")\n        model.load_state_dict(torch.load(os.path.join(args.work_dir, 'model.pt')))\n    if args.sample_only:\n        print_samples(num=50)\n        sys.exit()\n\n    # init optimizer\n    train_config = TrainConfig(learning_rate=args.learning_rate, weight_decay=args.weight_decay)\n    optimizer = model.configure_optimizers(train_config)\n\n    # init dataloader\n    train_sampler = torch.utils.data.RandomSampler(train_dataset, replacement=True, num_samples=int(1e10))\n    train_loader = DataLoader(train_dataset, batch_size=args.batch_size, pin_memory=True,\n                              num_workers=args.num_workers, sampler=train_sampler)\n    data_iter = iter(train_loader)\n\n    # training loop\n    best_loss = None\n    step = 0\n    while True:\n\n        t0 = time.time()\n        # fetch the next batch and reset dataloader every epoch as necessary\n        try:\n            batch = next(data_iter)\n        except StopIteration:\n            data_iter = iter(train_loader)\n            batch = next(data_iter)\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n\n        # feed into the model\n        logits, loss = model(X, Y)\n\n        # calculate the gradient, clip it, update the weights\n        model.zero_grad(set_to_none=True)\n        loss.backward()\n        torch.nn.utils.clip_grad_norm_(model.parameters(), 1.0)\n        optimizer.step()\n        if args.device.startswith('cuda'):\n            torch.cuda.synchronize()\n        t1 = time.time()\n\n        # logging\n        if step % 10 == 0:\n            print(f\"step {step} | loss {loss.item():.4f} | step time {(t1-t0)*1000:.2f}ms\")\n\n        # evaluate the model\n        if step > 0 and step % 500 == 0:\n            train_loss = evaluate(model, train_dataset, batch_size=100, max_batches=10)\n            test_loss  = evaluate(model, test_dataset,  batch_size=100, max_batches=10)\n            writer.add_scalar(\"Loss/train\", train_loss, step)\n            writer.add_scalar(\"Loss/test\", test_loss, step)\n            writer.flush()\n            print(f\"step {step} train loss: {train_loss} test loss: {test_loss}\")\n            # save the model to disk if it has improved\n            if best_loss is None or test_loss < best_loss:\n                out_path = os.path.join(args.work_dir, \"model.pt\")\n                print(f\"test loss {test_loss} is the best so far, saving model to {out_path}\")\n                torch.save(model.state_dict(), out_path)\n                best_loss = test_loss\n\n        # sample from the model\n        if step > 0 and step % 200 == 0:\n            print_samples(num=10)\n\n        step += 1\n", "diff": "@@ -411,7 +411,7 @@ def create_datasets(input_file):\n         loss.backward()\n         torch.nn.utils.clip_grad_norm_(model.parameters(), 1.0)\n         optimizer.step()\n-        if args.device == 'cuda':\n+        if args.device.startswith('cuda'):\n             torch.cuda.synchronize()\n         t1 = time.time()\n ", "status": "modified"}, {"commit_id": "013af92770a9749e3d77745e502b0124329ae238", "commit_message": "big refactor to make easier and api agree with mingpt more", "relative_path": "makemore.py", "previous_code_file": "\"\"\"\nyou give this script some words (one per line) and it will generate more things like it.\nuses super state of the art Transformer AI tech\nthis code is intended to be super hackable. tune it to your needs.\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport math\nimport argparse\nfrom dataclasses import dataclass\nfrom typing import List\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\nfrom torch.utils.data import Dataset\nfrom torch.utils.data.dataloader import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\n# -----------------------------------------------------------------------------\n# GPT (PyTorch) model definition\n\n@dataclass\nclass GPTConfig:\n    # size of the model\n    n_layer: int = 4\n    n_head: int = 4\n    n_embd: int = 64\n    vocab_size: int = None\n    block_size: int = None\n    # regularization\n    embd_pdrop: float = 0.1\n    resid_pdrop:float = 0.1\n    attn_pdrop:float = 0.1\n\n@dataclass\nclass TrainConfig:\n    # optimization parameters\n    learning_rate: float = 5e-4\n    weight_decay: float = 0.1 # only applied on matmul weights\n    betas: List[float] = (0.9, 0.99)\n\nclass CausalSelfAttention(nn.Module):\n    \"\"\"\n    A vanilla multi-head masked self-attention layer with a projection at the end.\n    It is possible to use torch.nn.MultiheadAttention here but I am including an\n    explicit implementation here to show that there is nothing too scary here.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.n_embd % config.n_head == 0\n        # key, query, value projections for all heads\n        self.key = nn.Linear(config.n_embd, config.n_embd)\n        self.query = nn.Linear(config.n_embd, config.n_embd)\n        self.value = nn.Linear(config.n_embd, config.n_embd)\n        # regularization\n        self.attn_drop = nn.Dropout(config.attn_pdrop)\n        self.resid_drop = nn.Dropout(config.resid_pdrop)\n        # output projection\n        self.proj = nn.Linear(config.n_embd, config.n_embd)\n        # causal mask to ensure that attention is only applied to the left in the input sequence\n        self.register_buffer(\"mask\", torch.tril(torch.ones(config.block_size, config.block_size))\n                                     .view(1, 1, config.block_size, config.block_size))\n        self.n_head = config.n_head\n\n    def forward(self, x):\n        B, T, C = x.size() # batch size, sequence length, embedding dimensionality (n_embd)\n\n        # calculate query, key, values for all heads in batch and move head forward to be the batch dim\n        k = self.key(x).view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        q = self.query(x).view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        v = self.value(x).view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n\n        # causal self-attention; Self-attend: (B, nh, T, hs) x (B, nh, hs, T) -> (B, nh, T, T)\n        att = (q @ k.transpose(-2, -1)) * (1.0 / math.sqrt(k.size(-1)))\n        att = att.masked_fill(self.mask[:,:,:T,:T] == 0, float('-inf'))\n        att = F.softmax(att, dim=-1)\n        att = self.attn_drop(att)\n        y = att @ v # (B, nh, T, T) x (B, nh, T, hs) -> (B, nh, T, hs)\n        y = y.transpose(1, 2).contiguous().view(B, T, C) # re-assemble all head outputs side by side\n\n        # output projection\n        y = self.resid_drop(self.proj(y))\n        return y\n\nclass Block(nn.Module):\n    \"\"\" an unassuming Transformer block \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.ln1 = nn.LayerNorm(config.n_embd)\n        self.ln2 = nn.LayerNorm(config.n_embd)\n        self.attn = CausalSelfAttention(config)\n        self.mlp = nn.Sequential(\n            nn.Linear(config.n_embd, 4 * config.n_embd),\n            nn.GELU(),\n            nn.Linear(4 * config.n_embd, config.n_embd),\n            nn.Dropout(config.resid_pdrop),\n        )\n\n    def forward(self, x):\n        x = x + self.attn(self.ln1(x))\n        x = x + self.mlp(self.ln2(x))\n        return x\n\nclass GPT(nn.Module):\n    \"\"\" the full GPT language model, with a context size of block_size \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n\n        # input embedding stem\n        self.tok_emb = nn.Embedding(config.vocab_size, config.n_embd)\n        self.pos_emb = nn.Parameter(torch.zeros(1, config.block_size, config.n_embd))\n        self.drop = nn.Dropout(config.embd_pdrop)\n        # transformer\n        self.blocks = nn.Sequential(*[Block(config) for _ in range(config.n_layer)])\n        # decoder head\n        self.ln_f = nn.LayerNorm(config.n_embd)\n        self.head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n\n        self.block_size = config.block_size\n        self.apply(self._init_weights)\n\n        print(\"number of parameters: %d\" % sum(p.numel() for p in self.parameters()))\n\n    def get_block_size(self):\n        return self.block_size\n\n    def _init_weights(self, module):\n        if isinstance(module, (nn.Linear, nn.Embedding)):\n            torch.nn.init.normal_(module.weight, mean=0.0, std=0.02)\n            if isinstance(module, nn.Linear) and module.bias is not None:\n                torch.nn.init.zeros_(module.bias)\n        elif isinstance(module, nn.LayerNorm):\n            torch.nn.init.zeros_(module.bias)\n            torch.nn.init.ones_(module.weight)\n        elif isinstance(module, GPT):\n            torch.nn.init.normal_(module.pos_emb, mean=0.0, std=0.02)\n\n    def configure_optimizers(self, train_config):\n        \"\"\"\n        This long function is unfortunately doing something very simple and is being very defensive:\n        We are separating out all parameters of the model into two buckets: those that will experience\n        weight decay for regularization and those that won't (biases, and layernorm/embedding weights).\n        We are then returning the PyTorch optimizer object.\n        \"\"\"\n\n        # separate out all parameters to those that will and won't experience regularizing weight decay\n        decay = set()\n        no_decay = set()\n        whitelist_weight_modules = (torch.nn.Linear, )\n        blacklist_weight_modules = (torch.nn.LayerNorm, torch.nn.Embedding)\n        for mn, m in self.named_modules():\n            for pn, p in m.named_parameters():\n                fpn = '%s.%s' % (mn, pn) if mn else pn # full param name\n\n                if pn.endswith('bias'):\n                    # all biases will not be decayed\n                    no_decay.add(fpn)\n                elif pn.endswith('weight') and isinstance(m, whitelist_weight_modules):\n                    # weights of whitelist modules will be weight decayed\n                    decay.add(fpn)\n                elif pn.endswith('weight') and isinstance(m, blacklist_weight_modules):\n                    # weights of blacklist modules will NOT be weight decayed\n                    no_decay.add(fpn)\n\n        # special case the position embedding parameter in the root GPT module as not decayed\n        no_decay.add('pos_emb')\n\n        # validate that we considered every parameter\n        param_dict = {pn: p for pn, p in self.named_parameters()}\n        inter_params = decay & no_decay\n        union_params = decay | no_decay\n        assert len(inter_params) == 0, \"parameters %s made it into both decay/no_decay sets!\" % (str(inter_params), )\n        assert len(param_dict.keys() - union_params) == 0, \"parameters %s were not separated into either decay/no_decay set!\" \\\n                                                    % (str(param_dict.keys() - union_params), )\n\n        # create the pytorch optimizer object\n        optim_groups = [\n            {\"params\": [param_dict[pn] for pn in sorted(list(decay))], \"weight_decay\": train_config.weight_decay},\n            {\"params\": [param_dict[pn] for pn in sorted(list(no_decay))], \"weight_decay\": 0.0},\n        ]\n        optimizer = torch.optim.AdamW(optim_groups, lr=train_config.learning_rate, betas=train_config.betas)\n        return optimizer\n\n    def forward(self, idx, targets=None):\n        b, t = idx.size()\n        assert t <= self.block_size, \"Cannot forward, input tensor sequence is longer than model block_size.\"\n\n        # forward the GPT model\n        token_embeddings = self.tok_emb(idx) # each index maps to a (learnable) vector\n        position_embeddings = self.pos_emb[:, :t, :] # each position maps to a (learnable) vector\n        x = self.drop(token_embeddings + position_embeddings)\n        x = self.blocks(x)\n        x = self.ln_f(x)\n        logits = self.head(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n# helper functions for evaluating and sampling from the model\n\ndef top_k_logits(logits, k):\n    \"\"\"\n    takes logits (N,D) and returns logits (N,D), but in each row only\n    the top-k are kept and the rest of the entries are set to -inf.\n    \"\"\"\n    v, ix = torch.topk(logits, k, dim=-1)\n    out = logits.clone()\n    out[out < v[:, [-1]]] = -float('Inf')\n    return out\n\n@torch.inference_mode()\ndef sample(model, x, steps, temperature=1.0, top_k=None):\n    \"\"\"\n    take a conditioning sequence of indices in x (b,t) and predict next tokens\n    in the sequence, feeding the predictions back into the model each step.\n    \"\"\"\n    block_size = model.get_block_size()\n    model.eval()\n    for k in range(steps):\n        # crop the context, if necessary\n        x_cond = x if x.size(1) <= block_size else x[:, -block_size:]\n        # feed the context into the model to get logits at each step\n        logits, _ = model(x_cond)\n        # pluck the logits at the final step and scale by temperature\n        logits = logits[:, -1, :] / temperature\n        # optionally crop probabilities to only the top k options\n        if top_k is not None:\n            logits = top_k_logits(logits, top_k)\n        # apply softmax to convert to probabilities\n        probs = F.softmax(logits, dim=-1)\n        # sample from the distribution or take the most likely\n        ix = torch.multinomial(probs, num_samples=1)\n        # append to the sequence and continue\n        x = torch.cat((x, ix), dim=1)\n    model.train()\n    return x\n\ndef print_samples(num=10):\n    \"\"\" samples from the model and pretty prints the decoded samples \"\"\"\n    X_init = torch.zeros(num, 1, dtype=torch.long).to(args.device)\n    top_k = args.top_k if args.top_k != -1 else None\n    steps = train_dataset.get_output_length() - 1 # -1 because we already start with <START> token (index 0)\n    X_samp = sample(model, X_init, steps, top_k=top_k).to('cpu')\n    train_samples, test_samples, new_samples = [], [], []\n    for i in range(X_samp.size(0)):\n        # get the i'th row of sampled integers, as python list\n        row = X_samp[i, 1:].tolist() # note: we need to crop out the first <START> token\n        # token 0 is the <STOP> token, so we crop the output sequence at that point\n        crop_index = row.index(0) if 0 in row else len(row)\n        row = row[:crop_index]\n        word_samp = train_dataset.decode(row)\n        # separately track samples that we have and have not seen before\n        if train_dataset.contains(word_samp):\n            train_samples.append(word_samp)\n        elif test_dataset.contains(word_samp):\n            test_samples.append(word_samp)\n        else:\n            new_samples.append(word_samp)\n    print('-'*80)\n    for lst, desc in [(train_samples, 'in train'), (test_samples, 'in test'), (new_samples, 'new')]:\n        print(f\"{len(lst)} samples that are {desc}:\")\n        for word in lst:\n            print(word)\n    print('-'*80)\n\n@torch.inference_mode()\ndef evaluate(model, dataset, batch_size=50, max_batches=None):\n    model.eval()\n    loader = DataLoader(dataset, shuffle=True, batch_size=batch_size, num_workers=0)\n    losses = []\n    for i, batch in enumerate(loader):\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n        logits, loss = model(X, Y)\n        losses.append(loss.item())\n        if max_batches is not None and i >= max_batches:\n            break\n    mean_loss = torch.tensor(losses).mean().item()\n    model.train() # reset model back to training mode\n    return mean_loss\n\n# -----------------------------------------------------------------------------\n# helper functions for creating the training and test Datasets that emit words\n\nclass CharDataset(Dataset):\n\n    def __init__(self, words, chars, max_word_length):\n        self.words = words\n        self.chars = chars\n        self.max_word_length = max_word_length\n        self.stoi = {ch:i+1 for i,ch in enumerate(chars)}\n        self.itos = {i:s for s,i in self.stoi.items()} # inverse mapping\n\n    def __len__(self):\n        return len(self.words)\n\n    def contains(self, word):\n        return word in self.words\n\n    def get_vocab_size(self):\n        return len(self.chars) + 1 # all the possible characters and special 0 token\n\n    def get_output_length(self):\n        return self.max_word_length + 1 # <START> token followed by words\n\n    def encode(self, word):\n        ix = torch.tensor([self.stoi[w] for w in word], dtype=torch.long)\n        return ix\n\n    def decode(self, ix):\n        word = ''.join(self.itos[i] for i in ix)\n        return word\n\n    def __getitem__(self, idx):\n        word = self.words[idx]\n        ix = self.encode(word)\n        x = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        y = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        x[1:1+len(ix)] = ix\n        y[:len(ix)] = ix\n        y[len(ix)+1:] = -1 # index -1 will mask the loss at the inactive locations\n        return x, y\n\ndef create_datasets(input_file):\n\n    # preprocessing of the input text file\n    with open(input_file, 'r') as f:\n        data = f.read()\n    words = data.splitlines()\n    words = [w.strip() for w in words] # get rid of any leading or trailing white space\n    words = [w for w in words if w] # get rid of any empty strings\n    chars = sorted(list(set(''.join(words)))) # all the possible characters\n    max_word_length = max(len(w) for w in words)\n    print(f\"number of examples in the dataset: {len(words)}\")\n    print(f\"max word length: {max_word_length}\")\n    print(f\"number of unique characters in the vocabulary: {len(chars)}\")\n    print(\"vocabulary:\")\n    print(''.join(chars))\n\n    # partition the input data into a training and the test set\n    test_set_size = min(1000, int(len(words) * 0.1)) # 10% of the training set, or up to 1000 examples\n    rp = torch.randperm(len(words)).tolist()\n    train_words = [words[i] for i in rp[:-test_set_size]]\n    test_words = [words[i] for i in rp[-test_set_size:]]\n    print(f\"split up the dataset into {len(train_words)} training examples and {len(test_words)} test examples\")\n\n    # wrap in dataset objects\n    train_dataset = CharDataset(train_words, chars, max_word_length)\n    test_dataset = CharDataset(test_words, chars, max_word_length)\n\n    return train_dataset, test_dataset\n\n# -----------------------------------------------------------------------------\nif __name__ == '__main__':\n\n    # parse command line args\n    parser = argparse.ArgumentParser(description=\"Make More\")\n    # system/input/output\n    parser.add_argument('--input-file', '-i', type=str, default='input.txt', help=\"input file with things one per line\")\n    parser.add_argument('--work-dir', '-o', type=str, default='out', help=\"output working directory\")\n    parser.add_argument('--resume', action='store_true', help=\"when this flag is used, we will resume optimization from existing model in the workdir\")\n    parser.add_argument('--num-workers', '-n', type=int, default=1, help=\"number of data workers for both train/test\")\n    parser.add_argument('--device', type=str, default='cpu', help=\"device to use for compute, e.g. cpu|cuda|mps\")\n    parser.add_argument('--seed', type=int, default=1337, help=\"seed\")\n    # sampling\n    parser.add_argument('--sample-only', action='store_true', help=\"just sample from the model and quit, don't train\")\n    parser.add_argument('--top-k', type=int, default=-1, help=\"top-k for sampling, -1 means no top-k\")\n    # model\n    parser.add_argument('--n-layer', type=int, default=4, help=\"number of layers in the transformer\")\n    parser.add_argument('--n-head', type=int, default=4, help=\"number of heads in the transformer\")\n    parser.add_argument('--n-embd', type=int, default=64, help=\"number of feature channels in the transformer\")\n    # optimization\n    parser.add_argument('--batch-size', '-b', type=int, default=32, help=\"batch size during optimization\")\n    parser.add_argument('--learning-rate', '-l', type=float, default=5e-4, help=\"learning rate\")\n    parser.add_argument('--dropout', '-d', type=float, default=0.1, help=\"dropout rate\")\n    parser.add_argument('--weight-decay', '-w', type=float, default=0.1, help=\"weight decay\")\n    args = parser.parse_args()\n    print(vars(args))\n\n    # system inits\n    torch.manual_seed(args.seed)\n    torch.cuda.manual_seed_all(args.seed)\n    torch.use_deterministic_algorithms(True)\n    os.makedirs(args.work_dir, exist_ok=True)\n    writer = SummaryWriter(log_dir=args.work_dir)\n\n    # init datasets\n    train_dataset, test_dataset = create_datasets(args.input_file)\n\n    # init model\n    config = GPTConfig(vocab_size=train_dataset.get_vocab_size(), block_size=train_dataset.get_output_length(),\n                       n_layer=args.n_layer, n_head=args.n_head, n_embd=args.n_embd,\n                       embd_pdrop=args.dropout, attn_pdrop=args.dropout, resid_pdrop=args.dropout)\n    model = GPT(config)\n    model.to(args.device)\n    print(f\"model #params: {sum(p.numel() for p in model.parameters())}\")\n    if args.resume or args.sample_only: # note: if we sample-only then we also assume we're resuming\n        print(\"resuming from existing model in the workdir\")\n        model.load_state_dict(torch.load(os.path.join(args.work_dir, 'model.pt')))\n    if args.sample_only:\n        print_samples(num=50)\n        sys.exit()\n\n    # init optimizer\n    train_config = TrainConfig(learning_rate=args.learning_rate, weight_decay=args.weight_decay)\n    optimizer = model.configure_optimizers(train_config)\n\n    # init dataloader\n    train_sampler = torch.utils.data.RandomSampler(train_dataset, replacement=True, num_samples=int(1e10))\n    train_loader = DataLoader(train_dataset, batch_size=args.batch_size, pin_memory=True,\n                              num_workers=args.num_workers, sampler=train_sampler)\n    data_iter = iter(train_loader)\n\n    # training loop\n    best_loss = None\n    step = 0\n    while True:\n\n        t0 = time.time()\n        # fetch the next batch and reset dataloader every epoch as necessary\n        try:\n            batch = next(data_iter)\n        except StopIteration:\n            data_iter = iter(train_loader)\n            batch = next(data_iter)\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n\n        # feed into the model\n        logits, loss = model(X, Y)\n\n        # calculate the gradient, clip it, update the weights\n        model.zero_grad(set_to_none=True)\n        loss.backward()\n        torch.nn.utils.clip_grad_norm_(model.parameters(), 1.0)\n        optimizer.step()\n        if args.device == 'cuda':\n            torch.cuda.synchronize()\n        t1 = time.time()\n\n        # logging\n        if step % 10 == 0:\n            print(f\"step {step} | loss {loss.item():.4f} | step time {(t1-t0)*1000:.2f}ms\")\n\n        # evaluate the model\n        if step > 0 and step % 500 == 0:\n            train_loss = evaluate(model, train_dataset, batch_size=100, max_batches=10)\n            test_loss  = evaluate(model, test_dataset,  batch_size=100, max_batches=10)\n            writer.add_scalar(\"Loss/train\", train_loss, step)\n            writer.add_scalar(\"Loss/test\", test_loss, step)\n            writer.flush()\n            print(f\"step {step} train loss: {train_loss} test loss: {test_loss}\")\n            # save the model to disk if it has improved\n            if best_loss is None or test_loss < best_loss:\n                out_path = os.path.join(args.work_dir, \"model.pt\")\n                print(f\"test loss {test_loss} is the best so far, saving model to {out_path}\")\n                torch.save(model.state_dict(), out_path)\n                best_loss = test_loss\n\n        # sample from the model\n        if step > 0 and step % 200 == 0:\n            print_samples(num=10)\n\n        step += 1\n", "previous_id": "054568ec24729808317466148e8e8c62c502bedb", "new_code_file": "\"\"\"\nyou give this script some words (one per line) and it will generate more things like it.\nuses super state of the art Transformer AI tech\nthis code is intended to be super hackable. tune it to your needs.\n\nChanges from minGPT:\n- I removed the from_pretrained function where we init with GPT2 weights\n- I removed dropout layers because the models we train here are small,\n  it's not necessary to understand at this stage and at this scale.\n- I removed weight decay and all of the complexity around what parameters are\n  and are not weight decayed. I don't believe this should make a massive\n  difference at the scale that we operate on here.\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport math\nimport argparse\nfrom dataclasses import dataclass\nfrom typing import List\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\nfrom torch.utils.data import Dataset\nfrom torch.utils.data.dataloader import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\n# -----------------------------------------------------------------------------\n# GPT model definition\n\n@dataclass\nclass GPTConfig:\n    # size of the model\n    n_layer: int = 4\n    n_head: int = 4\n    n_embd: int = 64\n    vocab_size: int = None\n    block_size: int = None\n\n@dataclass\nclass TrainConfig:\n    # optimization parameters\n    learning_rate: float = 5e-4\n    betas: List[float] = (0.9, 0.99)\n    weight_decay: float = 0.01\n\nclass NewGELU(nn.Module):\n    \"\"\"\n    Implementation of the GELU activation function currently in Google BERT repo (identical to OpenAI GPT).\n    Reference: Gaussian Error Linear Units (GELU) paper: https://arxiv.org/abs/1606.08415\n    \"\"\"\n    def forward(self, x):\n        return 0.5 * x * (1.0 + torch.tanh(math.sqrt(2.0 / math.pi) * (x + 0.044715 * torch.pow(x, 3.0))))\n\nclass CausalSelfAttention(nn.Module):\n    \"\"\"\n    A vanilla multi-head masked self-attention layer with a projection at the end.\n    It is possible to use torch.nn.MultiheadAttention here but I am including an\n    explicit implementation here to show that there is nothing too scary here.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.n_embd % config.n_head == 0\n        # key, query, value projections for all heads, but in a batch\n        self.c_attn = nn.Linear(config.n_embd, 3 * config.n_embd)\n        # output projection\n        self.c_proj = nn.Linear(config.n_embd, config.n_embd)\n        # causal mask to ensure that attention is only applied to the left in the input sequence\n        self.register_buffer(\"bias\", torch.tril(torch.ones(config.block_size, config.block_size))\n                                     .view(1, 1, config.block_size, config.block_size))\n        self.n_head = config.n_head\n        self.n_embd = config.n_embd\n\n    def forward(self, x):\n        B, T, C = x.size() # batch size, sequence length, embedding dimensionality (n_embd)\n\n        # calculate query, key, values for all heads in batch and move head forward to be the batch dim\n        q, k ,v  = self.c_attn(x).split(self.n_embd, dim=2)\n        k = k.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        q = q.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        v = v.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n\n        # causal self-attention; Self-attend: (B, nh, T, hs) x (B, nh, hs, T) -> (B, nh, T, T)\n        att = (q @ k.transpose(-2, -1)) * (1.0 / math.sqrt(k.size(-1)))\n        att = att.masked_fill(self.bias[:,:,:T,:T] == 0, float('-inf'))\n        att = F.softmax(att, dim=-1)\n        y = att @ v # (B, nh, T, T) x (B, nh, T, hs) -> (B, nh, T, hs)\n        y = y.transpose(1, 2).contiguous().view(B, T, C) # re-assemble all head outputs side by side\n\n        # output projection\n        y = self.c_proj(y)\n        return y\n\nclass Block(nn.Module):\n    \"\"\" an unassuming Transformer block \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.ln_1 = nn.LayerNorm(config.n_embd)\n        self.attn = CausalSelfAttention(config)\n        self.ln_2 = nn.LayerNorm(config.n_embd)\n        self.mlp = nn.ModuleDict(dict(\n            c_fc    = nn.Linear(config.n_embd, 4 * config.n_embd),\n            c_proj  = nn.Linear(4 * config.n_embd, config.n_embd),\n            act     = NewGELU(),\n        ))\n        m = self.mlp\n        self.mlpf = lambda x: m.c_proj(m.act(m.c_fc(x))) # MLP forward\n\n    def forward(self, x):\n        x = x + self.attn(self.ln_1(x))\n        x = x + self.mlpf(self.ln_2(x))\n        return x\n\nclass GPT(nn.Module):\n    \"\"\" GPT Language Model \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.vocab_size is not None\n        assert config.block_size is not None\n        self.block_size = config.block_size\n\n        self.transformer = nn.ModuleDict(dict(\n            wte = nn.Embedding(config.vocab_size, config.n_embd),\n            wpe = nn.Embedding(config.block_size, config.n_embd),\n            h = nn.ModuleList([Block(config) for _ in range(config.n_layer)]),\n            ln_f = nn.LayerNorm(config.n_embd),\n        ))\n        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n\n        # init all weights\n        self.apply(self._init_weights)\n\n        # report number of parameters (note we don't count the decoder parameters in lm_head)\n        n_params = sum(p.numel() for p in self.transformer.parameters())\n        print(\"number of parameters: %.2fM\" % (n_params/1e6,))\n\n    def _init_weights(self, module):\n        # TODO is this function needed?\n        if isinstance(module, nn.Linear):\n            torch.nn.init.normal_(module.weight, mean=0.0, std=0.02)\n            if module.bias is not None:\n                torch.nn.init.zeros_(module.bias)\n        elif isinstance(module, nn.Embedding):\n            torch.nn.init.normal_(module.weight, mean=0.0, std=0.02)\n        elif isinstance(module, nn.LayerNorm):\n            torch.nn.init.zeros_(module.bias)\n            torch.nn.init.ones_(module.weight)\n\n    def configure_optimizers(self, train_config):\n        optimizer = torch.optim.AdamW(self.parameters(), lr=train_config.learning_rate,\n                                      betas=train_config.betas, weight_decay=train_config.weight_decay,\n                                      eps=1e-8)\n        return optimizer\n\n    def forward(self, idx, targets=None):\n        device = idx.device\n        b, t = idx.size()\n        assert t <= self.block_size, f\"Cannot forward sequence of length {t}, block size is only {self.block_size}\"\n        pos = torch.arange(0, t, dtype=torch.long, device=device).unsqueeze(0) # shape (1, t)\n\n        # forward the GPT model itself\n        tok_emb = self.transformer.wte(idx) # token embeddings of shape (b, t, n_embd)\n        pos_emb = self.transformer.wpe(pos) # position embeddings of shape (1, t, n_embd)\n        x = tok_emb + pos_emb\n        for block in self.transformer.h:\n            x = block(x)\n        x = self.transformer.ln_f(x)\n        logits = self.lm_head(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n    @torch.no_grad()\n    def generate(self, idx, max_new_tokens, temperature=1.0, do_sample=False, top_k=None):\n        \"\"\"\n        Take a conditioning sequence of indices idx (LongTensor of shape (b,t)) and complete\n        the sequence max_new_tokens times, feeding the predictions back into the model each time.\n        Most likely you'll want to make sure to be in model.eval() mode of operation for this.\n        \"\"\"\n        for _ in range(max_new_tokens):\n            # if the sequence context is growing too long we must crop it at block_size\n            idx_cond = idx if idx.size(1) <= self.block_size else idx[:, -self.block_size:]\n            # forward the model to get the logits for the index in the sequence\n            logits, _ = self(idx_cond)\n            # pluck the logits at the final step and scale by desired temperature\n            logits = logits[:, -1, :] / temperature\n            # optionally crop the logits to only the top k options\n            if top_k is not None:\n                v, _ = torch.topk(logits, top_k)\n                logits[logits < v[:, [-1]]] = -float('Inf')\n            # apply softmax to convert logits to (normalized) probabilities\n            probs = F.softmax(logits, dim=-1)\n            # either sample from the distribution or take the most likely element\n            if do_sample:\n                idx_next = torch.multinomial(probs, num_samples=1)\n            else:\n                _, idx_next = torch.topk(probs, k=1, dim=-1)\n            # append sampled index to the running sequence and continue\n            idx = torch.cat((idx, idx_next), dim=1)\n\n        return idx\n\n# -----------------------------------------------------------------------------\n# helper functions for evaluating and sampling from the model\n\ndef print_samples(num=10):\n    \"\"\" samples from the model and pretty prints the decoded samples \"\"\"\n    X_init = torch.zeros(num, 1, dtype=torch.long).to(args.device)\n    top_k = args.top_k if args.top_k != -1 else None\n    steps = train_dataset.get_output_length() - 1 # -1 because we already start with <START> token (index 0)\n    X_samp = model.generate(X_init, steps, top_k=top_k, do_sample=True).to('cpu')\n    train_samples, test_samples, new_samples = [], [], []\n    for i in range(X_samp.size(0)):\n        # get the i'th row of sampled integers, as python list\n        row = X_samp[i, 1:].tolist() # note: we need to crop out the first <START> token\n        # token 0 is the <STOP> token, so we crop the output sequence at that point\n        crop_index = row.index(0) if 0 in row else len(row)\n        row = row[:crop_index]\n        word_samp = train_dataset.decode(row)\n        # separately track samples that we have and have not seen before\n        if train_dataset.contains(word_samp):\n            train_samples.append(word_samp)\n        elif test_dataset.contains(word_samp):\n            test_samples.append(word_samp)\n        else:\n            new_samples.append(word_samp)\n    print('-'*80)\n    for lst, desc in [(train_samples, 'in train'), (test_samples, 'in test'), (new_samples, 'new')]:\n        print(f\"{len(lst)} samples that are {desc}:\")\n        for word in lst:\n            print(word)\n    print('-'*80)\n\n@torch.inference_mode()\ndef evaluate(model, dataset, batch_size=50, max_batches=None):\n    model.eval()\n    loader = DataLoader(dataset, shuffle=True, batch_size=batch_size, num_workers=0)\n    losses = []\n    for i, batch in enumerate(loader):\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n        logits, loss = model(X, Y)\n        losses.append(loss.item())\n        if max_batches is not None and i >= max_batches:\n            break\n    mean_loss = torch.tensor(losses).mean().item()\n    model.train() # reset model back to training mode\n    return mean_loss\n\n# -----------------------------------------------------------------------------\n# helper functions for creating the training and test Datasets that emit words\n\nclass CharDataset(Dataset):\n\n    def __init__(self, words, chars, max_word_length):\n        self.words = words\n        self.chars = chars\n        self.max_word_length = max_word_length\n        self.stoi = {ch:i+1 for i,ch in enumerate(chars)}\n        self.itos = {i:s for s,i in self.stoi.items()} # inverse mapping\n\n    def __len__(self):\n        return len(self.words)\n\n    def contains(self, word):\n        return word in self.words\n\n    def get_vocab_size(self):\n        return len(self.chars) + 1 # all the possible characters and special 0 token\n\n    def get_output_length(self):\n        return self.max_word_length + 1 # <START> token followed by words\n\n    def encode(self, word):\n        ix = torch.tensor([self.stoi[w] for w in word], dtype=torch.long)\n        return ix\n\n    def decode(self, ix):\n        word = ''.join(self.itos[i] for i in ix)\n        return word\n\n    def __getitem__(self, idx):\n        word = self.words[idx]\n        ix = self.encode(word)\n        x = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        y = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        x[1:1+len(ix)] = ix\n        y[:len(ix)] = ix\n        y[len(ix)+1:] = -1 # index -1 will mask the loss at the inactive locations\n        return x, y\n\ndef create_datasets(input_file):\n\n    # preprocessing of the input text file\n    with open(input_file, 'r') as f:\n        data = f.read()\n    words = data.splitlines()\n    words = [w.strip() for w in words] # get rid of any leading or trailing white space\n    words = [w for w in words if w] # get rid of any empty strings\n    chars = sorted(list(set(''.join(words)))) # all the possible characters\n    max_word_length = max(len(w) for w in words)\n    print(f\"number of examples in the dataset: {len(words)}\")\n    print(f\"max word length: {max_word_length}\")\n    print(f\"number of unique characters in the vocabulary: {len(chars)}\")\n    print(\"vocabulary:\")\n    print(''.join(chars))\n\n    # partition the input data into a training and the test set\n    test_set_size = min(1000, int(len(words) * 0.1)) # 10% of the training set, or up to 1000 examples\n    rp = torch.randperm(len(words)).tolist()\n    train_words = [words[i] for i in rp[:-test_set_size]]\n    test_words = [words[i] for i in rp[-test_set_size:]]\n    print(f\"split up the dataset into {len(train_words)} training examples and {len(test_words)} test examples\")\n\n    # wrap in dataset objects\n    train_dataset = CharDataset(train_words, chars, max_word_length)\n    test_dataset = CharDataset(test_words, chars, max_word_length)\n\n    return train_dataset, test_dataset\n\n# -----------------------------------------------------------------------------\nif __name__ == '__main__':\n\n    # parse command line args\n    parser = argparse.ArgumentParser(description=\"Make More\")\n    # system/input/output\n    parser.add_argument('--input-file', '-i', type=str, default='names.txt', help=\"input file with things one per line\")\n    parser.add_argument('--work-dir', '-o', type=str, default='out', help=\"output working directory\")\n    parser.add_argument('--resume', action='store_true', help=\"when this flag is used, we will resume optimization from existing model in the workdir\")\n    parser.add_argument('--sample-only', action='store_true', help=\"just sample from the model and quit, don't train\")\n    parser.add_argument('--num-workers', '-n', type=int, default=0, help=\"number of data workers for both train/test\")\n    parser.add_argument('--device', type=str, default='cpu', help=\"device to use for compute, examples: cpu|cuda|cuda:2|mps\")\n    parser.add_argument('--seed', type=int, default=3407, help=\"seed\")\n    # sampling\n    parser.add_argument('--top-k', type=int, default=-1, help=\"top-k for sampling, -1 means no top-k\")\n    # model\n    parser.add_argument('--n-layer', type=int, default=4, help=\"number of layers in the transformer\")\n    parser.add_argument('--n-head', type=int, default=4, help=\"number of heads in the transformer\")\n    parser.add_argument('--n-embd', type=int, default=64, help=\"number of feature channels in the transformer\")\n    # optimization\n    parser.add_argument('--batch-size', '-b', type=int, default=32, help=\"batch size during optimization\")\n    parser.add_argument('--learning-rate', '-l', type=float, default=5e-4, help=\"learning rate\")\n    parser.add_argument('--weight-decay', '-w', type=float, default=0.01, help=\"weight decay\")\n    args = parser.parse_args()\n    print(vars(args))\n\n    # system inits\n    torch.manual_seed(args.seed)\n    torch.cuda.manual_seed_all(args.seed)\n    os.makedirs(args.work_dir, exist_ok=True)\n    writer = SummaryWriter(log_dir=args.work_dir)\n\n    # init datasets\n    train_dataset, test_dataset = create_datasets(args.input_file)\n    vocab_size = train_dataset.get_vocab_size()\n    block_size = train_dataset.get_output_length()\n    print(f\"dataset determined that: {vocab_size=}, {block_size=}\")\n\n    # init model\n    config = GPTConfig(vocab_size=vocab_size, block_size=block_size,\n                       n_layer=args.n_layer, n_head=args.n_head, n_embd=args.n_embd)\n    model = GPT(config)\n    model.to(args.device)\n    print(f\"model #params: {sum(p.numel() for p in model.parameters())}\")\n    if args.resume or args.sample_only: # note: if we sample-only then we also assume we're resuming\n        print(\"resuming from existing model in the workdir\")\n        model.load_state_dict(torch.load(os.path.join(args.work_dir, 'model.pt')))\n    if args.sample_only:\n        print_samples(num=50)\n        sys.exit()\n\n    # init optimizer\n    train_config = TrainConfig(learning_rate=args.learning_rate, weight_decay=args.weight_decay)\n    optimizer = model.configure_optimizers(train_config)\n\n    # init dataloader\n    train_sampler = torch.utils.data.RandomSampler(train_dataset, replacement=True, num_samples=int(1e10))\n    train_loader = DataLoader(train_dataset, batch_size=args.batch_size, pin_memory=True,\n                              num_workers=args.num_workers, sampler=train_sampler)\n    data_iter = iter(train_loader)\n\n    # training loop\n    best_loss = None\n    step = 0\n    while True:\n\n        t0 = time.time()\n        # fetch the next batch and reset dataloader every epoch as necessary\n        try:\n            batch = next(data_iter)\n        except StopIteration:\n            data_iter = iter(train_loader)\n            batch = next(data_iter)\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n\n        # feed into the model\n        logits, loss = model(X, Y)\n\n        # calculate the gradient, clip it, update the weights\n        model.zero_grad(set_to_none=True)\n        loss.backward()\n        torch.nn.utils.clip_grad_norm_(model.parameters(), 1.0)\n        optimizer.step()\n        if args.device == 'cuda':\n            torch.cuda.synchronize()\n        t1 = time.time()\n\n        # logging\n        if step % 10 == 0:\n            print(f\"step {step} | loss {loss.item():.4f} | step time {(t1-t0)*1000:.2f}ms\")\n\n        # evaluate the model\n        if step > 0 and step % 500 == 0:\n            train_loss = evaluate(model, train_dataset, batch_size=100, max_batches=10)\n            test_loss  = evaluate(model, test_dataset,  batch_size=100, max_batches=10)\n            writer.add_scalar(\"Loss/train\", train_loss, step)\n            writer.add_scalar(\"Loss/test\", test_loss, step)\n            writer.flush()\n            print(f\"step {step} train loss: {train_loss} test loss: {test_loss}\")\n            # save the model to disk if it has improved\n            if best_loss is None or test_loss < best_loss:\n                out_path = os.path.join(args.work_dir, \"model.pt\")\n                print(f\"test loss {test_loss} is the best so far, saving model to {out_path}\")\n                torch.save(model.state_dict(), out_path)\n                best_loss = test_loss\n\n        # sample from the model\n        if step > 0 and step % 200 == 0:\n            print_samples(num=10)\n\n        step += 1\n", "diff": "@@ -2,6 +2,14 @@\n you give this script some words (one per line) and it will generate more things like it.\n uses super state of the art Transformer AI tech\n this code is intended to be super hackable. tune it to your needs.\n+\n+Changes from minGPT:\n+- I removed the from_pretrained function where we init with GPT2 weights\n+- I removed dropout layers because the models we train here are small,\n+  it's not necessary to understand at this stage and at this scale.\n+- I removed weight decay and all of the complexity around what parameters are\n+  and are not weight decayed. I don't believe this should make a massive\n+  difference at the scale that we operate on here.\n \"\"\"\n \n import os\n@@ -20,7 +28,7 @@\n from torch.utils.tensorboard import SummaryWriter\n \n # -----------------------------------------------------------------------------\n-# GPT (PyTorch) model definition\n+# GPT model definition\n \n @dataclass\n class GPTConfig:\n@@ -30,17 +38,21 @@ class GPTConfig:\n     n_embd: int = 64\n     vocab_size: int = None\n     block_size: int = None\n-    # regularization\n-    embd_pdrop: float = 0.1\n-    resid_pdrop:float = 0.1\n-    attn_pdrop:float = 0.1\n \n @dataclass\n class TrainConfig:\n     # optimization parameters\n     learning_rate: float = 5e-4\n-    weight_decay: float = 0.1 # only applied on matmul weights\n     betas: List[float] = (0.9, 0.99)\n+    weight_decay: float = 0.01\n+\n+class NewGELU(nn.Module):\n+    \"\"\"\n+    Implementation of the GELU activation function currently in Google BERT repo (identical to OpenAI GPT).\n+    Reference: Gaussian Error Linear Units (GELU) paper: https://arxiv.org/abs/1606.08415\n+    \"\"\"\n+    def forward(self, x):\n+        return 0.5 * x * (1.0 + torch.tanh(math.sqrt(2.0 / math.pi) * (x + 0.044715 * torch.pow(x, 3.0))))\n \n class CausalSelfAttention(nn.Module):\n     \"\"\"\n@@ -52,152 +64,113 @@ class CausalSelfAttention(nn.Module):\n     def __init__(self, config):\n         super().__init__()\n         assert config.n_embd % config.n_head == 0\n-        # key, query, value projections for all heads\n-        self.key = nn.Linear(config.n_embd, config.n_embd)\n-        self.query = nn.Linear(config.n_embd, config.n_embd)\n-        self.value = nn.Linear(config.n_embd, config.n_embd)\n-        # regularization\n-        self.attn_drop = nn.Dropout(config.attn_pdrop)\n-        self.resid_drop = nn.Dropout(config.resid_pdrop)\n+        # key, query, value projections for all heads, but in a batch\n+        self.c_attn = nn.Linear(config.n_embd, 3 * config.n_embd)\n         # output projection\n-        self.proj = nn.Linear(config.n_embd, config.n_embd)\n+        self.c_proj = nn.Linear(config.n_embd, config.n_embd)\n         # causal mask to ensure that attention is only applied to the left in the input sequence\n-        self.register_buffer(\"mask\", torch.tril(torch.ones(config.block_size, config.block_size))\n+        self.register_buffer(\"bias\", torch.tril(torch.ones(config.block_size, config.block_size))\n                                      .view(1, 1, config.block_size, config.block_size))\n         self.n_head = config.n_head\n+        self.n_embd = config.n_embd\n \n     def forward(self, x):\n         B, T, C = x.size() # batch size, sequence length, embedding dimensionality (n_embd)\n \n         # calculate query, key, values for all heads in batch and move head forward to be the batch dim\n-        k = self.key(x).view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n-        q = self.query(x).view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n-        v = self.value(x).view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n+        q, k ,v  = self.c_attn(x).split(self.n_embd, dim=2)\n+        k = k.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n+        q = q.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n+        v = v.view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n \n         # causal self-attention; Self-attend: (B, nh, T, hs) x (B, nh, hs, T) -> (B, nh, T, T)\n         att = (q @ k.transpose(-2, -1)) * (1.0 / math.sqrt(k.size(-1)))\n-        att = att.masked_fill(self.mask[:,:,:T,:T] == 0, float('-inf'))\n+        att = att.masked_fill(self.bias[:,:,:T,:T] == 0, float('-inf'))\n         att = F.softmax(att, dim=-1)\n-        att = self.attn_drop(att)\n         y = att @ v # (B, nh, T, T) x (B, nh, T, hs) -> (B, nh, T, hs)\n         y = y.transpose(1, 2).contiguous().view(B, T, C) # re-assemble all head outputs side by side\n \n         # output projection\n-        y = self.resid_drop(self.proj(y))\n+        y = self.c_proj(y)\n         return y\n \n class Block(nn.Module):\n     \"\"\" an unassuming Transformer block \"\"\"\n \n     def __init__(self, config):\n         super().__init__()\n-        self.ln1 = nn.LayerNorm(config.n_embd)\n-        self.ln2 = nn.LayerNorm(config.n_embd)\n+        self.ln_1 = nn.LayerNorm(config.n_embd)\n         self.attn = CausalSelfAttention(config)\n-        self.mlp = nn.Sequential(\n-            nn.Linear(config.n_embd, 4 * config.n_embd),\n-            nn.GELU(),\n-            nn.Linear(4 * config.n_embd, config.n_embd),\n-            nn.Dropout(config.resid_pdrop),\n-        )\n+        self.ln_2 = nn.LayerNorm(config.n_embd)\n+        self.mlp = nn.ModuleDict(dict(\n+            c_fc    = nn.Linear(config.n_embd, 4 * config.n_embd),\n+            c_proj  = nn.Linear(4 * config.n_embd, config.n_embd),\n+            act     = NewGELU(),\n+        ))\n+        m = self.mlp\n+        self.mlpf = lambda x: m.c_proj(m.act(m.c_fc(x))) # MLP forward\n \n     def forward(self, x):\n-        x = x + self.attn(self.ln1(x))\n-        x = x + self.mlp(self.ln2(x))\n+        x = x + self.attn(self.ln_1(x))\n+        x = x + self.mlpf(self.ln_2(x))\n         return x\n \n class GPT(nn.Module):\n-    \"\"\" the full GPT language model, with a context size of block_size \"\"\"\n+    \"\"\" GPT Language Model \"\"\"\n \n     def __init__(self, config):\n         super().__init__()\n+        assert config.vocab_size is not None\n+        assert config.block_size is not None\n+        self.block_size = config.block_size\n \n-        # input embedding stem\n-        self.tok_emb = nn.Embedding(config.vocab_size, config.n_embd)\n-        self.pos_emb = nn.Parameter(torch.zeros(1, config.block_size, config.n_embd))\n-        self.drop = nn.Dropout(config.embd_pdrop)\n-        # transformer\n-        self.blocks = nn.Sequential(*[Block(config) for _ in range(config.n_layer)])\n-        # decoder head\n-        self.ln_f = nn.LayerNorm(config.n_embd)\n-        self.head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n+        self.transformer = nn.ModuleDict(dict(\n+            wte = nn.Embedding(config.vocab_size, config.n_embd),\n+            wpe = nn.Embedding(config.block_size, config.n_embd),\n+            h = nn.ModuleList([Block(config) for _ in range(config.n_layer)]),\n+            ln_f = nn.LayerNorm(config.n_embd),\n+        ))\n+        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n \n-        self.block_size = config.block_size\n+        # init all weights\n         self.apply(self._init_weights)\n \n-        print(\"number of parameters: %d\" % sum(p.numel() for p in self.parameters()))\n-\n-    def get_block_size(self):\n-        return self.block_size\n+        # report number of parameters (note we don't count the decoder parameters in lm_head)\n+        n_params = sum(p.numel() for p in self.transformer.parameters())\n+        print(\"number of parameters: %.2fM\" % (n_params/1e6,))\n \n     def _init_weights(self, module):\n-        if isinstance(module, (nn.Linear, nn.Embedding)):\n+        # TODO is this function needed?\n+        if isinstance(module, nn.Linear):\n             torch.nn.init.normal_(module.weight, mean=0.0, std=0.02)\n-            if isinstance(module, nn.Linear) and module.bias is not None:\n+            if module.bias is not None:\n                 torch.nn.init.zeros_(module.bias)\n+        elif isinstance(module, nn.Embedding):\n+            torch.nn.init.normal_(module.weight, mean=0.0, std=0.02)\n         elif isinstance(module, nn.LayerNorm):\n             torch.nn.init.zeros_(module.bias)\n             torch.nn.init.ones_(module.weight)\n-        elif isinstance(module, GPT):\n-            torch.nn.init.normal_(module.pos_emb, mean=0.0, std=0.02)\n \n     def configure_optimizers(self, train_config):\n-        \"\"\"\n-        This long function is unfortunately doing something very simple and is being very defensive:\n-        We are separating out all parameters of the model into two buckets: those that will experience\n-        weight decay for regularization and those that won't (biases, and layernorm/embedding weights).\n-        We are then returning the PyTorch optimizer object.\n-        \"\"\"\n-\n-        # separate out all parameters to those that will and won't experience regularizing weight decay\n-        decay = set()\n-        no_decay = set()\n-        whitelist_weight_modules = (torch.nn.Linear, )\n-        blacklist_weight_modules = (torch.nn.LayerNorm, torch.nn.Embedding)\n-        for mn, m in self.named_modules():\n-            for pn, p in m.named_parameters():\n-                fpn = '%s.%s' % (mn, pn) if mn else pn # full param name\n-\n-                if pn.endswith('bias'):\n-                    # all biases will not be decayed\n-                    no_decay.add(fpn)\n-                elif pn.endswith('weight') and isinstance(m, whitelist_weight_modules):\n-                    # weights of whitelist modules will be weight decayed\n-                    decay.add(fpn)\n-                elif pn.endswith('weight') and isinstance(m, blacklist_weight_modules):\n-                    # weights of blacklist modules will NOT be weight decayed\n-                    no_decay.add(fpn)\n-\n-        # special case the position embedding parameter in the root GPT module as not decayed\n-        no_decay.add('pos_emb')\n-\n-        # validate that we considered every parameter\n-        param_dict = {pn: p for pn, p in self.named_parameters()}\n-        inter_params = decay & no_decay\n-        union_params = decay | no_decay\n-        assert len(inter_params) == 0, \"parameters %s made it into both decay/no_decay sets!\" % (str(inter_params), )\n-        assert len(param_dict.keys() - union_params) == 0, \"parameters %s were not separated into either decay/no_decay set!\" \\\n-                                                    % (str(param_dict.keys() - union_params), )\n-\n-        # create the pytorch optimizer object\n-        optim_groups = [\n-            {\"params\": [param_dict[pn] for pn in sorted(list(decay))], \"weight_decay\": train_config.weight_decay},\n-            {\"params\": [param_dict[pn] for pn in sorted(list(no_decay))], \"weight_decay\": 0.0},\n-        ]\n-        optimizer = torch.optim.AdamW(optim_groups, lr=train_config.learning_rate, betas=train_config.betas)\n+        optimizer = torch.optim.AdamW(self.parameters(), lr=train_config.learning_rate,\n+                                      betas=train_config.betas, weight_decay=train_config.weight_decay,\n+                                      eps=1e-8)\n         return optimizer\n \n     def forward(self, idx, targets=None):\n+        device = idx.device\n         b, t = idx.size()\n-        assert t <= self.block_size, \"Cannot forward, input tensor sequence is longer than model block_size.\"\n-\n-        # forward the GPT model\n-        token_embeddings = self.tok_emb(idx) # each index maps to a (learnable) vector\n-        position_embeddings = self.pos_emb[:, :t, :] # each position maps to a (learnable) vector\n-        x = self.drop(token_embeddings + position_embeddings)\n-        x = self.blocks(x)\n-        x = self.ln_f(x)\n-        logits = self.head(x)\n+        assert t <= self.block_size, f\"Cannot forward sequence of length {t}, block size is only {self.block_size}\"\n+        pos = torch.arange(0, t, dtype=torch.long, device=device).unsqueeze(0) # shape (1, t)\n+\n+        # forward the GPT model itself\n+        tok_emb = self.transformer.wte(idx) # token embeddings of shape (b, t, n_embd)\n+        pos_emb = self.transformer.wpe(pos) # position embeddings of shape (1, t, n_embd)\n+        x = tok_emb + pos_emb\n+        for block in self.transformer.h:\n+            x = block(x)\n+        x = self.transformer.ln_f(x)\n+        logits = self.lm_head(x)\n \n         # if we are given some desired targets also calculate the loss\n         loss = None\n@@ -206,52 +179,45 @@ def forward(self, idx, targets=None):\n \n         return logits, loss\n \n+    @torch.no_grad()\n+    def generate(self, idx, max_new_tokens, temperature=1.0, do_sample=False, top_k=None):\n+        \"\"\"\n+        Take a conditioning sequence of indices idx (LongTensor of shape (b,t)) and complete\n+        the sequence max_new_tokens times, feeding the predictions back into the model each time.\n+        Most likely you'll want to make sure to be in model.eval() mode of operation for this.\n+        \"\"\"\n+        for _ in range(max_new_tokens):\n+            # if the sequence context is growing too long we must crop it at block_size\n+            idx_cond = idx if idx.size(1) <= self.block_size else idx[:, -self.block_size:]\n+            # forward the model to get the logits for the index in the sequence\n+            logits, _ = self(idx_cond)\n+            # pluck the logits at the final step and scale by desired temperature\n+            logits = logits[:, -1, :] / temperature\n+            # optionally crop the logits to only the top k options\n+            if top_k is not None:\n+                v, _ = torch.topk(logits, top_k)\n+                logits[logits < v[:, [-1]]] = -float('Inf')\n+            # apply softmax to convert logits to (normalized) probabilities\n+            probs = F.softmax(logits, dim=-1)\n+            # either sample from the distribution or take the most likely element\n+            if do_sample:\n+                idx_next = torch.multinomial(probs, num_samples=1)\n+            else:\n+                _, idx_next = torch.topk(probs, k=1, dim=-1)\n+            # append sampled index to the running sequence and continue\n+            idx = torch.cat((idx, idx_next), dim=1)\n+\n+        return idx\n+\n # -----------------------------------------------------------------------------\n # helper functions for evaluating and sampling from the model\n \n-def top_k_logits(logits, k):\n-    \"\"\"\n-    takes logits (N,D) and returns logits (N,D), but in each row only\n-    the top-k are kept and the rest of the entries are set to -inf.\n-    \"\"\"\n-    v, ix = torch.topk(logits, k, dim=-1)\n-    out = logits.clone()\n-    out[out < v[:, [-1]]] = -float('Inf')\n-    return out\n-\n-@torch.inference_mode()\n-def sample(model, x, steps, temperature=1.0, top_k=None):\n-    \"\"\"\n-    take a conditioning sequence of indices in x (b,t) and predict next tokens\n-    in the sequence, feeding the predictions back into the model each step.\n-    \"\"\"\n-    block_size = model.get_block_size()\n-    model.eval()\n-    for k in range(steps):\n-        # crop the context, if necessary\n-        x_cond = x if x.size(1) <= block_size else x[:, -block_size:]\n-        # feed the context into the model to get logits at each step\n-        logits, _ = model(x_cond)\n-        # pluck the logits at the final step and scale by temperature\n-        logits = logits[:, -1, :] / temperature\n-        # optionally crop probabilities to only the top k options\n-        if top_k is not None:\n-            logits = top_k_logits(logits, top_k)\n-        # apply softmax to convert to probabilities\n-        probs = F.softmax(logits, dim=-1)\n-        # sample from the distribution or take the most likely\n-        ix = torch.multinomial(probs, num_samples=1)\n-        # append to the sequence and continue\n-        x = torch.cat((x, ix), dim=1)\n-    model.train()\n-    return x\n-\n def print_samples(num=10):\n     \"\"\" samples from the model and pretty prints the decoded samples \"\"\"\n     X_init = torch.zeros(num, 1, dtype=torch.long).to(args.device)\n     top_k = args.top_k if args.top_k != -1 else None\n     steps = train_dataset.get_output_length() - 1 # -1 because we already start with <START> token (index 0)\n-    X_samp = sample(model, X_init, steps, top_k=top_k).to('cpu')\n+    X_samp = model.generate(X_init, steps, top_k=top_k, do_sample=True).to('cpu')\n     train_samples, test_samples, new_samples = [], [], []\n     for i in range(X_samp.size(0)):\n         # get the i'th row of sampled integers, as python list\n@@ -367,14 +333,14 @@ def create_datasets(input_file):\n     # parse command line args\n     parser = argparse.ArgumentParser(description=\"Make More\")\n     # system/input/output\n-    parser.add_argument('--input-file', '-i', type=str, default='input.txt', help=\"input file with things one per line\")\n+    parser.add_argument('--input-file', '-i', type=str, default='names.txt', help=\"input file with things one per line\")\n     parser.add_argument('--work-dir', '-o', type=str, default='out', help=\"output working directory\")\n     parser.add_argument('--resume', action='store_true', help=\"when this flag is used, we will resume optimization from existing model in the workdir\")\n-    parser.add_argument('--num-workers', '-n', type=int, default=1, help=\"number of data workers for both train/test\")\n-    parser.add_argument('--device', type=str, default='cpu', help=\"device to use for compute, e.g. cpu|cuda|mps\")\n-    parser.add_argument('--seed', type=int, default=1337, help=\"seed\")\n-    # sampling\n     parser.add_argument('--sample-only', action='store_true', help=\"just sample from the model and quit, don't train\")\n+    parser.add_argument('--num-workers', '-n', type=int, default=0, help=\"number of data workers for both train/test\")\n+    parser.add_argument('--device', type=str, default='cpu', help=\"device to use for compute, examples: cpu|cuda|cuda:2|mps\")\n+    parser.add_argument('--seed', type=int, default=3407, help=\"seed\")\n+    # sampling\n     parser.add_argument('--top-k', type=int, default=-1, help=\"top-k for sampling, -1 means no top-k\")\n     # model\n     parser.add_argument('--n-layer', type=int, default=4, help=\"number of layers in the transformer\")\n@@ -383,25 +349,25 @@ def create_datasets(input_file):\n     # optimization\n     parser.add_argument('--batch-size', '-b', type=int, default=32, help=\"batch size during optimization\")\n     parser.add_argument('--learning-rate', '-l', type=float, default=5e-4, help=\"learning rate\")\n-    parser.add_argument('--dropout', '-d', type=float, default=0.1, help=\"dropout rate\")\n-    parser.add_argument('--weight-decay', '-w', type=float, default=0.1, help=\"weight decay\")\n+    parser.add_argument('--weight-decay', '-w', type=float, default=0.01, help=\"weight decay\")\n     args = parser.parse_args()\n     print(vars(args))\n \n     # system inits\n     torch.manual_seed(args.seed)\n     torch.cuda.manual_seed_all(args.seed)\n-    torch.use_deterministic_algorithms(True)\n     os.makedirs(args.work_dir, exist_ok=True)\n     writer = SummaryWriter(log_dir=args.work_dir)\n \n     # init datasets\n     train_dataset, test_dataset = create_datasets(args.input_file)\n+    vocab_size = train_dataset.get_vocab_size()\n+    block_size = train_dataset.get_output_length()\n+    print(f\"dataset determined that: {vocab_size=}, {block_size=}\")\n \n     # init model\n-    config = GPTConfig(vocab_size=train_dataset.get_vocab_size(), block_size=train_dataset.get_output_length(),\n-                       n_layer=args.n_layer, n_head=args.n_head, n_embd=args.n_embd,\n-                       embd_pdrop=args.dropout, attn_pdrop=args.dropout, resid_pdrop=args.dropout)\n+    config = GPTConfig(vocab_size=vocab_size, block_size=block_size,\n+                       n_layer=args.n_layer, n_head=args.n_head, n_embd=args.n_embd)\n     model = GPT(config)\n     model.to(args.device)\n     print(f\"model #params: {sum(p.numel() for p in model.parameters())}\")", "status": "modified"}, {"commit_id": "c3aaadcb165a7e188d808cc36507d8bd10a94524", "commit_message": "split out train,test,new separately when reporting on sampling word identity", "relative_path": "makemore.py", "previous_code_file": "\"\"\"\nyou give this script some words (one per line) and it will generate more things like it.\nuses super state of the art Transformer AI tech\nthis code is intended to be super hackable. tune it to your needs.\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport math\nimport argparse\nfrom dataclasses import dataclass\nfrom typing import List\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\nfrom torch.utils.data import Dataset\nfrom torch.utils.data.dataloader import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\n# -----------------------------------------------------------------------------\n# GPT (PyTorch) model definition\n\n@dataclass\nclass GPTConfig:\n    # size of the model\n    n_layer: int = 4\n    n_head: int = 4\n    n_embd: int = 64\n    vocab_size: int = None\n    block_size: int = None\n    # regularization\n    embd_pdrop: float = 0.1\n    resid_pdrop:float = 0.1\n    attn_pdrop:float = 0.1\n\n@dataclass\nclass TrainConfig:\n    # optimization parameters\n    learning_rate: float = 5e-4\n    weight_decay: float = 0.1 # only applied on matmul weights\n    betas: List[float] = (0.9, 0.99)\n\nclass CausalSelfAttention(nn.Module):\n    \"\"\"\n    A vanilla multi-head masked self-attention layer with a projection at the end.\n    It is possible to use torch.nn.MultiheadAttention here but I am including an\n    explicit implementation here to show that there is nothing too scary here.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.n_embd % config.n_head == 0\n        # key, query, value projections for all heads\n        self.key = nn.Linear(config.n_embd, config.n_embd)\n        self.query = nn.Linear(config.n_embd, config.n_embd)\n        self.value = nn.Linear(config.n_embd, config.n_embd)\n        # regularization\n        self.attn_drop = nn.Dropout(config.attn_pdrop)\n        self.resid_drop = nn.Dropout(config.resid_pdrop)\n        # output projection\n        self.proj = nn.Linear(config.n_embd, config.n_embd)\n        # causal mask to ensure that attention is only applied to the left in the input sequence\n        self.register_buffer(\"mask\", torch.tril(torch.ones(config.block_size, config.block_size))\n                                     .view(1, 1, config.block_size, config.block_size))\n        self.n_head = config.n_head\n\n    def forward(self, x):\n        B, T, C = x.size() # batch size, sequence length, embedding dimensionality (n_embd)\n\n        # calculate query, key, values for all heads in batch and move head forward to be the batch dim\n        k = self.key(x).view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        q = self.query(x).view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        v = self.value(x).view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n\n        # causal self-attention; Self-attend: (B, nh, T, hs) x (B, nh, hs, T) -> (B, nh, T, T)\n        att = (q @ k.transpose(-2, -1)) * (1.0 / math.sqrt(k.size(-1)))\n        att = att.masked_fill(self.mask[:,:,:T,:T] == 0, float('-inf'))\n        att = F.softmax(att, dim=-1)\n        att = self.attn_drop(att)\n        y = att @ v # (B, nh, T, T) x (B, nh, T, hs) -> (B, nh, T, hs)\n        y = y.transpose(1, 2).contiguous().view(B, T, C) # re-assemble all head outputs side by side\n\n        # output projection\n        y = self.resid_drop(self.proj(y))\n        return y\n\nclass Block(nn.Module):\n    \"\"\" an unassuming Transformer block \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.ln1 = nn.LayerNorm(config.n_embd)\n        self.ln2 = nn.LayerNorm(config.n_embd)\n        self.attn = CausalSelfAttention(config)\n        self.mlp = nn.Sequential(\n            nn.Linear(config.n_embd, 4 * config.n_embd),\n            nn.GELU(),\n            nn.Linear(4 * config.n_embd, config.n_embd),\n            nn.Dropout(config.resid_pdrop),\n        )\n\n    def forward(self, x):\n        x = x + self.attn(self.ln1(x))\n        x = x + self.mlp(self.ln2(x))\n        return x\n\nclass GPT(nn.Module):\n    \"\"\" the full GPT language model, with a context size of block_size \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n\n        # input embedding stem\n        self.tok_emb = nn.Embedding(config.vocab_size, config.n_embd)\n        self.pos_emb = nn.Parameter(torch.zeros(1, config.block_size, config.n_embd))\n        self.drop = nn.Dropout(config.embd_pdrop)\n        # transformer\n        self.blocks = nn.Sequential(*[Block(config) for _ in range(config.n_layer)])\n        # decoder head\n        self.ln_f = nn.LayerNorm(config.n_embd)\n        self.head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n\n        self.block_size = config.block_size\n        self.apply(self._init_weights)\n\n        print(\"number of parameters: %d\" % sum(p.numel() for p in self.parameters()))\n\n    def get_block_size(self):\n        return self.block_size\n\n    def _init_weights(self, module):\n        if isinstance(module, (nn.Linear, nn.Embedding)):\n            torch.nn.init.normal_(module.weight, mean=0.0, std=0.02)\n            if isinstance(module, nn.Linear) and module.bias is not None:\n                torch.nn.init.zeros_(module.bias)\n        elif isinstance(module, nn.LayerNorm):\n            torch.nn.init.zeros_(module.bias)\n            torch.nn.init.ones_(module.weight)\n        elif isinstance(module, GPT):\n            torch.nn.init.normal_(module.pos_emb, mean=0.0, std=0.02)\n\n    def configure_optimizers(self, train_config):\n        \"\"\"\n        This long function is unfortunately doing something very simple and is being very defensive:\n        We are separating out all parameters of the model into two buckets: those that will experience\n        weight decay for regularization and those that won't (biases, and layernorm/embedding weights).\n        We are then returning the PyTorch optimizer object.\n        \"\"\"\n\n        # separate out all parameters to those that will and won't experience regularizing weight decay\n        decay = set()\n        no_decay = set()\n        whitelist_weight_modules = (torch.nn.Linear, )\n        blacklist_weight_modules = (torch.nn.LayerNorm, torch.nn.Embedding)\n        for mn, m in self.named_modules():\n            for pn, p in m.named_parameters():\n                fpn = '%s.%s' % (mn, pn) if mn else pn # full param name\n\n                if pn.endswith('bias'):\n                    # all biases will not be decayed\n                    no_decay.add(fpn)\n                elif pn.endswith('weight') and isinstance(m, whitelist_weight_modules):\n                    # weights of whitelist modules will be weight decayed\n                    decay.add(fpn)\n                elif pn.endswith('weight') and isinstance(m, blacklist_weight_modules):\n                    # weights of blacklist modules will NOT be weight decayed\n                    no_decay.add(fpn)\n\n        # special case the position embedding parameter in the root GPT module as not decayed\n        no_decay.add('pos_emb')\n\n        # validate that we considered every parameter\n        param_dict = {pn: p for pn, p in self.named_parameters()}\n        inter_params = decay & no_decay\n        union_params = decay | no_decay\n        assert len(inter_params) == 0, \"parameters %s made it into both decay/no_decay sets!\" % (str(inter_params), )\n        assert len(param_dict.keys() - union_params) == 0, \"parameters %s were not separated into either decay/no_decay set!\" \\\n                                                    % (str(param_dict.keys() - union_params), )\n\n        # create the pytorch optimizer object\n        optim_groups = [\n            {\"params\": [param_dict[pn] for pn in sorted(list(decay))], \"weight_decay\": train_config.weight_decay},\n            {\"params\": [param_dict[pn] for pn in sorted(list(no_decay))], \"weight_decay\": 0.0},\n        ]\n        optimizer = torch.optim.AdamW(optim_groups, lr=train_config.learning_rate, betas=train_config.betas)\n        return optimizer\n\n    def forward(self, idx, targets=None):\n        b, t = idx.size()\n        assert t <= self.block_size, \"Cannot forward, input tensor sequence is longer than model block_size.\"\n\n        # forward the GPT model\n        token_embeddings = self.tok_emb(idx) # each index maps to a (learnable) vector\n        position_embeddings = self.pos_emb[:, :t, :] # each position maps to a (learnable) vector\n        x = self.drop(token_embeddings + position_embeddings)\n        x = self.blocks(x)\n        x = self.ln_f(x)\n        logits = self.head(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n# helper functions for evaluating and sampling from the model\n\ndef top_k_logits(logits, k):\n    \"\"\"\n    takes logits (N,D) and returns logits (N,D), but in each row only\n    the top-k are kept and the rest of the entries are set to -inf.\n    \"\"\"\n    v, ix = torch.topk(logits, k, dim=-1)\n    out = logits.clone()\n    out[out < v[:, [-1]]] = -float('Inf')\n    return out\n\n@torch.inference_mode()\ndef sample(model, x, steps, temperature=1.0, top_k=None):\n    \"\"\"\n    take a conditioning sequence of indices in x (b,t) and predict next tokens\n    in the sequence, feeding the predictions back into the model each step.\n    \"\"\"\n    block_size = model.get_block_size()\n    model.eval()\n    for k in range(steps):\n        # crop the context, if necessary\n        x_cond = x if x.size(1) <= block_size else x[:, -block_size:]\n        # feed the context into the model to get logits at each step\n        logits, _ = model(x_cond)\n        # pluck the logits at the final step and scale by temperature\n        logits = logits[:, -1, :] / temperature\n        # optionally crop probabilities to only the top k options\n        if top_k is not None:\n            logits = top_k_logits(logits, top_k)\n        # apply softmax to convert to probabilities\n        probs = F.softmax(logits, dim=-1)\n        # sample from the distribution or take the most likely\n        ix = torch.multinomial(probs, num_samples=1)\n        # append to the sequence and continue\n        x = torch.cat((x, ix), dim=1)\n    model.train()\n    return x\n\ndef print_samples(num=10):\n    \"\"\" samples from the model and pretty prints the decoded samples \"\"\"\n    X_init = torch.zeros(num, 1, dtype=torch.long).to(args.device)\n    top_k = args.top_k if args.top_k != -1 else None\n    steps = train_dataset.get_output_length() - 1 # -1 because we already start with <START> token (index 0)\n    X_samp = sample(model, X_init, steps, top_k=top_k).to('cpu')\n    unique_samples = []\n    had_samples = []\n    for i in range(X_samp.size(0)):\n        # get the i'th row of sampled integers, as python list\n        row = X_samp[i, 1:].tolist() # note: we need to crop out the first <START> token\n        # token 0 is the <STOP> token, so we crop the output sequence at that point\n        crop_index = row.index(0) if 0 in row else len(row)\n        row = row[:crop_index]\n        word_samp = train_dataset.decode(row)\n        # separately track samples that we have and have not seen before\n        word_have = train_dataset.contains(word_samp) or test_dataset.contains(word_samp)\n        sample_list = had_samples if word_have else unique_samples\n        sample_list.append(word_samp)\n\n    print('-'*80)\n    print(f'{len(had_samples)} Samples that were found in input dataset:')\n    for word in had_samples:\n        print(word)\n    print(f'{len(unique_samples)} Samples that were NOT found in input dataset:')\n    for word in unique_samples:\n        print(word)\n    print('-'*80)\n\n@torch.inference_mode()\ndef evaluate(model, dataset, batch_size=50, max_batches=None):\n    model.eval()\n    loader = DataLoader(dataset, shuffle=True, batch_size=batch_size, num_workers=0)\n    losses = []\n    for i, batch in enumerate(loader):\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n        logits, loss = model(X, Y)\n        losses.append(loss.item())\n        if max_batches is not None and i >= max_batches:\n            break\n    mean_loss = torch.tensor(losses).mean().item()\n    model.train() # reset model back to training mode\n    return mean_loss\n\n# -----------------------------------------------------------------------------\n# helper functions for creating the training and test Datasets that emit words\n\nclass CharDataset(Dataset):\n\n    def __init__(self, words, chars, max_word_length):\n        self.words = words\n        self.chars = chars\n        self.max_word_length = max_word_length\n        self.stoi = {ch:i+1 for i,ch in enumerate(chars)}\n        self.itos = {i:s for s,i in self.stoi.items()} # inverse mapping\n\n    def __len__(self):\n        return len(self.words)\n\n    def contains(self, word):\n        return word in self.words\n\n    def get_vocab_size(self):\n        return len(self.chars) + 1 # all the possible characters and special 0 token\n\n    def get_output_length(self):\n        return self.max_word_length + 1 # <START> token followed by words\n\n    def encode(self, word):\n        ix = torch.tensor([self.stoi[w] for w in word], dtype=torch.long)\n        return ix\n\n    def decode(self, ix):\n        word = ''.join(self.itos[i] for i in ix)\n        return word\n\n    def __getitem__(self, idx):\n        word = self.words[idx]\n        ix = self.encode(word)\n        x = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        y = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        x[1:1+len(ix)] = ix\n        y[:len(ix)] = ix\n        y[len(ix)+1:] = -1 # index -1 will mask the loss at the inactive locations\n        return x, y\n\ndef create_datasets(input_file):\n\n    # preprocessing of the input text file\n    with open(input_file, 'r') as f:\n        data = f.read()\n    words = data.splitlines()\n    words = [w.strip() for w in words] # get rid of any leading or trailing white space\n    words = [w for w in words if w] # get rid of any empty strings\n    chars = sorted(list(set(''.join(words)))) # all the possible characters\n    max_word_length = max(len(w) for w in words)\n    print(f\"number of examples in the dataset: {len(words)}\")\n    print(f\"max word length: {max_word_length}\")\n    print(f\"number of unique characters in the vocabulary: {len(chars)}\")\n    print(\"vocabulary:\")\n    print(''.join(chars))\n\n    # partition the input data into a training and the test set\n    test_set_size = min(1000, int(len(words) * 0.1)) # 10% of the training set, or up to 1000 examples\n    rp = torch.randperm(len(words)).tolist()\n    train_words = [words[i] for i in rp[:-test_set_size]]\n    test_words = [words[i] for i in rp[-test_set_size:]]\n    print(f\"split up the dataset into {len(train_words)} training examples and {len(test_words)} test examples\")\n\n    # wrap in dataset objects\n    train_dataset = CharDataset(train_words, chars, max_word_length)\n    test_dataset = CharDataset(test_words, chars, max_word_length)\n\n    return train_dataset, test_dataset\n\n# -----------------------------------------------------------------------------\nif __name__ == '__main__':\n\n    # parse command line args\n    parser = argparse.ArgumentParser(description=\"Make More\")\n    # system/input/output\n    parser.add_argument('--input-file', '-i', type=str, default='input.txt', help=\"input file with things one per line\")\n    parser.add_argument('--work-dir', '-o', type=str, default='out', help=\"output working directory\")\n    parser.add_argument('--resume', action='store_true', help=\"when this flag is used, we will resume optimization from existing model in the workdir\")\n    parser.add_argument('--num-workers', '-n', type=int, default=1, help=\"number of data workers for both train/test\")\n    parser.add_argument('--device', type=str, default='cpu', help=\"device to use for compute, e.g. cpu|cuda|mps\")\n    parser.add_argument('--seed', type=int, default=1337, help=\"seed\")\n    # sampling\n    parser.add_argument('--sample-only', action='store_true', help=\"just sample from the model and quit, don't train\")\n    parser.add_argument('--top-k', type=int, default=-1, help=\"top-k for sampling, -1 means no top-k\")\n    # model\n    parser.add_argument('--n-layer', type=int, default=4, help=\"number of layers in the transformer\")\n    parser.add_argument('--n-head', type=int, default=4, help=\"number of heads in the transformer\")\n    parser.add_argument('--n-embd', type=int, default=64, help=\"number of feature channels in the transformer\")\n    # optimization\n    parser.add_argument('--batch-size', '-b', type=int, default=32, help=\"batch size during optimization\")\n    parser.add_argument('--learning-rate', '-l', type=float, default=5e-4, help=\"learning rate\")\n    parser.add_argument('--dropout', '-d', type=float, default=0.1, help=\"dropout rate\")\n    parser.add_argument('--weight-decay', '-w', type=float, default=0.1, help=\"weight decay\")\n    args = parser.parse_args()\n    print(vars(args))\n\n    # system inits\n    torch.manual_seed(args.seed)\n    torch.cuda.manual_seed_all(args.seed)\n    torch.use_deterministic_algorithms(True)\n    os.makedirs(args.work_dir, exist_ok=True)\n    writer = SummaryWriter(log_dir=args.work_dir)\n\n    # init datasets\n    train_dataset, test_dataset = create_datasets(args.input_file)\n\n    # init model\n    config = GPTConfig(vocab_size=train_dataset.get_vocab_size(), block_size=train_dataset.get_output_length(),\n                       n_layer=args.n_layer, n_head=args.n_head, n_embd=args.n_embd,\n                       embd_pdrop=args.dropout, attn_pdrop=args.dropout, resid_pdrop=args.dropout)\n    model = GPT(config)\n    model.to(args.device)\n    print(f\"model #params: {sum(p.numel() for p in model.parameters())}\")\n    if args.resume or args.sample_only: # note: if we sample-only then we also assume we're resuming\n        print(\"resuming from existing model in the workdir\")\n        model.load_state_dict(torch.load(os.path.join(args.work_dir, 'model.pt')))\n    if args.sample_only:\n        print_samples(num=50)\n        sys.exit()\n\n    # init optimizer\n    train_config = TrainConfig(learning_rate=args.learning_rate, weight_decay=args.weight_decay)\n    optimizer = model.configure_optimizers(train_config)\n\n    # init dataloader\n    train_sampler = torch.utils.data.RandomSampler(train_dataset, replacement=True, num_samples=int(1e10))\n    train_loader = DataLoader(train_dataset, batch_size=args.batch_size, pin_memory=True,\n                              num_workers=args.num_workers, sampler=train_sampler)\n    data_iter = iter(train_loader)\n\n    # training loop\n    best_loss = None\n    step = 0\n    while True:\n\n        t0 = time.time()\n        # fetch the next batch and reset dataloader every epoch as necessary\n        try:\n            batch = next(data_iter)\n        except StopIteration:\n            data_iter = iter(train_loader)\n            batch = next(data_iter)\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n\n        # feed into the model\n        logits, loss = model(X, Y)\n\n        # calculate the gradient, clip it, update the weights\n        model.zero_grad(set_to_none=True)\n        loss.backward()\n        torch.nn.utils.clip_grad_norm_(model.parameters(), 1.0)\n        optimizer.step()\n        if args.device == 'cuda':\n            torch.cuda.synchronize()\n        t1 = time.time()\n\n        # logging\n        if step % 10 == 0:\n            print(f\"step {step} | loss {loss.item():.4f} | step time {(t1-t0)*1000:.2f}ms\")\n\n        # evaluate the model\n        if step > 0 and step % 500 == 0:\n            train_loss = evaluate(model, train_dataset, batch_size=100, max_batches=10)\n            test_loss  = evaluate(model, test_dataset,  batch_size=100, max_batches=10)\n            writer.add_scalar(\"Loss/train\", train_loss, step)\n            writer.add_scalar(\"Loss/test\", test_loss, step)\n            writer.flush()\n            print(f\"step {step} train loss: {train_loss} test loss: {test_loss}\")\n            # save the model to disk if it has improved\n            if best_loss is None or test_loss < best_loss:\n                out_path = os.path.join(args.work_dir, \"model.pt\")\n                print(f\"test loss {test_loss} is the best so far, saving model to {out_path}\")\n                torch.save(model.state_dict(), out_path)\n                best_loss = test_loss\n\n        # sample from the model\n        if step > 0 and step % 200 == 0:\n            print_samples(num=10)\n\n        step += 1\n", "previous_id": "e0a08f234c933a04b8b0282332c5c451a64a0891", "new_code_file": "\"\"\"\nyou give this script some words (one per line) and it will generate more things like it.\nuses super state of the art Transformer AI tech\nthis code is intended to be super hackable. tune it to your needs.\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport math\nimport argparse\nfrom dataclasses import dataclass\nfrom typing import List\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\nfrom torch.utils.data import Dataset\nfrom torch.utils.data.dataloader import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\n# -----------------------------------------------------------------------------\n# GPT (PyTorch) model definition\n\n@dataclass\nclass GPTConfig:\n    # size of the model\n    n_layer: int = 4\n    n_head: int = 4\n    n_embd: int = 64\n    vocab_size: int = None\n    block_size: int = None\n    # regularization\n    embd_pdrop: float = 0.1\n    resid_pdrop:float = 0.1\n    attn_pdrop:float = 0.1\n\n@dataclass\nclass TrainConfig:\n    # optimization parameters\n    learning_rate: float = 5e-4\n    weight_decay: float = 0.1 # only applied on matmul weights\n    betas: List[float] = (0.9, 0.99)\n\nclass CausalSelfAttention(nn.Module):\n    \"\"\"\n    A vanilla multi-head masked self-attention layer with a projection at the end.\n    It is possible to use torch.nn.MultiheadAttention here but I am including an\n    explicit implementation here to show that there is nothing too scary here.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.n_embd % config.n_head == 0\n        # key, query, value projections for all heads\n        self.key = nn.Linear(config.n_embd, config.n_embd)\n        self.query = nn.Linear(config.n_embd, config.n_embd)\n        self.value = nn.Linear(config.n_embd, config.n_embd)\n        # regularization\n        self.attn_drop = nn.Dropout(config.attn_pdrop)\n        self.resid_drop = nn.Dropout(config.resid_pdrop)\n        # output projection\n        self.proj = nn.Linear(config.n_embd, config.n_embd)\n        # causal mask to ensure that attention is only applied to the left in the input sequence\n        self.register_buffer(\"mask\", torch.tril(torch.ones(config.block_size, config.block_size))\n                                     .view(1, 1, config.block_size, config.block_size))\n        self.n_head = config.n_head\n\n    def forward(self, x):\n        B, T, C = x.size() # batch size, sequence length, embedding dimensionality (n_embd)\n\n        # calculate query, key, values for all heads in batch and move head forward to be the batch dim\n        k = self.key(x).view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        q = self.query(x).view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        v = self.value(x).view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n\n        # causal self-attention; Self-attend: (B, nh, T, hs) x (B, nh, hs, T) -> (B, nh, T, T)\n        att = (q @ k.transpose(-2, -1)) * (1.0 / math.sqrt(k.size(-1)))\n        att = att.masked_fill(self.mask[:,:,:T,:T] == 0, float('-inf'))\n        att = F.softmax(att, dim=-1)\n        att = self.attn_drop(att)\n        y = att @ v # (B, nh, T, T) x (B, nh, T, hs) -> (B, nh, T, hs)\n        y = y.transpose(1, 2).contiguous().view(B, T, C) # re-assemble all head outputs side by side\n\n        # output projection\n        y = self.resid_drop(self.proj(y))\n        return y\n\nclass Block(nn.Module):\n    \"\"\" an unassuming Transformer block \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.ln1 = nn.LayerNorm(config.n_embd)\n        self.ln2 = nn.LayerNorm(config.n_embd)\n        self.attn = CausalSelfAttention(config)\n        self.mlp = nn.Sequential(\n            nn.Linear(config.n_embd, 4 * config.n_embd),\n            nn.GELU(),\n            nn.Linear(4 * config.n_embd, config.n_embd),\n            nn.Dropout(config.resid_pdrop),\n        )\n\n    def forward(self, x):\n        x = x + self.attn(self.ln1(x))\n        x = x + self.mlp(self.ln2(x))\n        return x\n\nclass GPT(nn.Module):\n    \"\"\" the full GPT language model, with a context size of block_size \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n\n        # input embedding stem\n        self.tok_emb = nn.Embedding(config.vocab_size, config.n_embd)\n        self.pos_emb = nn.Parameter(torch.zeros(1, config.block_size, config.n_embd))\n        self.drop = nn.Dropout(config.embd_pdrop)\n        # transformer\n        self.blocks = nn.Sequential(*[Block(config) for _ in range(config.n_layer)])\n        # decoder head\n        self.ln_f = nn.LayerNorm(config.n_embd)\n        self.head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n\n        self.block_size = config.block_size\n        self.apply(self._init_weights)\n\n        print(\"number of parameters: %d\" % sum(p.numel() for p in self.parameters()))\n\n    def get_block_size(self):\n        return self.block_size\n\n    def _init_weights(self, module):\n        if isinstance(module, (nn.Linear, nn.Embedding)):\n            torch.nn.init.normal_(module.weight, mean=0.0, std=0.02)\n            if isinstance(module, nn.Linear) and module.bias is not None:\n                torch.nn.init.zeros_(module.bias)\n        elif isinstance(module, nn.LayerNorm):\n            torch.nn.init.zeros_(module.bias)\n            torch.nn.init.ones_(module.weight)\n        elif isinstance(module, GPT):\n            torch.nn.init.normal_(module.pos_emb, mean=0.0, std=0.02)\n\n    def configure_optimizers(self, train_config):\n        \"\"\"\n        This long function is unfortunately doing something very simple and is being very defensive:\n        We are separating out all parameters of the model into two buckets: those that will experience\n        weight decay for regularization and those that won't (biases, and layernorm/embedding weights).\n        We are then returning the PyTorch optimizer object.\n        \"\"\"\n\n        # separate out all parameters to those that will and won't experience regularizing weight decay\n        decay = set()\n        no_decay = set()\n        whitelist_weight_modules = (torch.nn.Linear, )\n        blacklist_weight_modules = (torch.nn.LayerNorm, torch.nn.Embedding)\n        for mn, m in self.named_modules():\n            for pn, p in m.named_parameters():\n                fpn = '%s.%s' % (mn, pn) if mn else pn # full param name\n\n                if pn.endswith('bias'):\n                    # all biases will not be decayed\n                    no_decay.add(fpn)\n                elif pn.endswith('weight') and isinstance(m, whitelist_weight_modules):\n                    # weights of whitelist modules will be weight decayed\n                    decay.add(fpn)\n                elif pn.endswith('weight') and isinstance(m, blacklist_weight_modules):\n                    # weights of blacklist modules will NOT be weight decayed\n                    no_decay.add(fpn)\n\n        # special case the position embedding parameter in the root GPT module as not decayed\n        no_decay.add('pos_emb')\n\n        # validate that we considered every parameter\n        param_dict = {pn: p for pn, p in self.named_parameters()}\n        inter_params = decay & no_decay\n        union_params = decay | no_decay\n        assert len(inter_params) == 0, \"parameters %s made it into both decay/no_decay sets!\" % (str(inter_params), )\n        assert len(param_dict.keys() - union_params) == 0, \"parameters %s were not separated into either decay/no_decay set!\" \\\n                                                    % (str(param_dict.keys() - union_params), )\n\n        # create the pytorch optimizer object\n        optim_groups = [\n            {\"params\": [param_dict[pn] for pn in sorted(list(decay))], \"weight_decay\": train_config.weight_decay},\n            {\"params\": [param_dict[pn] for pn in sorted(list(no_decay))], \"weight_decay\": 0.0},\n        ]\n        optimizer = torch.optim.AdamW(optim_groups, lr=train_config.learning_rate, betas=train_config.betas)\n        return optimizer\n\n    def forward(self, idx, targets=None):\n        b, t = idx.size()\n        assert t <= self.block_size, \"Cannot forward, input tensor sequence is longer than model block_size.\"\n\n        # forward the GPT model\n        token_embeddings = self.tok_emb(idx) # each index maps to a (learnable) vector\n        position_embeddings = self.pos_emb[:, :t, :] # each position maps to a (learnable) vector\n        x = self.drop(token_embeddings + position_embeddings)\n        x = self.blocks(x)\n        x = self.ln_f(x)\n        logits = self.head(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n# helper functions for evaluating and sampling from the model\n\ndef top_k_logits(logits, k):\n    \"\"\"\n    takes logits (N,D) and returns logits (N,D), but in each row only\n    the top-k are kept and the rest of the entries are set to -inf.\n    \"\"\"\n    v, ix = torch.topk(logits, k, dim=-1)\n    out = logits.clone()\n    out[out < v[:, [-1]]] = -float('Inf')\n    return out\n\n@torch.inference_mode()\ndef sample(model, x, steps, temperature=1.0, top_k=None):\n    \"\"\"\n    take a conditioning sequence of indices in x (b,t) and predict next tokens\n    in the sequence, feeding the predictions back into the model each step.\n    \"\"\"\n    block_size = model.get_block_size()\n    model.eval()\n    for k in range(steps):\n        # crop the context, if necessary\n        x_cond = x if x.size(1) <= block_size else x[:, -block_size:]\n        # feed the context into the model to get logits at each step\n        logits, _ = model(x_cond)\n        # pluck the logits at the final step and scale by temperature\n        logits = logits[:, -1, :] / temperature\n        # optionally crop probabilities to only the top k options\n        if top_k is not None:\n            logits = top_k_logits(logits, top_k)\n        # apply softmax to convert to probabilities\n        probs = F.softmax(logits, dim=-1)\n        # sample from the distribution or take the most likely\n        ix = torch.multinomial(probs, num_samples=1)\n        # append to the sequence and continue\n        x = torch.cat((x, ix), dim=1)\n    model.train()\n    return x\n\ndef print_samples(num=10):\n    \"\"\" samples from the model and pretty prints the decoded samples \"\"\"\n    X_init = torch.zeros(num, 1, dtype=torch.long).to(args.device)\n    top_k = args.top_k if args.top_k != -1 else None\n    steps = train_dataset.get_output_length() - 1 # -1 because we already start with <START> token (index 0)\n    X_samp = sample(model, X_init, steps, top_k=top_k).to('cpu')\n    train_samples, test_samples, new_samples = [], [], []\n    for i in range(X_samp.size(0)):\n        # get the i'th row of sampled integers, as python list\n        row = X_samp[i, 1:].tolist() # note: we need to crop out the first <START> token\n        # token 0 is the <STOP> token, so we crop the output sequence at that point\n        crop_index = row.index(0) if 0 in row else len(row)\n        row = row[:crop_index]\n        word_samp = train_dataset.decode(row)\n        # separately track samples that we have and have not seen before\n        if train_dataset.contains(word_samp):\n            train_samples.append(word_samp)\n        elif test_dataset.contains(word_samp):\n            test_samples.append(word_samp)\n        else:\n            new_samples.append(word_samp)\n    print('-'*80)\n    for lst, desc in [(train_samples, 'in train'), (test_samples, 'in test'), (new_samples, 'new')]:\n        print(f\"{len(lst)} samples that are {desc}:\")\n        for word in lst:\n            print(word)\n    print('-'*80)\n\n@torch.inference_mode()\ndef evaluate(model, dataset, batch_size=50, max_batches=None):\n    model.eval()\n    loader = DataLoader(dataset, shuffle=True, batch_size=batch_size, num_workers=0)\n    losses = []\n    for i, batch in enumerate(loader):\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n        logits, loss = model(X, Y)\n        losses.append(loss.item())\n        if max_batches is not None and i >= max_batches:\n            break\n    mean_loss = torch.tensor(losses).mean().item()\n    model.train() # reset model back to training mode\n    return mean_loss\n\n# -----------------------------------------------------------------------------\n# helper functions for creating the training and test Datasets that emit words\n\nclass CharDataset(Dataset):\n\n    def __init__(self, words, chars, max_word_length):\n        self.words = words\n        self.chars = chars\n        self.max_word_length = max_word_length\n        self.stoi = {ch:i+1 for i,ch in enumerate(chars)}\n        self.itos = {i:s for s,i in self.stoi.items()} # inverse mapping\n\n    def __len__(self):\n        return len(self.words)\n\n    def contains(self, word):\n        return word in self.words\n\n    def get_vocab_size(self):\n        return len(self.chars) + 1 # all the possible characters and special 0 token\n\n    def get_output_length(self):\n        return self.max_word_length + 1 # <START> token followed by words\n\n    def encode(self, word):\n        ix = torch.tensor([self.stoi[w] for w in word], dtype=torch.long)\n        return ix\n\n    def decode(self, ix):\n        word = ''.join(self.itos[i] for i in ix)\n        return word\n\n    def __getitem__(self, idx):\n        word = self.words[idx]\n        ix = self.encode(word)\n        x = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        y = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        x[1:1+len(ix)] = ix\n        y[:len(ix)] = ix\n        y[len(ix)+1:] = -1 # index -1 will mask the loss at the inactive locations\n        return x, y\n\ndef create_datasets(input_file):\n\n    # preprocessing of the input text file\n    with open(input_file, 'r') as f:\n        data = f.read()\n    words = data.splitlines()\n    words = [w.strip() for w in words] # get rid of any leading or trailing white space\n    words = [w for w in words if w] # get rid of any empty strings\n    chars = sorted(list(set(''.join(words)))) # all the possible characters\n    max_word_length = max(len(w) for w in words)\n    print(f\"number of examples in the dataset: {len(words)}\")\n    print(f\"max word length: {max_word_length}\")\n    print(f\"number of unique characters in the vocabulary: {len(chars)}\")\n    print(\"vocabulary:\")\n    print(''.join(chars))\n\n    # partition the input data into a training and the test set\n    test_set_size = min(1000, int(len(words) * 0.1)) # 10% of the training set, or up to 1000 examples\n    rp = torch.randperm(len(words)).tolist()\n    train_words = [words[i] for i in rp[:-test_set_size]]\n    test_words = [words[i] for i in rp[-test_set_size:]]\n    print(f\"split up the dataset into {len(train_words)} training examples and {len(test_words)} test examples\")\n\n    # wrap in dataset objects\n    train_dataset = CharDataset(train_words, chars, max_word_length)\n    test_dataset = CharDataset(test_words, chars, max_word_length)\n\n    return train_dataset, test_dataset\n\n# -----------------------------------------------------------------------------\nif __name__ == '__main__':\n\n    # parse command line args\n    parser = argparse.ArgumentParser(description=\"Make More\")\n    # system/input/output\n    parser.add_argument('--input-file', '-i', type=str, default='input.txt', help=\"input file with things one per line\")\n    parser.add_argument('--work-dir', '-o', type=str, default='out', help=\"output working directory\")\n    parser.add_argument('--resume', action='store_true', help=\"when this flag is used, we will resume optimization from existing model in the workdir\")\n    parser.add_argument('--num-workers', '-n', type=int, default=1, help=\"number of data workers for both train/test\")\n    parser.add_argument('--device', type=str, default='cpu', help=\"device to use for compute, e.g. cpu|cuda|mps\")\n    parser.add_argument('--seed', type=int, default=1337, help=\"seed\")\n    # sampling\n    parser.add_argument('--sample-only', action='store_true', help=\"just sample from the model and quit, don't train\")\n    parser.add_argument('--top-k', type=int, default=-1, help=\"top-k for sampling, -1 means no top-k\")\n    # model\n    parser.add_argument('--n-layer', type=int, default=4, help=\"number of layers in the transformer\")\n    parser.add_argument('--n-head', type=int, default=4, help=\"number of heads in the transformer\")\n    parser.add_argument('--n-embd', type=int, default=64, help=\"number of feature channels in the transformer\")\n    # optimization\n    parser.add_argument('--batch-size', '-b', type=int, default=32, help=\"batch size during optimization\")\n    parser.add_argument('--learning-rate', '-l', type=float, default=5e-4, help=\"learning rate\")\n    parser.add_argument('--dropout', '-d', type=float, default=0.1, help=\"dropout rate\")\n    parser.add_argument('--weight-decay', '-w', type=float, default=0.1, help=\"weight decay\")\n    args = parser.parse_args()\n    print(vars(args))\n\n    # system inits\n    torch.manual_seed(args.seed)\n    torch.cuda.manual_seed_all(args.seed)\n    torch.use_deterministic_algorithms(True)\n    os.makedirs(args.work_dir, exist_ok=True)\n    writer = SummaryWriter(log_dir=args.work_dir)\n\n    # init datasets\n    train_dataset, test_dataset = create_datasets(args.input_file)\n\n    # init model\n    config = GPTConfig(vocab_size=train_dataset.get_vocab_size(), block_size=train_dataset.get_output_length(),\n                       n_layer=args.n_layer, n_head=args.n_head, n_embd=args.n_embd,\n                       embd_pdrop=args.dropout, attn_pdrop=args.dropout, resid_pdrop=args.dropout)\n    model = GPT(config)\n    model.to(args.device)\n    print(f\"model #params: {sum(p.numel() for p in model.parameters())}\")\n    if args.resume or args.sample_only: # note: if we sample-only then we also assume we're resuming\n        print(\"resuming from existing model in the workdir\")\n        model.load_state_dict(torch.load(os.path.join(args.work_dir, 'model.pt')))\n    if args.sample_only:\n        print_samples(num=50)\n        sys.exit()\n\n    # init optimizer\n    train_config = TrainConfig(learning_rate=args.learning_rate, weight_decay=args.weight_decay)\n    optimizer = model.configure_optimizers(train_config)\n\n    # init dataloader\n    train_sampler = torch.utils.data.RandomSampler(train_dataset, replacement=True, num_samples=int(1e10))\n    train_loader = DataLoader(train_dataset, batch_size=args.batch_size, pin_memory=True,\n                              num_workers=args.num_workers, sampler=train_sampler)\n    data_iter = iter(train_loader)\n\n    # training loop\n    best_loss = None\n    step = 0\n    while True:\n\n        t0 = time.time()\n        # fetch the next batch and reset dataloader every epoch as necessary\n        try:\n            batch = next(data_iter)\n        except StopIteration:\n            data_iter = iter(train_loader)\n            batch = next(data_iter)\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n\n        # feed into the model\n        logits, loss = model(X, Y)\n\n        # calculate the gradient, clip it, update the weights\n        model.zero_grad(set_to_none=True)\n        loss.backward()\n        torch.nn.utils.clip_grad_norm_(model.parameters(), 1.0)\n        optimizer.step()\n        if args.device == 'cuda':\n            torch.cuda.synchronize()\n        t1 = time.time()\n\n        # logging\n        if step % 10 == 0:\n            print(f\"step {step} | loss {loss.item():.4f} | step time {(t1-t0)*1000:.2f}ms\")\n\n        # evaluate the model\n        if step > 0 and step % 500 == 0:\n            train_loss = evaluate(model, train_dataset, batch_size=100, max_batches=10)\n            test_loss  = evaluate(model, test_dataset,  batch_size=100, max_batches=10)\n            writer.add_scalar(\"Loss/train\", train_loss, step)\n            writer.add_scalar(\"Loss/test\", test_loss, step)\n            writer.flush()\n            print(f\"step {step} train loss: {train_loss} test loss: {test_loss}\")\n            # save the model to disk if it has improved\n            if best_loss is None or test_loss < best_loss:\n                out_path = os.path.join(args.work_dir, \"model.pt\")\n                print(f\"test loss {test_loss} is the best so far, saving model to {out_path}\")\n                torch.save(model.state_dict(), out_path)\n                best_loss = test_loss\n\n        # sample from the model\n        if step > 0 and step % 200 == 0:\n            print_samples(num=10)\n\n        step += 1\n", "diff": "@@ -252,8 +252,7 @@ def print_samples(num=10):\n     top_k = args.top_k if args.top_k != -1 else None\n     steps = train_dataset.get_output_length() - 1 # -1 because we already start with <START> token (index 0)\n     X_samp = sample(model, X_init, steps, top_k=top_k).to('cpu')\n-    unique_samples = []\n-    had_samples = []\n+    train_samples, test_samples, new_samples = [], [], []\n     for i in range(X_samp.size(0)):\n         # get the i'th row of sampled integers, as python list\n         row = X_samp[i, 1:].tolist() # note: we need to crop out the first <START> token\n@@ -262,17 +261,17 @@ def print_samples(num=10):\n         row = row[:crop_index]\n         word_samp = train_dataset.decode(row)\n         # separately track samples that we have and have not seen before\n-        word_have = train_dataset.contains(word_samp) or test_dataset.contains(word_samp)\n-        sample_list = had_samples if word_have else unique_samples\n-        sample_list.append(word_samp)\n-\n+        if train_dataset.contains(word_samp):\n+            train_samples.append(word_samp)\n+        elif test_dataset.contains(word_samp):\n+            test_samples.append(word_samp)\n+        else:\n+            new_samples.append(word_samp)\n     print('-'*80)\n-    print(f'{len(had_samples)} Samples that were found in input dataset:')\n-    for word in had_samples:\n-        print(word)\n-    print(f'{len(unique_samples)} Samples that were NOT found in input dataset:')\n-    for word in unique_samples:\n-        print(word)\n+    for lst, desc in [(train_samples, 'in train'), (test_samples, 'in test'), (new_samples, 'new')]:\n+        print(f\"{len(lst)} samples that are {desc}:\")\n+        for word in lst:\n+            print(word)\n     print('-'*80)\n \n @torch.inference_mode()", "status": "modified"}, {"commit_id": "e0a08f234c933a04b8b0282332c5c451a64a0891", "commit_message": "small tweaks to support the Apple Silicon M1 chip device 'mps'. But this is not yet faster because a lot of ops are still being implemented https://github.com/pytorch/pytorch/issues/77764 , in particular for us the layernorm backward as of today", "relative_path": "makemore.py", "previous_code_file": "\"\"\"\nyou give this script some words (one per line) and it will generate more things like it.\nuses super state of the art Transformer AI tech\nthis code is intended to be super hackable. tune it to your needs.\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport math\nimport argparse\nfrom dataclasses import dataclass\nfrom typing import List\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\nfrom torch.utils.data import Dataset\nfrom torch.utils.data.dataloader import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\n# -----------------------------------------------------------------------------\n# GPT (PyTorch) model definition\n\n@dataclass\nclass GPTConfig:\n    # size of the model\n    n_layer: int = 4\n    n_head: int = 4\n    n_embd: int = 64\n    vocab_size: int = None\n    block_size: int = None\n    # regularization\n    embd_pdrop: float = 0.1\n    resid_pdrop:float = 0.1\n    attn_pdrop:float = 0.1\n\n@dataclass\nclass TrainConfig:\n    # optimization parameters\n    learning_rate: float = 5e-4\n    weight_decay: float = 0.1 # only applied on matmul weights\n    betas: List[float] = (0.9, 0.99)\n\nclass CausalSelfAttention(nn.Module):\n    \"\"\"\n    A vanilla multi-head masked self-attention layer with a projection at the end.\n    It is possible to use torch.nn.MultiheadAttention here but I am including an\n    explicit implementation here to show that there is nothing too scary here.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.n_embd % config.n_head == 0\n        # key, query, value projections for all heads\n        self.key = nn.Linear(config.n_embd, config.n_embd)\n        self.query = nn.Linear(config.n_embd, config.n_embd)\n        self.value = nn.Linear(config.n_embd, config.n_embd)\n        # regularization\n        self.attn_drop = nn.Dropout(config.attn_pdrop)\n        self.resid_drop = nn.Dropout(config.resid_pdrop)\n        # output projection\n        self.proj = nn.Linear(config.n_embd, config.n_embd)\n        # causal mask to ensure that attention is only applied to the left in the input sequence\n        self.register_buffer(\"mask\", torch.tril(torch.ones(config.block_size, config.block_size))\n                                     .view(1, 1, config.block_size, config.block_size))\n        self.n_head = config.n_head\n\n    def forward(self, x):\n        B, T, C = x.size() # batch size, sequence length, embedding dimensionality (n_embd)\n\n        # calculate query, key, values for all heads in batch and move head forward to be the batch dim\n        k = self.key(x).view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        q = self.query(x).view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        v = self.value(x).view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n\n        # causal self-attention; Self-attend: (B, nh, T, hs) x (B, nh, hs, T) -> (B, nh, T, T)\n        att = (q @ k.transpose(-2, -1)) * (1.0 / math.sqrt(k.size(-1)))\n        att = att.masked_fill(self.mask[:,:,:T,:T] == 0, float('-inf'))\n        att = F.softmax(att, dim=-1)\n        att = self.attn_drop(att)\n        y = att @ v # (B, nh, T, T) x (B, nh, T, hs) -> (B, nh, T, hs)\n        y = y.transpose(1, 2).contiguous().view(B, T, C) # re-assemble all head outputs side by side\n\n        # output projection\n        y = self.resid_drop(self.proj(y))\n        return y\n\nclass Block(nn.Module):\n    \"\"\" an unassuming Transformer block \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.ln1 = nn.LayerNorm(config.n_embd)\n        self.ln2 = nn.LayerNorm(config.n_embd)\n        self.attn = CausalSelfAttention(config)\n        self.mlp = nn.Sequential(\n            nn.Linear(config.n_embd, 4 * config.n_embd),\n            nn.GELU(),\n            nn.Linear(4 * config.n_embd, config.n_embd),\n            nn.Dropout(config.resid_pdrop),\n        )\n\n    def forward(self, x):\n        x = x + self.attn(self.ln1(x))\n        x = x + self.mlp(self.ln2(x))\n        return x\n\nclass GPT(nn.Module):\n    \"\"\" the full GPT language model, with a context size of block_size \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n\n        # input embedding stem\n        self.tok_emb = nn.Embedding(config.vocab_size, config.n_embd)\n        self.pos_emb = nn.Parameter(torch.zeros(1, config.block_size, config.n_embd))\n        self.drop = nn.Dropout(config.embd_pdrop)\n        # transformer\n        self.blocks = nn.Sequential(*[Block(config) for _ in range(config.n_layer)])\n        # decoder head\n        self.ln_f = nn.LayerNorm(config.n_embd)\n        self.head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n\n        self.block_size = config.block_size\n        self.apply(self._init_weights)\n\n        print(\"number of parameters: %d\" % sum(p.numel() for p in self.parameters()))\n\n    def get_block_size(self):\n        return self.block_size\n\n    def _init_weights(self, module):\n        if isinstance(module, (nn.Linear, nn.Embedding)):\n            torch.nn.init.normal_(module.weight, mean=0.0, std=0.02)\n            if isinstance(module, nn.Linear) and module.bias is not None:\n                torch.nn.init.zeros_(module.bias)\n        elif isinstance(module, nn.LayerNorm):\n            torch.nn.init.zeros_(module.bias)\n            torch.nn.init.ones_(module.weight)\n        elif isinstance(module, GPT):\n            torch.nn.init.normal_(module.pos_emb, mean=0.0, std=0.02)\n\n    def configure_optimizers(self, train_config):\n        \"\"\"\n        This long function is unfortunately doing something very simple and is being very defensive:\n        We are separating out all parameters of the model into two buckets: those that will experience\n        weight decay for regularization and those that won't (biases, and layernorm/embedding weights).\n        We are then returning the PyTorch optimizer object.\n        \"\"\"\n\n        # separate out all parameters to those that will and won't experience regularizing weight decay\n        decay = set()\n        no_decay = set()\n        whitelist_weight_modules = (torch.nn.Linear, )\n        blacklist_weight_modules = (torch.nn.LayerNorm, torch.nn.Embedding)\n        for mn, m in self.named_modules():\n            for pn, p in m.named_parameters():\n                fpn = '%s.%s' % (mn, pn) if mn else pn # full param name\n\n                if pn.endswith('bias'):\n                    # all biases will not be decayed\n                    no_decay.add(fpn)\n                elif pn.endswith('weight') and isinstance(m, whitelist_weight_modules):\n                    # weights of whitelist modules will be weight decayed\n                    decay.add(fpn)\n                elif pn.endswith('weight') and isinstance(m, blacklist_weight_modules):\n                    # weights of blacklist modules will NOT be weight decayed\n                    no_decay.add(fpn)\n\n        # special case the position embedding parameter in the root GPT module as not decayed\n        no_decay.add('pos_emb')\n\n        # validate that we considered every parameter\n        param_dict = {pn: p for pn, p in self.named_parameters()}\n        inter_params = decay & no_decay\n        union_params = decay | no_decay\n        assert len(inter_params) == 0, \"parameters %s made it into both decay/no_decay sets!\" % (str(inter_params), )\n        assert len(param_dict.keys() - union_params) == 0, \"parameters %s were not separated into either decay/no_decay set!\" \\\n                                                    % (str(param_dict.keys() - union_params), )\n\n        # create the pytorch optimizer object\n        optim_groups = [\n            {\"params\": [param_dict[pn] for pn in sorted(list(decay))], \"weight_decay\": train_config.weight_decay},\n            {\"params\": [param_dict[pn] for pn in sorted(list(no_decay))], \"weight_decay\": 0.0},\n        ]\n        optimizer = torch.optim.AdamW(optim_groups, lr=train_config.learning_rate, betas=train_config.betas)\n        return optimizer\n\n    def forward(self, idx, targets=None):\n        b, t = idx.size()\n        assert t <= self.block_size, \"Cannot forward, input tensor sequence is longer than model block_size.\"\n\n        # forward the GPT model\n        token_embeddings = self.tok_emb(idx) # each index maps to a (learnable) vector\n        position_embeddings = self.pos_emb[:, :t, :] # each position maps to a (learnable) vector\n        x = self.drop(token_embeddings + position_embeddings)\n        x = self.blocks(x)\n        x = self.ln_f(x)\n        logits = self.head(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n# helper functions for evaluating and sampling from the model\n\ndef top_k_logits(logits, k):\n    \"\"\"\n    takes logits (N,D) and returns logits (N,D), but in each row only\n    the top-k are kept and the rest of the entries are set to -inf.\n    \"\"\"\n    v, ix = torch.topk(logits, k, dim=-1)\n    out = logits.clone()\n    out[out < v[:, [-1]]] = -float('Inf')\n    return out\n\n@torch.inference_mode()\ndef sample(model, x, steps, temperature=1.0, top_k=None):\n    \"\"\"\n    take a conditioning sequence of indices in x (b,t) and predict next tokens\n    in the sequence, feeding the predictions back into the model each step.\n    \"\"\"\n    block_size = model.get_block_size()\n    model.eval()\n    for k in range(steps):\n        # crop the context, if necessary\n        x_cond = x if x.size(1) <= block_size else x[:, -block_size:]\n        # feed the context into the model to get logits at each step\n        logits, _ = model(x_cond)\n        # pluck the logits at the final step and scale by temperature\n        logits = logits[:, -1, :] / temperature\n        # optionally crop probabilities to only the top k options\n        if top_k is not None:\n            logits = top_k_logits(logits, top_k)\n        # apply softmax to convert to probabilities\n        probs = F.softmax(logits, dim=-1)\n        # sample from the distribution or take the most likely\n        ix = torch.multinomial(probs, num_samples=1)\n        # append to the sequence and continue\n        x = torch.cat((x, ix), dim=1)\n    model.train()\n    return x\n\ndef print_samples(num=10):\n    \"\"\" samples from the model and pretty prints the decoded samples \"\"\"\n    X_init = torch.zeros(num, 1, dtype=torch.long).to(args.device)\n    top_k = args.top_k if args.top_k != -1 else None\n    steps = train_dataset.get_output_length() - 1 # -1 because we already start with <START> token (index 0)\n    X_samp = sample(model, X_init, steps, top_k=top_k).to('cpu')\n    unique_samples = []\n    had_samples = []\n    for i in range(X_samp.size(0)):\n        # get the i'th row of sampled integers, as python list\n        row = X_samp[i, 1:].tolist() # note: we need to crop out the first <START> token\n        # token 0 is the <STOP> token, so we crop the output sequence at that point\n        crop_index = row.index(0) if 0 in row else len(row)\n        row = row[:crop_index]\n        word_samp = train_dataset.decode(row)\n        # separately track samples that we have and have not seen before\n        word_have = train_dataset.contains(word_samp) or test_dataset.contains(word_samp)\n        sample_list = had_samples if word_have else unique_samples\n        sample_list.append(word_samp)\n\n    print('-'*80)\n    print(f'{len(had_samples)} Samples that were found in input dataset:')\n    for word in had_samples:\n        print(word)\n    print(f'{len(unique_samples)} Samples that were NOT found in input dataset:')\n    for word in unique_samples:\n        print(word)\n    print('-'*80)\n\n@torch.inference_mode()\ndef evaluate(model, dataset, batch_size=50, max_batches=None):\n    model.eval()\n    loader = DataLoader(dataset, shuffle=True, batch_size=batch_size, num_workers=0)\n    losses = []\n    for i, batch in enumerate(loader):\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n        logits, loss = model(X, Y)\n        losses.append(loss.item())\n        if max_batches is not None and i >= max_batches:\n            break\n    mean_loss = torch.tensor(losses).mean().item()\n    model.train() # reset model back to training mode\n    return mean_loss\n\n# -----------------------------------------------------------------------------\n# helper functions for creating the training and test Datasets that emit words\n\nclass CharDataset(Dataset):\n\n    def __init__(self, words, chars, max_word_length):\n        self.words = words\n        self.chars = chars\n        self.max_word_length = max_word_length\n        self.stoi = {ch:i+1 for i,ch in enumerate(chars)}\n        self.itos = {i:s for s,i in self.stoi.items()} # inverse mapping\n\n    def __len__(self):\n        return len(self.words)\n\n    def contains(self, word):\n        return word in self.words\n\n    def get_vocab_size(self):\n        return len(self.chars) + 1 # all the possible characters and special 0 token\n\n    def get_output_length(self):\n        return self.max_word_length + 1 # <START> token followed by words\n\n    def encode(self, word):\n        ix = torch.tensor([self.stoi[w] for w in word], dtype=torch.long)\n        return ix\n\n    def decode(self, ix):\n        word = ''.join(self.itos[i] for i in ix)\n        return word\n\n    def __getitem__(self, idx):\n        word = self.words[idx]\n        ix = self.encode(word)\n        x = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        y = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        x[1:1+len(ix)] = ix\n        y[:len(ix)] = ix\n        y[len(ix)+1:] = -1 # index -1 will mask the loss at the inactive locations\n        return x, y\n\ndef create_datasets(input_file):\n\n    # preprocessing of the input text file\n    with open(input_file, 'r') as f:\n        data = f.read()\n    words = data.splitlines()\n    words = [w.strip() for w in words] # get rid of any leading or trailing white space\n    words = [w for w in words if w] # get rid of any empty strings\n    chars = sorted(list(set(''.join(words)))) # all the possible characters\n    max_word_length = max(len(w) for w in words)\n    print(f\"number of examples in the dataset: {len(words)}\")\n    print(f\"max word length: {max_word_length}\")\n    print(f\"number of unique characters in the vocabulary: {len(chars)}\")\n    print(\"vocabulary:\")\n    print(''.join(chars))\n\n    # partition the input data into a training and the test set\n    test_set_size = min(1000, int(len(words) * 0.1)) # 10% of the training set, or up to 1000 examples\n    rp = torch.randperm(len(words)).tolist()\n    train_words = [words[i] for i in rp[:-test_set_size]]\n    test_words = [words[i] for i in rp[-test_set_size:]]\n    print(f\"split up the dataset into {len(train_words)} training examples and {len(test_words)} test examples\")\n\n    # wrap in dataset objects\n    train_dataset = CharDataset(train_words, chars, max_word_length)\n    test_dataset = CharDataset(test_words, chars, max_word_length)\n\n    return train_dataset, test_dataset\n\n# -----------------------------------------------------------------------------\nif __name__ == '__main__':\n\n    # parse command line args\n    parser = argparse.ArgumentParser(description=\"Make More\")\n    # system/input/output\n    parser.add_argument('--input-file', '-i', type=str, default='input.txt', help=\"input file with things one per line\")\n    parser.add_argument('--work-dir', '-o', type=str, default='out', help=\"output working directory\")\n    parser.add_argument('--resume', action='store_true', help=\"when this flag is used, we will resume optimization from existing model in the workdir\")\n    parser.add_argument('--num-workers', '-n', type=int, default=1, help=\"number of data workers for both train/test\")\n    parser.add_argument('--device', type=str, default='cpu', help=\"device to use for compute, e.g. cpu|cuda|m1\")\n    parser.add_argument('--seed', type=int, default=1337, help=\"seed\")\n    # sampling\n    parser.add_argument('--sample-only', action='store_true', help=\"just sample from the model and quit, don't train\")\n    parser.add_argument('--top-k', type=int, default=-1, help=\"top-k for sampling, -1 means no top-k\")\n    # model\n    parser.add_argument('--n-layer', type=int, default=4, help=\"number of layers in the transformer\")\n    parser.add_argument('--n-head', type=int, default=4, help=\"number of heads in the transformer\")\n    parser.add_argument('--n-embd', type=int, default=64, help=\"number of feature channels in the transformer\")\n    # optimization\n    parser.add_argument('--batch-size', '-b', type=int, default=32, help=\"batch size during optimization\")\n    parser.add_argument('--learning-rate', '-l', type=float, default=5e-4, help=\"learning rate\")\n    parser.add_argument('--dropout', '-d', type=float, default=0.1, help=\"dropout rate\")\n    parser.add_argument('--weight-decay', '-w', type=float, default=0.1, help=\"weight decay\")\n    args = parser.parse_args()\n    print(vars(args))\n\n    # system inits\n    torch.manual_seed(args.seed)\n    torch.cuda.manual_seed_all(args.seed)\n    torch.use_deterministic_algorithms(True)\n    os.makedirs(args.work_dir, exist_ok=True)\n    writer = SummaryWriter(log_dir=args.work_dir)\n\n    # init datasets\n    train_dataset, test_dataset = create_datasets(args.input_file)\n\n    # init model\n    config = GPTConfig(vocab_size=train_dataset.get_vocab_size(), block_size=train_dataset.get_output_length(),\n                       n_layer=args.n_layer, n_head=args.n_head, n_embd=args.n_embd,\n                       embd_pdrop=args.dropout, attn_pdrop=args.dropout, resid_pdrop=args.dropout)\n    model = GPT(config)\n    model.to(args.device)\n    print(f\"model #params: {sum(p.numel() for p in model.parameters())}\")\n    if args.resume or args.sample_only: # note: if we sample-only then we also assume we're resuming\n        print(\"resuming from existing model in the workdir\")\n        model.load_state_dict(torch.load(os.path.join(args.work_dir, 'model.pt')))\n    if args.sample_only:\n        print_samples(num=50)\n        sys.exit()\n\n    # init optimizer\n    train_config = TrainConfig(learning_rate=args.learning_rate, weight_decay=args.weight_decay)\n    optimizer = model.configure_optimizers(train_config)\n\n    # init dataloader\n    train_sampler = torch.utils.data.RandomSampler(train_dataset, replacement=True, num_samples=int(1e10))\n    train_loader = DataLoader(train_dataset, batch_size=args.batch_size, pin_memory=True,\n                              num_workers=args.num_workers, sampler=train_sampler)\n    data_iter = iter(train_loader)\n\n    # training loop\n    best_loss = None\n    step = 0\n    while True:\n\n        t0 = time.time()\n        # fetch the next batch and reset dataloader every epoch as necessary\n        try:\n            batch = next(data_iter)\n        except StopIteration:\n            data_iter = iter(train_loader)\n            batch = next(data_iter)\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n\n        # feed into the model\n        logits, loss = model(X, Y)\n\n        # calculate the gradient, clip it, update the weights\n        model.zero_grad(set_to_none=True)\n        loss.backward()\n        torch.nn.utils.clip_grad_norm_(model.parameters(), 1.0)\n        optimizer.step()\n        if args.device != 'cpu':\n            torch.cuda.synchronize()\n        t1 = time.time()\n\n        # logging\n        if step % 10 == 0:\n            print(f\"step {step} | loss {loss.item():.4f} | step time {(t1-t0)*1000:.2f}ms\")\n\n        # evaluate the model\n        if step > 0 and step % 500 == 0:\n            train_loss = evaluate(model, train_dataset, batch_size=100, max_batches=10)\n            test_loss  = evaluate(model, test_dataset,  batch_size=100, max_batches=10)\n            writer.add_scalar(\"Loss/train\", train_loss, step)\n            writer.add_scalar(\"Loss/test\", test_loss, step)\n            writer.flush()\n            print(f\"step {step} train loss: {train_loss} test loss: {test_loss}\")\n            # save the model to disk if it has improved\n            if best_loss is None or test_loss < best_loss:\n                out_path = os.path.join(args.work_dir, \"model.pt\")\n                print(f\"test loss {test_loss} is the best so far, saving model to {out_path}\")\n                torch.save(model.state_dict(), out_path)\n                best_loss = test_loss\n\n        # sample from the model\n        if step > 0 and step % 200 == 0:\n            print_samples(num=10)\n\n        step += 1\n", "previous_id": "8f79bd0126eaef5eb82d346c9f85ae20ea1c476a", "new_code_file": "\"\"\"\nyou give this script some words (one per line) and it will generate more things like it.\nuses super state of the art Transformer AI tech\nthis code is intended to be super hackable. tune it to your needs.\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport math\nimport argparse\nfrom dataclasses import dataclass\nfrom typing import List\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\nfrom torch.utils.data import Dataset\nfrom torch.utils.data.dataloader import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\n# -----------------------------------------------------------------------------\n# GPT (PyTorch) model definition\n\n@dataclass\nclass GPTConfig:\n    # size of the model\n    n_layer: int = 4\n    n_head: int = 4\n    n_embd: int = 64\n    vocab_size: int = None\n    block_size: int = None\n    # regularization\n    embd_pdrop: float = 0.1\n    resid_pdrop:float = 0.1\n    attn_pdrop:float = 0.1\n\n@dataclass\nclass TrainConfig:\n    # optimization parameters\n    learning_rate: float = 5e-4\n    weight_decay: float = 0.1 # only applied on matmul weights\n    betas: List[float] = (0.9, 0.99)\n\nclass CausalSelfAttention(nn.Module):\n    \"\"\"\n    A vanilla multi-head masked self-attention layer with a projection at the end.\n    It is possible to use torch.nn.MultiheadAttention here but I am including an\n    explicit implementation here to show that there is nothing too scary here.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.n_embd % config.n_head == 0\n        # key, query, value projections for all heads\n        self.key = nn.Linear(config.n_embd, config.n_embd)\n        self.query = nn.Linear(config.n_embd, config.n_embd)\n        self.value = nn.Linear(config.n_embd, config.n_embd)\n        # regularization\n        self.attn_drop = nn.Dropout(config.attn_pdrop)\n        self.resid_drop = nn.Dropout(config.resid_pdrop)\n        # output projection\n        self.proj = nn.Linear(config.n_embd, config.n_embd)\n        # causal mask to ensure that attention is only applied to the left in the input sequence\n        self.register_buffer(\"mask\", torch.tril(torch.ones(config.block_size, config.block_size))\n                                     .view(1, 1, config.block_size, config.block_size))\n        self.n_head = config.n_head\n\n    def forward(self, x):\n        B, T, C = x.size() # batch size, sequence length, embedding dimensionality (n_embd)\n\n        # calculate query, key, values for all heads in batch and move head forward to be the batch dim\n        k = self.key(x).view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        q = self.query(x).view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        v = self.value(x).view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n\n        # causal self-attention; Self-attend: (B, nh, T, hs) x (B, nh, hs, T) -> (B, nh, T, T)\n        att = (q @ k.transpose(-2, -1)) * (1.0 / math.sqrt(k.size(-1)))\n        att = att.masked_fill(self.mask[:,:,:T,:T] == 0, float('-inf'))\n        att = F.softmax(att, dim=-1)\n        att = self.attn_drop(att)\n        y = att @ v # (B, nh, T, T) x (B, nh, T, hs) -> (B, nh, T, hs)\n        y = y.transpose(1, 2).contiguous().view(B, T, C) # re-assemble all head outputs side by side\n\n        # output projection\n        y = self.resid_drop(self.proj(y))\n        return y\n\nclass Block(nn.Module):\n    \"\"\" an unassuming Transformer block \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.ln1 = nn.LayerNorm(config.n_embd)\n        self.ln2 = nn.LayerNorm(config.n_embd)\n        self.attn = CausalSelfAttention(config)\n        self.mlp = nn.Sequential(\n            nn.Linear(config.n_embd, 4 * config.n_embd),\n            nn.GELU(),\n            nn.Linear(4 * config.n_embd, config.n_embd),\n            nn.Dropout(config.resid_pdrop),\n        )\n\n    def forward(self, x):\n        x = x + self.attn(self.ln1(x))\n        x = x + self.mlp(self.ln2(x))\n        return x\n\nclass GPT(nn.Module):\n    \"\"\" the full GPT language model, with a context size of block_size \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n\n        # input embedding stem\n        self.tok_emb = nn.Embedding(config.vocab_size, config.n_embd)\n        self.pos_emb = nn.Parameter(torch.zeros(1, config.block_size, config.n_embd))\n        self.drop = nn.Dropout(config.embd_pdrop)\n        # transformer\n        self.blocks = nn.Sequential(*[Block(config) for _ in range(config.n_layer)])\n        # decoder head\n        self.ln_f = nn.LayerNorm(config.n_embd)\n        self.head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n\n        self.block_size = config.block_size\n        self.apply(self._init_weights)\n\n        print(\"number of parameters: %d\" % sum(p.numel() for p in self.parameters()))\n\n    def get_block_size(self):\n        return self.block_size\n\n    def _init_weights(self, module):\n        if isinstance(module, (nn.Linear, nn.Embedding)):\n            torch.nn.init.normal_(module.weight, mean=0.0, std=0.02)\n            if isinstance(module, nn.Linear) and module.bias is not None:\n                torch.nn.init.zeros_(module.bias)\n        elif isinstance(module, nn.LayerNorm):\n            torch.nn.init.zeros_(module.bias)\n            torch.nn.init.ones_(module.weight)\n        elif isinstance(module, GPT):\n            torch.nn.init.normal_(module.pos_emb, mean=0.0, std=0.02)\n\n    def configure_optimizers(self, train_config):\n        \"\"\"\n        This long function is unfortunately doing something very simple and is being very defensive:\n        We are separating out all parameters of the model into two buckets: those that will experience\n        weight decay for regularization and those that won't (biases, and layernorm/embedding weights).\n        We are then returning the PyTorch optimizer object.\n        \"\"\"\n\n        # separate out all parameters to those that will and won't experience regularizing weight decay\n        decay = set()\n        no_decay = set()\n        whitelist_weight_modules = (torch.nn.Linear, )\n        blacklist_weight_modules = (torch.nn.LayerNorm, torch.nn.Embedding)\n        for mn, m in self.named_modules():\n            for pn, p in m.named_parameters():\n                fpn = '%s.%s' % (mn, pn) if mn else pn # full param name\n\n                if pn.endswith('bias'):\n                    # all biases will not be decayed\n                    no_decay.add(fpn)\n                elif pn.endswith('weight') and isinstance(m, whitelist_weight_modules):\n                    # weights of whitelist modules will be weight decayed\n                    decay.add(fpn)\n                elif pn.endswith('weight') and isinstance(m, blacklist_weight_modules):\n                    # weights of blacklist modules will NOT be weight decayed\n                    no_decay.add(fpn)\n\n        # special case the position embedding parameter in the root GPT module as not decayed\n        no_decay.add('pos_emb')\n\n        # validate that we considered every parameter\n        param_dict = {pn: p for pn, p in self.named_parameters()}\n        inter_params = decay & no_decay\n        union_params = decay | no_decay\n        assert len(inter_params) == 0, \"parameters %s made it into both decay/no_decay sets!\" % (str(inter_params), )\n        assert len(param_dict.keys() - union_params) == 0, \"parameters %s were not separated into either decay/no_decay set!\" \\\n                                                    % (str(param_dict.keys() - union_params), )\n\n        # create the pytorch optimizer object\n        optim_groups = [\n            {\"params\": [param_dict[pn] for pn in sorted(list(decay))], \"weight_decay\": train_config.weight_decay},\n            {\"params\": [param_dict[pn] for pn in sorted(list(no_decay))], \"weight_decay\": 0.0},\n        ]\n        optimizer = torch.optim.AdamW(optim_groups, lr=train_config.learning_rate, betas=train_config.betas)\n        return optimizer\n\n    def forward(self, idx, targets=None):\n        b, t = idx.size()\n        assert t <= self.block_size, \"Cannot forward, input tensor sequence is longer than model block_size.\"\n\n        # forward the GPT model\n        token_embeddings = self.tok_emb(idx) # each index maps to a (learnable) vector\n        position_embeddings = self.pos_emb[:, :t, :] # each position maps to a (learnable) vector\n        x = self.drop(token_embeddings + position_embeddings)\n        x = self.blocks(x)\n        x = self.ln_f(x)\n        logits = self.head(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n# helper functions for evaluating and sampling from the model\n\ndef top_k_logits(logits, k):\n    \"\"\"\n    takes logits (N,D) and returns logits (N,D), but in each row only\n    the top-k are kept and the rest of the entries are set to -inf.\n    \"\"\"\n    v, ix = torch.topk(logits, k, dim=-1)\n    out = logits.clone()\n    out[out < v[:, [-1]]] = -float('Inf')\n    return out\n\n@torch.inference_mode()\ndef sample(model, x, steps, temperature=1.0, top_k=None):\n    \"\"\"\n    take a conditioning sequence of indices in x (b,t) and predict next tokens\n    in the sequence, feeding the predictions back into the model each step.\n    \"\"\"\n    block_size = model.get_block_size()\n    model.eval()\n    for k in range(steps):\n        # crop the context, if necessary\n        x_cond = x if x.size(1) <= block_size else x[:, -block_size:]\n        # feed the context into the model to get logits at each step\n        logits, _ = model(x_cond)\n        # pluck the logits at the final step and scale by temperature\n        logits = logits[:, -1, :] / temperature\n        # optionally crop probabilities to only the top k options\n        if top_k is not None:\n            logits = top_k_logits(logits, top_k)\n        # apply softmax to convert to probabilities\n        probs = F.softmax(logits, dim=-1)\n        # sample from the distribution or take the most likely\n        ix = torch.multinomial(probs, num_samples=1)\n        # append to the sequence and continue\n        x = torch.cat((x, ix), dim=1)\n    model.train()\n    return x\n\ndef print_samples(num=10):\n    \"\"\" samples from the model and pretty prints the decoded samples \"\"\"\n    X_init = torch.zeros(num, 1, dtype=torch.long).to(args.device)\n    top_k = args.top_k if args.top_k != -1 else None\n    steps = train_dataset.get_output_length() - 1 # -1 because we already start with <START> token (index 0)\n    X_samp = sample(model, X_init, steps, top_k=top_k).to('cpu')\n    unique_samples = []\n    had_samples = []\n    for i in range(X_samp.size(0)):\n        # get the i'th row of sampled integers, as python list\n        row = X_samp[i, 1:].tolist() # note: we need to crop out the first <START> token\n        # token 0 is the <STOP> token, so we crop the output sequence at that point\n        crop_index = row.index(0) if 0 in row else len(row)\n        row = row[:crop_index]\n        word_samp = train_dataset.decode(row)\n        # separately track samples that we have and have not seen before\n        word_have = train_dataset.contains(word_samp) or test_dataset.contains(word_samp)\n        sample_list = had_samples if word_have else unique_samples\n        sample_list.append(word_samp)\n\n    print('-'*80)\n    print(f'{len(had_samples)} Samples that were found in input dataset:')\n    for word in had_samples:\n        print(word)\n    print(f'{len(unique_samples)} Samples that were NOT found in input dataset:')\n    for word in unique_samples:\n        print(word)\n    print('-'*80)\n\n@torch.inference_mode()\ndef evaluate(model, dataset, batch_size=50, max_batches=None):\n    model.eval()\n    loader = DataLoader(dataset, shuffle=True, batch_size=batch_size, num_workers=0)\n    losses = []\n    for i, batch in enumerate(loader):\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n        logits, loss = model(X, Y)\n        losses.append(loss.item())\n        if max_batches is not None and i >= max_batches:\n            break\n    mean_loss = torch.tensor(losses).mean().item()\n    model.train() # reset model back to training mode\n    return mean_loss\n\n# -----------------------------------------------------------------------------\n# helper functions for creating the training and test Datasets that emit words\n\nclass CharDataset(Dataset):\n\n    def __init__(self, words, chars, max_word_length):\n        self.words = words\n        self.chars = chars\n        self.max_word_length = max_word_length\n        self.stoi = {ch:i+1 for i,ch in enumerate(chars)}\n        self.itos = {i:s for s,i in self.stoi.items()} # inverse mapping\n\n    def __len__(self):\n        return len(self.words)\n\n    def contains(self, word):\n        return word in self.words\n\n    def get_vocab_size(self):\n        return len(self.chars) + 1 # all the possible characters and special 0 token\n\n    def get_output_length(self):\n        return self.max_word_length + 1 # <START> token followed by words\n\n    def encode(self, word):\n        ix = torch.tensor([self.stoi[w] for w in word], dtype=torch.long)\n        return ix\n\n    def decode(self, ix):\n        word = ''.join(self.itos[i] for i in ix)\n        return word\n\n    def __getitem__(self, idx):\n        word = self.words[idx]\n        ix = self.encode(word)\n        x = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        y = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        x[1:1+len(ix)] = ix\n        y[:len(ix)] = ix\n        y[len(ix)+1:] = -1 # index -1 will mask the loss at the inactive locations\n        return x, y\n\ndef create_datasets(input_file):\n\n    # preprocessing of the input text file\n    with open(input_file, 'r') as f:\n        data = f.read()\n    words = data.splitlines()\n    words = [w.strip() for w in words] # get rid of any leading or trailing white space\n    words = [w for w in words if w] # get rid of any empty strings\n    chars = sorted(list(set(''.join(words)))) # all the possible characters\n    max_word_length = max(len(w) for w in words)\n    print(f\"number of examples in the dataset: {len(words)}\")\n    print(f\"max word length: {max_word_length}\")\n    print(f\"number of unique characters in the vocabulary: {len(chars)}\")\n    print(\"vocabulary:\")\n    print(''.join(chars))\n\n    # partition the input data into a training and the test set\n    test_set_size = min(1000, int(len(words) * 0.1)) # 10% of the training set, or up to 1000 examples\n    rp = torch.randperm(len(words)).tolist()\n    train_words = [words[i] for i in rp[:-test_set_size]]\n    test_words = [words[i] for i in rp[-test_set_size:]]\n    print(f\"split up the dataset into {len(train_words)} training examples and {len(test_words)} test examples\")\n\n    # wrap in dataset objects\n    train_dataset = CharDataset(train_words, chars, max_word_length)\n    test_dataset = CharDataset(test_words, chars, max_word_length)\n\n    return train_dataset, test_dataset\n\n# -----------------------------------------------------------------------------\nif __name__ == '__main__':\n\n    # parse command line args\n    parser = argparse.ArgumentParser(description=\"Make More\")\n    # system/input/output\n    parser.add_argument('--input-file', '-i', type=str, default='input.txt', help=\"input file with things one per line\")\n    parser.add_argument('--work-dir', '-o', type=str, default='out', help=\"output working directory\")\n    parser.add_argument('--resume', action='store_true', help=\"when this flag is used, we will resume optimization from existing model in the workdir\")\n    parser.add_argument('--num-workers', '-n', type=int, default=1, help=\"number of data workers for both train/test\")\n    parser.add_argument('--device', type=str, default='cpu', help=\"device to use for compute, e.g. cpu|cuda|mps\")\n    parser.add_argument('--seed', type=int, default=1337, help=\"seed\")\n    # sampling\n    parser.add_argument('--sample-only', action='store_true', help=\"just sample from the model and quit, don't train\")\n    parser.add_argument('--top-k', type=int, default=-1, help=\"top-k for sampling, -1 means no top-k\")\n    # model\n    parser.add_argument('--n-layer', type=int, default=4, help=\"number of layers in the transformer\")\n    parser.add_argument('--n-head', type=int, default=4, help=\"number of heads in the transformer\")\n    parser.add_argument('--n-embd', type=int, default=64, help=\"number of feature channels in the transformer\")\n    # optimization\n    parser.add_argument('--batch-size', '-b', type=int, default=32, help=\"batch size during optimization\")\n    parser.add_argument('--learning-rate', '-l', type=float, default=5e-4, help=\"learning rate\")\n    parser.add_argument('--dropout', '-d', type=float, default=0.1, help=\"dropout rate\")\n    parser.add_argument('--weight-decay', '-w', type=float, default=0.1, help=\"weight decay\")\n    args = parser.parse_args()\n    print(vars(args))\n\n    # system inits\n    torch.manual_seed(args.seed)\n    torch.cuda.manual_seed_all(args.seed)\n    torch.use_deterministic_algorithms(True)\n    os.makedirs(args.work_dir, exist_ok=True)\n    writer = SummaryWriter(log_dir=args.work_dir)\n\n    # init datasets\n    train_dataset, test_dataset = create_datasets(args.input_file)\n\n    # init model\n    config = GPTConfig(vocab_size=train_dataset.get_vocab_size(), block_size=train_dataset.get_output_length(),\n                       n_layer=args.n_layer, n_head=args.n_head, n_embd=args.n_embd,\n                       embd_pdrop=args.dropout, attn_pdrop=args.dropout, resid_pdrop=args.dropout)\n    model = GPT(config)\n    model.to(args.device)\n    print(f\"model #params: {sum(p.numel() for p in model.parameters())}\")\n    if args.resume or args.sample_only: # note: if we sample-only then we also assume we're resuming\n        print(\"resuming from existing model in the workdir\")\n        model.load_state_dict(torch.load(os.path.join(args.work_dir, 'model.pt')))\n    if args.sample_only:\n        print_samples(num=50)\n        sys.exit()\n\n    # init optimizer\n    train_config = TrainConfig(learning_rate=args.learning_rate, weight_decay=args.weight_decay)\n    optimizer = model.configure_optimizers(train_config)\n\n    # init dataloader\n    train_sampler = torch.utils.data.RandomSampler(train_dataset, replacement=True, num_samples=int(1e10))\n    train_loader = DataLoader(train_dataset, batch_size=args.batch_size, pin_memory=True,\n                              num_workers=args.num_workers, sampler=train_sampler)\n    data_iter = iter(train_loader)\n\n    # training loop\n    best_loss = None\n    step = 0\n    while True:\n\n        t0 = time.time()\n        # fetch the next batch and reset dataloader every epoch as necessary\n        try:\n            batch = next(data_iter)\n        except StopIteration:\n            data_iter = iter(train_loader)\n            batch = next(data_iter)\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n\n        # feed into the model\n        logits, loss = model(X, Y)\n\n        # calculate the gradient, clip it, update the weights\n        model.zero_grad(set_to_none=True)\n        loss.backward()\n        torch.nn.utils.clip_grad_norm_(model.parameters(), 1.0)\n        optimizer.step()\n        if args.device == 'cuda':\n            torch.cuda.synchronize()\n        t1 = time.time()\n\n        # logging\n        if step % 10 == 0:\n            print(f\"step {step} | loss {loss.item():.4f} | step time {(t1-t0)*1000:.2f}ms\")\n\n        # evaluate the model\n        if step > 0 and step % 500 == 0:\n            train_loss = evaluate(model, train_dataset, batch_size=100, max_batches=10)\n            test_loss  = evaluate(model, test_dataset,  batch_size=100, max_batches=10)\n            writer.add_scalar(\"Loss/train\", train_loss, step)\n            writer.add_scalar(\"Loss/test\", test_loss, step)\n            writer.flush()\n            print(f\"step {step} train loss: {train_loss} test loss: {test_loss}\")\n            # save the model to disk if it has improved\n            if best_loss is None or test_loss < best_loss:\n                out_path = os.path.join(args.work_dir, \"model.pt\")\n                print(f\"test loss {test_loss} is the best so far, saving model to {out_path}\")\n                torch.save(model.state_dict(), out_path)\n                best_loss = test_loss\n\n        # sample from the model\n        if step > 0 and step % 200 == 0:\n            print_samples(num=10)\n\n        step += 1\n", "diff": "@@ -372,7 +372,7 @@ def create_datasets(input_file):\n     parser.add_argument('--work-dir', '-o', type=str, default='out', help=\"output working directory\")\n     parser.add_argument('--resume', action='store_true', help=\"when this flag is used, we will resume optimization from existing model in the workdir\")\n     parser.add_argument('--num-workers', '-n', type=int, default=1, help=\"number of data workers for both train/test\")\n-    parser.add_argument('--device', type=str, default='cpu', help=\"device to use for compute, e.g. cpu|cuda|m1\")\n+    parser.add_argument('--device', type=str, default='cpu', help=\"device to use for compute, e.g. cpu|cuda|mps\")\n     parser.add_argument('--seed', type=int, default=1337, help=\"seed\")\n     # sampling\n     parser.add_argument('--sample-only', action='store_true', help=\"just sample from the model and quit, don't train\")\n@@ -446,7 +446,7 @@ def create_datasets(input_file):\n         loss.backward()\n         torch.nn.utils.clip_grad_norm_(model.parameters(), 1.0)\n         optimizer.step()\n-        if args.device != 'cpu':\n+        if args.device == 'cuda':\n             torch.cuda.synchronize()\n         t1 = time.time()\n ", "status": "modified"}, {"commit_id": "8f79bd0126eaef5eb82d346c9f85ae20ea1c476a", "commit_message": "first commit", "relative_path": "makemore.py", "previous_code_file": null, "new_code_file": "\"\"\"\nyou give this script some words (one per line) and it will generate more things like it.\nuses super state of the art Transformer AI tech\nthis code is intended to be super hackable. tune it to your needs.\n\"\"\"\n\nimport os\nimport sys\nimport time\nimport math\nimport argparse\nfrom dataclasses import dataclass\nfrom typing import List\n\nimport torch\nimport torch.nn as nn\nfrom torch.nn import functional as F\nfrom torch.utils.data import Dataset\nfrom torch.utils.data.dataloader import DataLoader\nfrom torch.utils.tensorboard import SummaryWriter\n\n# -----------------------------------------------------------------------------\n# GPT (PyTorch) model definition\n\n@dataclass\nclass GPTConfig:\n    # size of the model\n    n_layer: int = 4\n    n_head: int = 4\n    n_embd: int = 64\n    vocab_size: int = None\n    block_size: int = None\n    # regularization\n    embd_pdrop: float = 0.1\n    resid_pdrop:float = 0.1\n    attn_pdrop:float = 0.1\n\n@dataclass\nclass TrainConfig:\n    # optimization parameters\n    learning_rate: float = 5e-4\n    weight_decay: float = 0.1 # only applied on matmul weights\n    betas: List[float] = (0.9, 0.99)\n\nclass CausalSelfAttention(nn.Module):\n    \"\"\"\n    A vanilla multi-head masked self-attention layer with a projection at the end.\n    It is possible to use torch.nn.MultiheadAttention here but I am including an\n    explicit implementation here to show that there is nothing too scary here.\n    \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        assert config.n_embd % config.n_head == 0\n        # key, query, value projections for all heads\n        self.key = nn.Linear(config.n_embd, config.n_embd)\n        self.query = nn.Linear(config.n_embd, config.n_embd)\n        self.value = nn.Linear(config.n_embd, config.n_embd)\n        # regularization\n        self.attn_drop = nn.Dropout(config.attn_pdrop)\n        self.resid_drop = nn.Dropout(config.resid_pdrop)\n        # output projection\n        self.proj = nn.Linear(config.n_embd, config.n_embd)\n        # causal mask to ensure that attention is only applied to the left in the input sequence\n        self.register_buffer(\"mask\", torch.tril(torch.ones(config.block_size, config.block_size))\n                                     .view(1, 1, config.block_size, config.block_size))\n        self.n_head = config.n_head\n\n    def forward(self, x):\n        B, T, C = x.size() # batch size, sequence length, embedding dimensionality (n_embd)\n\n        # calculate query, key, values for all heads in batch and move head forward to be the batch dim\n        k = self.key(x).view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        q = self.query(x).view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n        v = self.value(x).view(B, T, self.n_head, C // self.n_head).transpose(1, 2) # (B, nh, T, hs)\n\n        # causal self-attention; Self-attend: (B, nh, T, hs) x (B, nh, hs, T) -> (B, nh, T, T)\n        att = (q @ k.transpose(-2, -1)) * (1.0 / math.sqrt(k.size(-1)))\n        att = att.masked_fill(self.mask[:,:,:T,:T] == 0, float('-inf'))\n        att = F.softmax(att, dim=-1)\n        att = self.attn_drop(att)\n        y = att @ v # (B, nh, T, T) x (B, nh, T, hs) -> (B, nh, T, hs)\n        y = y.transpose(1, 2).contiguous().view(B, T, C) # re-assemble all head outputs side by side\n\n        # output projection\n        y = self.resid_drop(self.proj(y))\n        return y\n\nclass Block(nn.Module):\n    \"\"\" an unassuming Transformer block \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n        self.ln1 = nn.LayerNorm(config.n_embd)\n        self.ln2 = nn.LayerNorm(config.n_embd)\n        self.attn = CausalSelfAttention(config)\n        self.mlp = nn.Sequential(\n            nn.Linear(config.n_embd, 4 * config.n_embd),\n            nn.GELU(),\n            nn.Linear(4 * config.n_embd, config.n_embd),\n            nn.Dropout(config.resid_pdrop),\n        )\n\n    def forward(self, x):\n        x = x + self.attn(self.ln1(x))\n        x = x + self.mlp(self.ln2(x))\n        return x\n\nclass GPT(nn.Module):\n    \"\"\" the full GPT language model, with a context size of block_size \"\"\"\n\n    def __init__(self, config):\n        super().__init__()\n\n        # input embedding stem\n        self.tok_emb = nn.Embedding(config.vocab_size, config.n_embd)\n        self.pos_emb = nn.Parameter(torch.zeros(1, config.block_size, config.n_embd))\n        self.drop = nn.Dropout(config.embd_pdrop)\n        # transformer\n        self.blocks = nn.Sequential(*[Block(config) for _ in range(config.n_layer)])\n        # decoder head\n        self.ln_f = nn.LayerNorm(config.n_embd)\n        self.head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n\n        self.block_size = config.block_size\n        self.apply(self._init_weights)\n\n        print(\"number of parameters: %d\" % sum(p.numel() for p in self.parameters()))\n\n    def get_block_size(self):\n        return self.block_size\n\n    def _init_weights(self, module):\n        if isinstance(module, (nn.Linear, nn.Embedding)):\n            torch.nn.init.normal_(module.weight, mean=0.0, std=0.02)\n            if isinstance(module, nn.Linear) and module.bias is not None:\n                torch.nn.init.zeros_(module.bias)\n        elif isinstance(module, nn.LayerNorm):\n            torch.nn.init.zeros_(module.bias)\n            torch.nn.init.ones_(module.weight)\n        elif isinstance(module, GPT):\n            torch.nn.init.normal_(module.pos_emb, mean=0.0, std=0.02)\n\n    def configure_optimizers(self, train_config):\n        \"\"\"\n        This long function is unfortunately doing something very simple and is being very defensive:\n        We are separating out all parameters of the model into two buckets: those that will experience\n        weight decay for regularization and those that won't (biases, and layernorm/embedding weights).\n        We are then returning the PyTorch optimizer object.\n        \"\"\"\n\n        # separate out all parameters to those that will and won't experience regularizing weight decay\n        decay = set()\n        no_decay = set()\n        whitelist_weight_modules = (torch.nn.Linear, )\n        blacklist_weight_modules = (torch.nn.LayerNorm, torch.nn.Embedding)\n        for mn, m in self.named_modules():\n            for pn, p in m.named_parameters():\n                fpn = '%s.%s' % (mn, pn) if mn else pn # full param name\n\n                if pn.endswith('bias'):\n                    # all biases will not be decayed\n                    no_decay.add(fpn)\n                elif pn.endswith('weight') and isinstance(m, whitelist_weight_modules):\n                    # weights of whitelist modules will be weight decayed\n                    decay.add(fpn)\n                elif pn.endswith('weight') and isinstance(m, blacklist_weight_modules):\n                    # weights of blacklist modules will NOT be weight decayed\n                    no_decay.add(fpn)\n\n        # special case the position embedding parameter in the root GPT module as not decayed\n        no_decay.add('pos_emb')\n\n        # validate that we considered every parameter\n        param_dict = {pn: p for pn, p in self.named_parameters()}\n        inter_params = decay & no_decay\n        union_params = decay | no_decay\n        assert len(inter_params) == 0, \"parameters %s made it into both decay/no_decay sets!\" % (str(inter_params), )\n        assert len(param_dict.keys() - union_params) == 0, \"parameters %s were not separated into either decay/no_decay set!\" \\\n                                                    % (str(param_dict.keys() - union_params), )\n\n        # create the pytorch optimizer object\n        optim_groups = [\n            {\"params\": [param_dict[pn] for pn in sorted(list(decay))], \"weight_decay\": train_config.weight_decay},\n            {\"params\": [param_dict[pn] for pn in sorted(list(no_decay))], \"weight_decay\": 0.0},\n        ]\n        optimizer = torch.optim.AdamW(optim_groups, lr=train_config.learning_rate, betas=train_config.betas)\n        return optimizer\n\n    def forward(self, idx, targets=None):\n        b, t = idx.size()\n        assert t <= self.block_size, \"Cannot forward, input tensor sequence is longer than model block_size.\"\n\n        # forward the GPT model\n        token_embeddings = self.tok_emb(idx) # each index maps to a (learnable) vector\n        position_embeddings = self.pos_emb[:, :t, :] # each position maps to a (learnable) vector\n        x = self.drop(token_embeddings + position_embeddings)\n        x = self.blocks(x)\n        x = self.ln_f(x)\n        logits = self.head(x)\n\n        # if we are given some desired targets also calculate the loss\n        loss = None\n        if targets is not None:\n            loss = F.cross_entropy(logits.view(-1, logits.size(-1)), targets.view(-1), ignore_index=-1)\n\n        return logits, loss\n\n# -----------------------------------------------------------------------------\n# helper functions for evaluating and sampling from the model\n\ndef top_k_logits(logits, k):\n    \"\"\"\n    takes logits (N,D) and returns logits (N,D), but in each row only\n    the top-k are kept and the rest of the entries are set to -inf.\n    \"\"\"\n    v, ix = torch.topk(logits, k, dim=-1)\n    out = logits.clone()\n    out[out < v[:, [-1]]] = -float('Inf')\n    return out\n\n@torch.inference_mode()\ndef sample(model, x, steps, temperature=1.0, top_k=None):\n    \"\"\"\n    take a conditioning sequence of indices in x (b,t) and predict next tokens\n    in the sequence, feeding the predictions back into the model each step.\n    \"\"\"\n    block_size = model.get_block_size()\n    model.eval()\n    for k in range(steps):\n        # crop the context, if necessary\n        x_cond = x if x.size(1) <= block_size else x[:, -block_size:]\n        # feed the context into the model to get logits at each step\n        logits, _ = model(x_cond)\n        # pluck the logits at the final step and scale by temperature\n        logits = logits[:, -1, :] / temperature\n        # optionally crop probabilities to only the top k options\n        if top_k is not None:\n            logits = top_k_logits(logits, top_k)\n        # apply softmax to convert to probabilities\n        probs = F.softmax(logits, dim=-1)\n        # sample from the distribution or take the most likely\n        ix = torch.multinomial(probs, num_samples=1)\n        # append to the sequence and continue\n        x = torch.cat((x, ix), dim=1)\n    model.train()\n    return x\n\ndef print_samples(num=10):\n    \"\"\" samples from the model and pretty prints the decoded samples \"\"\"\n    X_init = torch.zeros(num, 1, dtype=torch.long).to(args.device)\n    top_k = args.top_k if args.top_k != -1 else None\n    steps = train_dataset.get_output_length() - 1 # -1 because we already start with <START> token (index 0)\n    X_samp = sample(model, X_init, steps, top_k=top_k).to('cpu')\n    unique_samples = []\n    had_samples = []\n    for i in range(X_samp.size(0)):\n        # get the i'th row of sampled integers, as python list\n        row = X_samp[i, 1:].tolist() # note: we need to crop out the first <START> token\n        # token 0 is the <STOP> token, so we crop the output sequence at that point\n        crop_index = row.index(0) if 0 in row else len(row)\n        row = row[:crop_index]\n        word_samp = train_dataset.decode(row)\n        # separately track samples that we have and have not seen before\n        word_have = train_dataset.contains(word_samp) or test_dataset.contains(word_samp)\n        sample_list = had_samples if word_have else unique_samples\n        sample_list.append(word_samp)\n\n    print('-'*80)\n    print(f'{len(had_samples)} Samples that were found in input dataset:')\n    for word in had_samples:\n        print(word)\n    print(f'{len(unique_samples)} Samples that were NOT found in input dataset:')\n    for word in unique_samples:\n        print(word)\n    print('-'*80)\n\n@torch.inference_mode()\ndef evaluate(model, dataset, batch_size=50, max_batches=None):\n    model.eval()\n    loader = DataLoader(dataset, shuffle=True, batch_size=batch_size, num_workers=0)\n    losses = []\n    for i, batch in enumerate(loader):\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n        logits, loss = model(X, Y)\n        losses.append(loss.item())\n        if max_batches is not None and i >= max_batches:\n            break\n    mean_loss = torch.tensor(losses).mean().item()\n    model.train() # reset model back to training mode\n    return mean_loss\n\n# -----------------------------------------------------------------------------\n# helper functions for creating the training and test Datasets that emit words\n\nclass CharDataset(Dataset):\n\n    def __init__(self, words, chars, max_word_length):\n        self.words = words\n        self.chars = chars\n        self.max_word_length = max_word_length\n        self.stoi = {ch:i+1 for i,ch in enumerate(chars)}\n        self.itos = {i:s for s,i in self.stoi.items()} # inverse mapping\n\n    def __len__(self):\n        return len(self.words)\n\n    def contains(self, word):\n        return word in self.words\n\n    def get_vocab_size(self):\n        return len(self.chars) + 1 # all the possible characters and special 0 token\n\n    def get_output_length(self):\n        return self.max_word_length + 1 # <START> token followed by words\n\n    def encode(self, word):\n        ix = torch.tensor([self.stoi[w] for w in word], dtype=torch.long)\n        return ix\n\n    def decode(self, ix):\n        word = ''.join(self.itos[i] for i in ix)\n        return word\n\n    def __getitem__(self, idx):\n        word = self.words[idx]\n        ix = self.encode(word)\n        x = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        y = torch.zeros(self.max_word_length + 1, dtype=torch.long)\n        x[1:1+len(ix)] = ix\n        y[:len(ix)] = ix\n        y[len(ix)+1:] = -1 # index -1 will mask the loss at the inactive locations\n        return x, y\n\ndef create_datasets(input_file):\n\n    # preprocessing of the input text file\n    with open(input_file, 'r') as f:\n        data = f.read()\n    words = data.splitlines()\n    words = [w.strip() for w in words] # get rid of any leading or trailing white space\n    words = [w for w in words if w] # get rid of any empty strings\n    chars = sorted(list(set(''.join(words)))) # all the possible characters\n    max_word_length = max(len(w) for w in words)\n    print(f\"number of examples in the dataset: {len(words)}\")\n    print(f\"max word length: {max_word_length}\")\n    print(f\"number of unique characters in the vocabulary: {len(chars)}\")\n    print(\"vocabulary:\")\n    print(''.join(chars))\n\n    # partition the input data into a training and the test set\n    test_set_size = min(1000, int(len(words) * 0.1)) # 10% of the training set, or up to 1000 examples\n    rp = torch.randperm(len(words)).tolist()\n    train_words = [words[i] for i in rp[:-test_set_size]]\n    test_words = [words[i] for i in rp[-test_set_size:]]\n    print(f\"split up the dataset into {len(train_words)} training examples and {len(test_words)} test examples\")\n\n    # wrap in dataset objects\n    train_dataset = CharDataset(train_words, chars, max_word_length)\n    test_dataset = CharDataset(test_words, chars, max_word_length)\n\n    return train_dataset, test_dataset\n\n# -----------------------------------------------------------------------------\nif __name__ == '__main__':\n\n    # parse command line args\n    parser = argparse.ArgumentParser(description=\"Make More\")\n    # system/input/output\n    parser.add_argument('--input-file', '-i', type=str, default='input.txt', help=\"input file with things one per line\")\n    parser.add_argument('--work-dir', '-o', type=str, default='out', help=\"output working directory\")\n    parser.add_argument('--resume', action='store_true', help=\"when this flag is used, we will resume optimization from existing model in the workdir\")\n    parser.add_argument('--num-workers', '-n', type=int, default=1, help=\"number of data workers for both train/test\")\n    parser.add_argument('--device', type=str, default='cpu', help=\"device to use for compute, e.g. cpu|cuda|m1\")\n    parser.add_argument('--seed', type=int, default=1337, help=\"seed\")\n    # sampling\n    parser.add_argument('--sample-only', action='store_true', help=\"just sample from the model and quit, don't train\")\n    parser.add_argument('--top-k', type=int, default=-1, help=\"top-k for sampling, -1 means no top-k\")\n    # model\n    parser.add_argument('--n-layer', type=int, default=4, help=\"number of layers in the transformer\")\n    parser.add_argument('--n-head', type=int, default=4, help=\"number of heads in the transformer\")\n    parser.add_argument('--n-embd', type=int, default=64, help=\"number of feature channels in the transformer\")\n    # optimization\n    parser.add_argument('--batch-size', '-b', type=int, default=32, help=\"batch size during optimization\")\n    parser.add_argument('--learning-rate', '-l', type=float, default=5e-4, help=\"learning rate\")\n    parser.add_argument('--dropout', '-d', type=float, default=0.1, help=\"dropout rate\")\n    parser.add_argument('--weight-decay', '-w', type=float, default=0.1, help=\"weight decay\")\n    args = parser.parse_args()\n    print(vars(args))\n\n    # system inits\n    torch.manual_seed(args.seed)\n    torch.cuda.manual_seed_all(args.seed)\n    torch.use_deterministic_algorithms(True)\n    os.makedirs(args.work_dir, exist_ok=True)\n    writer = SummaryWriter(log_dir=args.work_dir)\n\n    # init datasets\n    train_dataset, test_dataset = create_datasets(args.input_file)\n\n    # init model\n    config = GPTConfig(vocab_size=train_dataset.get_vocab_size(), block_size=train_dataset.get_output_length(),\n                       n_layer=args.n_layer, n_head=args.n_head, n_embd=args.n_embd,\n                       embd_pdrop=args.dropout, attn_pdrop=args.dropout, resid_pdrop=args.dropout)\n    model = GPT(config)\n    model.to(args.device)\n    print(f\"model #params: {sum(p.numel() for p in model.parameters())}\")\n    if args.resume or args.sample_only: # note: if we sample-only then we also assume we're resuming\n        print(\"resuming from existing model in the workdir\")\n        model.load_state_dict(torch.load(os.path.join(args.work_dir, 'model.pt')))\n    if args.sample_only:\n        print_samples(num=50)\n        sys.exit()\n\n    # init optimizer\n    train_config = TrainConfig(learning_rate=args.learning_rate, weight_decay=args.weight_decay)\n    optimizer = model.configure_optimizers(train_config)\n\n    # init dataloader\n    train_sampler = torch.utils.data.RandomSampler(train_dataset, replacement=True, num_samples=int(1e10))\n    train_loader = DataLoader(train_dataset, batch_size=args.batch_size, pin_memory=True,\n                              num_workers=args.num_workers, sampler=train_sampler)\n    data_iter = iter(train_loader)\n\n    # training loop\n    best_loss = None\n    step = 0\n    while True:\n\n        t0 = time.time()\n        # fetch the next batch and reset dataloader every epoch as necessary\n        try:\n            batch = next(data_iter)\n        except StopIteration:\n            data_iter = iter(train_loader)\n            batch = next(data_iter)\n        batch = [t.to(args.device) for t in batch]\n        X, Y = batch\n\n        # feed into the model\n        logits, loss = model(X, Y)\n\n        # calculate the gradient, clip it, update the weights\n        model.zero_grad(set_to_none=True)\n        loss.backward()\n        torch.nn.utils.clip_grad_norm_(model.parameters(), 1.0)\n        optimizer.step()\n        if args.device != 'cpu':\n            torch.cuda.synchronize()\n        t1 = time.time()\n\n        # logging\n        if step % 10 == 0:\n            print(f\"step {step} | loss {loss.item():.4f} | step time {(t1-t0)*1000:.2f}ms\")\n\n        # evaluate the model\n        if step > 0 and step % 500 == 0:\n            train_loss = evaluate(model, train_dataset, batch_size=100, max_batches=10)\n            test_loss  = evaluate(model, test_dataset,  batch_size=100, max_batches=10)\n            writer.add_scalar(\"Loss/train\", train_loss, step)\n            writer.add_scalar(\"Loss/test\", test_loss, step)\n            writer.flush()\n            print(f\"step {step} train loss: {train_loss} test loss: {test_loss}\")\n            # save the model to disk if it has improved\n            if best_loss is None or test_loss < best_loss:\n                out_path = os.path.join(args.work_dir, \"model.pt\")\n                print(f\"test loss {test_loss} is the best so far, saving model to {out_path}\")\n                torch.save(model.state_dict(), out_path)\n                best_loss = test_loss\n\n        # sample from the model\n        if step > 0 and step % 200 == 0:\n            print_samples(num=10)\n\n        step += 1\n", "diff": null, "status": "added"}]